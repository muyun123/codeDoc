# Vue.js

## 安装

(l) script

如果项目直接通过script加载CDN文件,代码示例如下：
```js
<scrip七src="http://webapp.didistatic.com/static/webapp/shield/z/vue/vue/1.0.24/vue. min.js"></script>
```
(2) npm

如果项目npm管理依赖,则可以使用npm来安装Vue,执行如下命令：
```js
$ npm i vue --save-dev
```
(3) bower

如果项目基于bower管理依赖,则可以使用bower来安装Vue,执行如下命令：
```js
$ bower i vue --save-dev
```

## 第一个Hello World程序

每一次学习新框架,都必将经历过Hello World程序,我们用Vue.js来输出一个微信内滴滴 打车的WebApp首页Tab,代码示例如下：
```js
<div id="app"> 
    <ul>
        <li v-for="tab in tabs">
            {{ tab. text}} 
        </li>
    </ul>
</div>

new Vue ({
el: 'app', 
data: {
    tabs: [
        { text: '巴士' },
        {text: '快车' },
        { text: '专车' },
        { text: '顺风车' },
        { text: '出租车' },
        { text: '代驾' }
    ]
}})
```

## 语法

### 插值

文本插值是最基本的形式,使用双大括号{{}}(类似千Mustache,所以本文中称作Mustache 标签),代码示例如下：
```js
<span>Text{{text}}</span>
```
例子中的标签{{text}}将会被相应的数据对象text属性的值替换掉,当text的值改变时,文 本中的值也会联动地发生变化。有时候只需渲染一次数据,后续数据变化不再关心,可以通过 "*"实现,代码示例如下：
```js
<span>Text: {{*text} } </ span>
```
双大括号标签会把里面的值全部当作字符串来处理,如果值是HTML片段,则可以使用三 个大括号来绑定,代码示例如下：
```js
<div>Logo: {{{logo}}}</div> logo :'<span>DDFE</ span>'
```
双大括号标签还可以放在HTML标签内,示例如下：
```js
<li data-id='{{id}}'></li>
```
总之,Vue.js提供了一系列文本渲染方式,足够我们应对日常的模板渲染情况。需要注意的是,Vue指令和自身特性内是不可以插值的,如果用错了地方,Vue.js会发出警告。 

### 表达式

Mustache标签也接受表达式形式的值,表达式可由JavaScript表达式和过滤器构成。过滤 器可以没有,也可以有多个。

表达式是各种数值、变量、运算符的综合体。简单的表达式可以是常量或者变量名称。表 达式的值是其运算结果,代码示例如下：
```js
< ! -- JS表达式－－>

{ { cents/100 } } //在原值的基础上除以100

{ { true? 1 : 0 } } //值为真,则渲染出l,否则渲染出0 {{example.split(",")}}

<－－无效示例－－>

{ { var logo ='DDFE'}} //这是语句,不是表达式

{{if(true) return'DDFE'}} //条件控制语句是不支待的,可以使用三元式
```
类似Linux中的管道,Vuejs允许在表达式后面添加过滤符,代码示例如下：
```js
{ { example | to Uppercase}}
```
这里toUpperCase就是过滤器,其本质是一个JS函数,返回字符串的全大写形式。Vue.js 允许过滤器串联,代码示例如下：
```js
{ { example | filterA | fil七erB}}
```
过滤器还支持传入参数,代码示例如下：
```js
{ { example | filter a b} }

这里a和b均为参数、用空格隔开。
```
Vue.js还提供了许多内置的过滤器,第6章将对此进行详细介绍。

### 指令

指令是带有v－前缀的特殊特性,其值限定为绑定表达式,也就是JavaScript表达式和过滤 器。指令的作用是当表达式的值发生变化时,将这个变化也反映到DOM上。代码示例如下：
```js
<div v-if="show">DDFE</div>
```
当show为true时,展示DDFE字样,否则不展示。还有一些指令的语法稍有不同,在指令和表达式之间插入一个参数,用冒号分隔,如v-bind指令。代码示例如下：
```js
<a v-bind:href="url"></a>

<div v-on:click="action"></div>
```
## 分隔符

Vue.js中数据绑定的语法被设计为可配置的。如果不习惯Mustache风格的语法,则可以自 己设置。

我们可以在Yue.config中配置绑定的语法。Yue.config是一个对象,包含了Yue.js的所有全 局配置,可以在Vue实例化前修改其中的属性。分隔符在Vue.config中源码定义如下：
```js
< !" －－源码目录src/config.js--> 
let delimiters= ['{{','}}']

let unsafeDelimiters = ['{ { {','}}}']
```
1. delimiters
```js
Vue.config.delimi七ers = ["<%", "%>"]
```
如果修改了默认的文本插值的分隔符,则文本插值的语法由{ {example}}变为
```js
<¾example%>。
```
2. unsafeDelimiters
```js
Vue.config.unsafeDelimiters = ["<$", "$>"]
```
如果修改了默认的HTML插值的分隔符,则HTML插值的语法由{ { {example}}}变为 <$emample$>。


## 内部指令

### v-if

v-if指令可以完全根据表达式的值在DOM中生成或移除一个元素。如果v-if表达式赋值为 false,那么对应的元素就会从DOM中移除;否则,对应元素的一个克隆将被重新插入DOM中。 代码示例如下：
```js
<body class="native"> 
    <div id="example">
        <p v-if="greeting">Hello</p>
    </div> 
</body> 
<script>
    var exampleVM2 = new Vue({ 
        el:'#example',
        data: {
            greeting: false
        }
    })
</script>

//<body class= "native"><div><script>….</script>
```
因为v-if是一个指令,需要将它添加到一个元素上。但是如果想切换多个元素,则可以把 \<template>元素当作包装元素,并在其上使用v-if,最终的渲染结果不会包含它。代码示例如下：
```js
<template v-if="ok"> 
    <hl>Title</hl> 
    <p>Paragraph l</p> 
    <p>Paragraph 2</p>
</template>
```

### v-show

v-show指令是根据表达式的值来显示或者隐藏HTML元素。当v-show赋值为false时,元 素将被隐藏。查看DOM时,会发现元素上多了一个内联样式style="display: none"。代码示例 如下：
```js
<body>
    <input type="text" v-model="message" placeholder="edit me"> 
        <div id="example">
        <p v-show="greeting">Hello!</p> 
    </div>
</body>

<script>
var exampleVM2 = new Vue({ 
    el:'#example',
    data: {
        greeting: false
    }
}) 
</script>
```

注：v-show不支持\<template>语法。

在切换v一if模块时,Vue.js有一个局部编译／卸载过程,因为v-if中的模板可能包括数据绑 定或子组件。v-if是真实的条件渲染,因为它会确保条件块在切换时合适地销毁与重建条件块 内的事件监听器和子组件。

v-if是惰性的一如果初始渲染时条件为假,则什么也不做,在条件第一次变为真时才开始 局部编译(编译会被缓存起来)。

相比之下,v-show简单得多一—元素始终被编译并保留,只是简单地基千CSS切换。

一般来说,v-if有更高的切换消耗,而v-show有更高的初始渲染消耗。因此,如果需要频 繁地切换,则使用v-show较好;如果在运行时条件不大可能改变,则使用v一if较好。


### v-else

顾名思义,v-else就是JavaScript中else的意思,它必须跟着v-if或v-show,充当else功 能。代码示例如下：
```js
<body class="native"> 
    <div id="example">
        <p v-if="ok">我是对的</p>
        <p v-else="ok">我是错的</p> 
    </div>
</body>

<script>
var exampleVM2 = new Vue({ 
    el:'#example',
    data: {
        ok: false
    }
}) 
</script>
```
将v-show用在组件上时,因为指令的优先级v-else会出现问题,所以不要这样做。代码示 例如下：
```js
<custom-component v-show="condition"></custom-component> <p v-else>这可能也是一个组件</p>
```
我们可以用另一个v-show替换v-else,代码示例如下：
```js
<custom-component v-show="condition"></custom-component> <p v-show="!condi巨on">这可能也是一个组件</p>
```
### v-model

v-model指令用来在input、select、text、checkbox、radio等表单控件元素上创建双向数据 绑定。根据控件类型v-model自动选取正确的方法更新元素。尽管有点神奇,但是v-model不 过是语法糖,在用户输入事件中更新数据,以及特别处理一些极端例子。代码示例如下：
```js
<body id="example"> 
<form>
    姓名：
    <input type="text" v-model="data.name" placeholder=""> <br/>
    性别：
    <input type="radio" id="man" value="One" v-model="data.sex"> <label for="man">男</label>
    <input type="radio" id="male" value="Two" v-model="data.sex"> <label for="male">女</label>
    <br/>
    兴趣：
    <input type="checkbox" id="book" value="book" v-model="data.interest"> <label for="book">阅读</label>
    <input type="checkbox" id="swim" value="swim" v-model="data.in七erest"> <label for="swim">游泳</label>
    <input type="checkbox" id="game" value="game" v-model="data.interest"> <label for="game">游戏</label>
    <input type="checkbox" id="song" value="song" v-model="data.interest"> <label for="song">唱歌</label>
    <br/>
    身份：
    <select v-model="data.identity">
    <option value="teacher" selected>教师</option> <option value="doctor">医生</option>
    <option value="lawyer">律师</op巨on>
    </select> 
</form>
</body>
<script>
    new Vue ({ 
        el:'#example', 
        data: {
            data: {
            name:"",
            sex:',',
            interest: [], 
            identity:''
        }
        }
    }) 
</script>
```

除了以上用法,在v-model指令后面还可以添加多个参数(number、lazy、debounce)。

1. number

如果想将用户的输入自动转换为Number类型(如果原值的转换结果为NaN,则返回原值), 则可以添加一个number特性。

2. lazy

在默认情况下,v-model在input事件中同步输入框的值与数据,我们可以添加一个lazy特 性,从而将数据改到在change事件中发生。代码示例如下：
```js
<body id="example">
input v-model="msg" lazy><br/> {{msg}}
</body>
<script>
var exampleVM2 = new Vue({ el:'#example',
    data: {
        msg: '内容是在change事件后才改变的～'
    }
})
</script>
```
我们在input输入框中输入"依然没变",虽然触发了 input事件,但是因为加入了lazy属性,msg的值一直没有 发生变化。。


3. debounce

设置一个最小的延时,在每次敲击之后延时同步输入框的值与数据。如果每次更新都要进 行高耗操作(例如,在input中输入内容时要随时发送AJAX请求),那么它较为有用。代码示 例如下：
```js
<body id="example">
<input v-model="msg" debounce="5000"><br/> {{msg}}
</body>
<script>
    var exampleVM2 = new Vue({ 
        el:'#example',
        data: {
            msg: '内容是在SOOOms后才改变的～'
        }
})
</script>
```
在5000ms内我们将输入框的内容清空,msg的值没有马上改变,还依然保持着"内容是在 5000ms后才改变的～"。

5000ms后内容才被清空。


### v-for

我们可以使用v-for指令基千源数据重复渲染元素。我们也可以使用$index来呈现相对应的 数组索引,代码示例如下：
```js
<body id="example"> 
<ul id="demo">
    <li v-for="item in items" class="item-{{$index))">
        {{$index}} -{{parentMessage}} {{item.msg}}} 
    </li>
</ul>
</body> 
<script>
var demo= new Vue({ 
    el:'#demo',
    data: {
        items: [
            parentMessage: '滴滴,' 
            { msg: '滴滴顺风车' },
            { msg: '滴滴专车' }
        ]
    }
}) 
</script>
```

v-for需要特殊的别名,形式为"item in items" (items是数据数组,item是当前数组元素的 别名)。v-for在开始时对传入的表达式做了语法分析,不是"item in / of items"的形式,将给出 警告信息。Vue.js 1.0.17及以后版本支持of分隔符,更接近JavaScript遍历器语法,用法如下：
```js
<div v-for="itern of iterns"></div>。
```
源码定义如下：
```js
<'－－源码目录：vue\src\directive\public\for.js 37行－－> // support "item in/of items" syntax

var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/) 
if (inMatch) {
var itMatch = inMatch[1].match(/\((.*),(.*)\)/) 
if (itMatch) {
this.iterator= itMatch[l].trim() this.alias= itMatch[2].trim()
) else {
this.alias= inMatch[1].trim()
this.expression= inMatch[2]
if(!this.alias) {
process.env.NODE_ENV !=='production'&& warn(
'Invalid v-for expression "'+ this. descriptor. raw +'":'+ 'alias is required.',
this.vm
)
return
}
```

使用v-for,将得到一个特殊的作用域,我们需要明确指定 props属性传递数据,否则在组件内将获取不到数据。对千组件内的\<p>标签,我们可以使用\<slot>:
```js
<my-item v-for="item in items" :item="item" :index="index"> <p>{ {item.text}}</p>
</my-item>
```
当数组数据出现变动时如何检测呢？Vue.js包装了被观察数组的变异方法,它们能触发视图更新。被包装的方法有：

 - push()
 - pop()
 - shift()
 - unshift()
 - splice()
 - sort()
 - reverse()

源码定义如下：
```js
< !" －－源码目录：vue/src/observer/array.js 10行－－> ; ［
{
'push', 'pop', 'shift', 'unshift', 'splice','sort', 'reverse'
}.forEach(function (method) {
var original= arrayProto[method]
def (arrayMethods, method, function mutator () {
    var i = arguments.length
var args = new Array(i)
while (i--) {
args[i] = arguments[i]
}
var result = original.apply(this, args) 
var ob= this._ob_
var inserted
switch (method) {
case'push':inserted = args break ;
case'unshift': inserted= args break;
case'splice':inserted= args.slice(2) break;
}
if (inserted) ob.observeArray(inserted) 
ob. dep. notify ()
return result
})
})
```
如源码所示,Vue.js重写这些方法之后,触发了一次notify。

Vue.js还增加了两个方法来观测变化： $set、$remove。源码定义如下：
```js
<!" －－源码目录：vue\src\observer\array.js 60行－－> 
def (arrayProto,'$set',function $set (index, val) {
if (index>= this.length) { this.length= Number(index) + 1}
return this. splice (index, 1, val) [ 0]
}}
def (arrayProto, '$remove',function $remove (item) { /* istanbul ignore if*/ if (!this. length) return
var index= indexOf(this, item) if (index>-1) {return this.splice(index, 1)}}}
```
我们应该尽量避免直接设置数据绑定的数组元素,因为这些变化不会被Vue.js检测到,因 而也不会更新视图渲染。这时,我们可以使用$set方法：
```js
demo.items.$set(O, { childMsg:'Changed!'})
```
$remove是splice的语法糖,从目标数组中查找并删除元素。因此,不必这样：
```js
var index= this.items.indexOf(item) if (index 1== -1) {
this.items.splice(index, 1)
}
```
只用这样：
```js
demo.items.$remove(item)
```

另外,也可以使用filter、concat、slice方法,返回的数组将是一个不同的实例。我们可以 用新的数组替换原来的数组。
```js
demo.items= demo.items.filter(function (item) { 
    return item. childMsg. match (/Hello/)
})
```

在某些情况下,我们有时可能需要用全新对象(例如,通过API调用创建的对象)来替换 数组。因为在默认情况下,v-for通过数据对象的特征来决定对已有作用域和DOM元素的复用 程度,这可能导致重新渲染整个列表。但是,如果每个对象都有一个唯一的ID属性,便可以使 用track-by特性给Vue.js一个提示,因而Vue.js能尽可能地复用已有实例。假定数据为：
```js
items: [
{ _uid:'88f869d',... }, { _uid:'7496cl0',...}
]
```
可以这样给出提示,代码示例如下：
```js
<div v-for ="item in items" track-by="_uid"> <!--content-->
</div>
```
在替换数组items时,如果Vue」s遇到一个包含有_ uid:'88f869d'的新对象,那么它知道可 以复用这个已有对象的作用域与DOM元素。

如果没有唯一的键供追踪,则可以使用track-by="$index",它强制让v-for进入原位更新模 式：片段不会被移动,而是简单地以对应索引的新值刷新。这种模式也能处理数据数组中重复 的值。

这让数据替换非常高效,但是也会付出一定的代价。因为这时DOM节点不再映射数组元 素顺序的改变,不能同步临时状态(比如\<input>元素的值),以及组件的私有状态。因此,如 果v-for块包含\<input>元素或子组件,则要小心使用track-by="$index"。

因为JavaScript的限制,Vue.js不能检测到下面数组的变化： 

O直接用索引设置元素,如vm.items[O] ={}。

0修改数据的长度,如vm.items.length = 0。

为了解决前一个问题,Vue.js扩展了观察数组,我们可以使用上面讲过的$set方法：
```JS
vm.items.$set(O, { childMsg:'Changed''})
```
至于后一个问题,只需用一个空数组替换items即可。

有时我们可能想重复一个包含多个DOM元素的块,在这种情况下,则可以使用\<template> 标签来包装重复片段。这里的\<template>标签只充当一个语义包装器。代码示例如下：
```js
<ul>
    <template v-for="list in lists"> 
        <li> {{list.msg}}</li>
        <li class="divider"></li>
    </template> 
</ul>
```
我们也可以使用v-for遍历一个对象,每一个重复的实例都将有一个特殊的属性$key,或者 给对象的键值提供一个别名。代码示例如下：
```js
<body id="example">
    <ul id="repeat-object">
        <li v-for ="value in primitiveValues">{{$key}} : {{value}}</li> <li>===</li>
        <li v-for=" (key, item) in objectValues">{{key}} : {{item.msg})</li> 
    </ul>
</body>
<script>
var demo= new Vue({ 
    el:'#repeat-object', 
    data: { 
        pr1mitiveValues: { FirstName:'DIDI', LastName:'FE',Age: 4 },
        objectValues: { one: {msg:'Hello' }},
        two: { msg:'DIDI FE'}
    }
})
</script>
// FirstNarne : DIDI
// LastNarne : FE
// Age : 4
// ===
// one : Hello
// two : DIDI FE
```

注：ECMAScript 5无法栓测到新属性添加到一个对象上或者在对象中删除。要处理这种情 况,Vue.js增加了三种方法： $add(key,value)、$set(key, value)和$delete(key),这些方法可以用来 添加和删除属性,同时触发视图更新。

v-for也支持整数。代码示例如下：
```js
<div id="range">

<div v-for="n in 10">Hi1 {{$index}}</div> </div>
```

### v-text

v-text指令可以更新元素的textContent。在内部,{{Mustache}}插值也被编译为textNode 的一个v-text指令。代码示例如下：
```js
<span v-text="msg"></span><br/> <!-- same as-->

<span> {{msg}} </ span>
```
### v-html

v-html指令可以更新元素的innerHTML。内容按普通HTML插入 数据绑定被忽略。如

果想复用模板片段,则应当使用partials。

在内部,{{{Mustache}}}插值也会被编译为铀节点上的一个v-html指令。

注：不建议在网站上直接动态渲染任意HTML片段,很容易导致XSS攻击。
```js
<div v-html="html"></div> <'--相同－－> <div>{{{html}}}</div>
```
### v-bind

v-bind指令用千咱应更新HTML特性,将一个或多个attribute,或者一个组件prop动态绑 定到表达式。v-bind可以简写为：
```js
<!" －－绑定attribute-->
<img v-bind:src="imageSrc"> <!"－－缩写－－>
<img :src="imageSrc">
```
在绑定class或style时,支持其他类型的值,如数组或对象。代码示例如下：
```js
<body id＝"example">
<div :class="[classA, { classB: isB, classC: isC }]"></div>
</body>

<script>
var demo= new Vue({ 
    el:'#example',
    data: {
    classA:'A', isB: false, isC: true
    }
}) 
</script>
```

没有参数时,可以绑定到一个对象。注意,此时class和style绑定不支持数组和对象(对 象key会转换为小写)。代码示例如下：
```js
<body id="example">

<div v-bind=" { id: someProp,'OTHERAttr': otherProp } "></div> </body>

<script>

var exampleVM2 = new Vue({ 
    el:'#example',
    data: {
        someProp:'idNarne',
        otherProp:'prop'
    }
}) 
</script>

```

在绑定prop时,prop必须在子组件中声明。可以用修饰符指定不同的绑定类型。修饰符为： 
- .sync一一双向绑定,只能用于prop绑定。
- .once—单次绑定,只能用于prop绑定。
- .camel——将绑定的特性名字转换回驼峰命名。只能用千普通HTML特性的绑定,通 常用千绑定用驼峰命名的SVG特性,比如viewBox。
```js
<!-- prop绑定,"prop"必须在my-component组件内声明--> <my-component :prop="someThing"></my-component>

<!--双向prop绑定-->

<my-component :prop.sync="someThing"></my-component> <!--单次prop绑定-->

<my-component :prop.once="someThing"></my-component>
```
### v-on

v-on指令用丁绑定事件监听器。事件类型由参数指定;表达式可以是一个方法的名字或一 个内联语句;如果没有修饰符,也可以省略。

使用在普通元素上时,只能监听原生DOM事件;使用在自定义元素组件上时,也可以监听子组件触发的自定义事件。

在监听原生DOM事件时,如果只定义一个参数,DOM event为事件的唯一参数;如果在 内联语旬处理器中访问原生DOM事件,则可以用特殊变矗$event把它传入方法。

Vue.js在监听自定义事件时,内联语句可以访问一个$arguments属性,它 是一个数组,包含了传给子组件的$emit回调的参数。

<'－－方法处理器－－>
```js
<button v-on:click="doThis"></button> <!"－－内联语句－－>

<button v-on:click="doThat('hello', $event)"></button>

<!--缩写－－>

<button @click="doThis"></button>
```
v-on后面不仅可以跟参数,还可以增加修饰符：

- .stop－－调用event.stopPropagation()。 
- .prevent-—调用event.preventDefault()。
- .capture一添加事件侦听器时使用capture模式。
- .self一一只当事件是从侦听器绑定的元素本身触发时才触发回调。
- .{keyCode I keyAlias}—只在指定按键上触发回调。Vue.js提供的键值有： ［esc: 27、tab:9、enter: 13、space: 32、'delete': [8, 46]、up: 38、left: 37、right: 39、down: 40]。
```js
<!--停止冒泡－－> <button @click.stop="doThis"></button>

<!"－－阻止默认行为－－>

<button @click.prevent="doThis"></button>

<!"－－阻止默认行为,没有表达式－－>

<form @submit.prevent></form>

<!"－－串联修饰符－－> <button @click.stop.prevent="doThis">stop</button> <!－－键修饰符,键别名－－>

<input @keyup.enter="onEnter"> <!--键修饰符,键代码－－>

<input @keyup.13="onEnter">
```
### v-ref

在父组件上注册一个子组件的索引,使十直接访问。不斋要表达式,必须提供参数过。可 以通过父组件的$refs对象访问子组件。

当v-ref和v-for一起使用时,注册的值将是一个数组,包含所有的子组件,对应千绑定数组; 如果v-for使用在一个对象上,注册的值将是一个对象,包含所有的子组件,对应千绑定对象。

注：因为HTML不区分大小写,camel Case风格的名字比如v-ref:someRef将全部转换为小 写。可以用v-ref:some-ref设置this.$refs.someRef。

### v-el

为DOM元素注册一个索引,方便通过所属实例的$els访问这个元素。可以用v-el:some-el设 置this.$els.someEI。
```js
<span v-el:msg>hello</span>

<span v-el:other-msg>world</span>
```
通过this.$els获取相应的DOM元素：
```js
this.$els.msg.textContent //->"hello" this.$els.otherMsg.textContent //->"world"
```
### v-pre

编译时跳过当前元素和它的子元素。可以用来显示原始Mustache标签。跳过大量没有指令 的节点会加快编译。

### v-cloak

v-cloak这个指令保持在元素上直到关联实例结束编译。AngularJS也提供了相同的功能。

当和CSS规则如[v-cloak]{ display: none}一起使用时,这个指令可以隐藏未编译的Mustache标 签直到实例准备完毕,否则在渲染页面时,有可能用户会先看到Mustache标签,然后看到编译 后的数据。用法如下：
```js
[v-cloak] { display: none;}

<div v-cloak> {{message}} </div>
```
## 自定义指令

## 基础

除了内置指令,Vue.js也允许注册自定义指令。自定义指令提供一种机制将数据的变化映 射为DOM行为。

我们来看看Vue.js是如何实现的。Vue.js用Vue.directive(id,definition)方法注册一个全局自 定义指令,它接收两个参数：指令ID与定义对象。也可以用组件的directives选项注册一个局 部自定义指令。

1.钩子函数

Vue.js 提供了几个钩子函数(都是可选的,相互之间没有制约关系)：

- bind 只调用一次,在指令第一次绑定到元素上时调用。
- update—在bind之后立即以初始值为参数第一次调用,之后每当绑定值变化时调 用,参数为新值与旧值。
- unbind—只调用一次,在指令从元素上解绑时调用。
```js
Vue.directive ('my-directive', { 
bind: function () {
//准备工作
//例如,添加事件处理器或只需要运行一次的高耗任务
},

update: function (newValue, oldValue) {

//值更新时的工作

//也会以初始值为参数调用一次 
},

unbind: function () { 
//清理工作

//例如,删除bind()添加的事件监听器

})
```
在注册之后,便可以在Vue.js模板中这样用(记着添加前缀v-):
```js
<div v-my-directive="someValue"></div>
```
当只需要update函数时,可以传入一个函数替代定义对象：
```js
Vue. directive('my-directive', function (value) { 
    //这个函数用作update ()
})
```
2.指令实例属性

所有的钩子函数都将被复制到实际的指令对象中,在钩子内this指向这个指令对象。这个对象暴露了一些有用的属性：

- el—指令绑定的元素。
- vm-—拥有该指令的上下文View Model。
- expression—指令的表达式,不包括参数和过滤器。 
- arg一一指令的参数。
- name—指令的名字,不包含前缀。
- modifiers—－个对象,包含指令的修饰符。 
- descriptor-—一个对象,包含指令的解析结果。

注：我们应当将这些属性视为只读,不要修改它们。我们也可以给指令对象添加自定义属 性,但是注意不要覆盖已有的内部属性。代码示例如下：
```js
<body id="exarnple" @click="up" >

<div id="derno" v-demo:hello.a.b="rnsg"></div> 
</body>

<script>
Vue.directive ('demo', { 
    bind: function () {
        console.log ('demo bound!') 
    },

    update: function (value) { 
        this.el.innerHTML ='name -'+ this. name +'<br>'+ 'expression -'+ this.expression+'<br>'+'argument -'+ this. arg +'<br>'+'modifiers -'+ JSON.stringify(this.modifiers) +'<br>'+ 'value -'+value+'<br>'+'vm-msg'+ this. vm. msg
    }
})

var demo= new Vue({ 
    el:'#example', 
    data: { 
        msg:'hello!'
    },
    methods: {
        up: function() {
            console.info ("click");
        }
    }
}) 
</script>
```

3.对象字面量

如果指令需要多个值,则可以传入一个JavaScript对象字面量。记住,指令可以使用任意 合法的JavaScript表达式。代码示例如下：
```js
<body>
    <div id="demo" v-demo="{ color:'white', text:'hello!'}"></div> 
</body>

<script>
    Vue.directive('demo', function (value) { 
        console. log (value. color) // "white" console. log (value. text) // "hello!"
    })
    var demo= new Vue({ 
        el:'#demo'
    }) 
</script>

```
 4.字面修饰符

当指令使用了字面修饰符时,它的值将按普通字符串处理并传递给update方法。update方 法将只调用一次,因为普通字符串不能响应数据变化。代码示例如下：
```js
<body>
<div id="demo" v-demo.literal="foo bar baz"></div> 
</body>

<script>
Vue.directive ('demo', function (value) { 
    console.info(value)
))
var demo= new Vue({ 
    el:'~demo'
}) 
</script>
```
5.元素指令

有时我们想以自定义元素的形式使用指令,而不是以属性的形式。这与AngularJS的"E" 指令非常相似。元素指令可以看作是一个轻量组件。可以像下面这样注册一个自定义元素指令：
```js
<body id="demo">
    <my-directive class="hello" name="hi"></my-directive> 
</body>
<script>

Vue.elementDirective('my-directive', {
// API同普通指令
bind: function () { 
    console.info(this.el.className) 
    console.info(this.el.getAttribute("name"))
})

var demo= new Vue({ 
    el:'#demo'
}) 
</script>
```

元素指令不能接受参数或表达式,但是它可以读取元素的特性,从而决定它的行为。

不同千普通指令,元素指令是终结性的。这意味着,一旦Vue遇到一个元素指令,它将跳过该元素及其子元素 只有该元素指令本身可以操作该元素及其子元素。

### 高级选项

Vue.js允许注册自定义指令。自定义指令提供一种机制将数据的变化映射为DOM行为。

1. params

自定义指令可以接受一个params数组,指定一个特性列表,Vue编译器将自动提取绑定元 素的这些特性。代码示例如下：
```js
<body id="demo">
<my-directive class="hello" name="hi" a="params"></my-directive> 
</body>
<script>
Vue. elementDirective('my-directive', { params: ['a'],
// API同普通指令
bind: function () { 
    console.log(this.params.a) 
    console.info(this.el.getAttribute("name"))
})

var demo = new Vue ({ 
    el:'ildemo'
}) 
</script>
```

此API也支持动态属性。this.params[key]会自动保持更新。另外,可以指定一个回调,在 值变化时调用。代码示例如下：
```js
<body id="demo">
<my-directive class="hello" name="hi" v-bind:a="someValue"></my-directive> <input type="text" v-model="someValue"/>
</body>
<scrip七>

Vue. elementDirective ('my-directive', { params: ['a'],
paramWatchers: (
a: function (val, oldVal) { 
    console. log ('a changed!')
    })
})

var demo= new Vue({
    el:'#demo',
    data: {
        some Value:'value'
    }
}) 
</script>

```

注：类似于props,指令参数的名字在JavaScript中使用camel Case凤格,在HTML中对应 使用kebab-case风格。例如,假设在模板中有一个参数disable-effect,在JavaScript中以 disableEffect访问它。

2. deep

如果自定义指令使用在一个对象上,当对象内部属性变化时要触发update,则在指令定义 对象中指定deep: true。代码示例如下：
```js
<body id="derno">

<div v-rny-directive="a"></div>

<button @click="change" >change</button> {{a.b.c}} </body>

<script>

Vue. directive ('rny-directive', { deep: true,

update: function (obj) {

//当 obj的嵌套屈性变化时调用

console.info(obj.b.c)

})

var demoVM = new Vue({ 
    el:'#demo',

    data: {

    a: { b: { c:2 }}
    },

    methods: {

        change: function() { demoVM.a.b.c = 4;

        }
    }
})

</script>

```

3. twoWay

如果指令想向Vue实例写回数据,则在指令定义对象中指定two Way:true。该选项允许在指 令中使用this.set(value)。代码示例如下：
```js
<body id="demo">

自定义组件： <input v-example="a.b.c" /><br/> 父作用域： {{a.b.c}}

</body>

<script>

Vue.directive ('example', { 
    
    twoWay: true,

    bind: function () {

        this. handler = function () {

        //把数据写回vm

        //如果指令这样绑定v-example=" a. b. c" //这里将会给｀vm.a.b.c·赋值 this.set(this.el.value)

    }.bind(this)

        this. el. addEventListener ('input',this.handler) 
    
    },

    unbind: function () { 
        this.el.removeEventListener('input', this.handler)
    }

})

var demo= new Vue({ 
    el:'#demo',

    data:{ 
        a:{b:{ c:2}} 
        } 
    })
</script>
```

4. acceptStatement

传入acceptStatement:true可以让自定义指令接受内联语句,就像v-on那样。代码示例如下：
```js
<body id="demo">

<div v-my-directive="a++"></div>

{{a}} </body>

<script>

Vue.directive ('my-directive', { 
    acceptStatement: true, 
    update: function (fn) {
        //传入值是一个函数
        //在调用它时将在所屈实例作用域内计算"a++"语句
        console.info (fn.toString()) 
        fn()
))
var demoVM = new Vue({ 
    el:'#demo',
    data: {
        a:5
    }
})
 </script>
```
5. Terminal 

Vue通过递归遍历DOM树来编译模块。但是当它遇到terminal指令时会停止遍历这个元素 的后代元素,这个指令将接管编译这个元素及其后代元素的任务。v-if和v-for都是terminal指令。


编写自定义terminal指令是一个高级话题,需要较好地理解Vue的编译流程,但并不是说 不可能编写自定义terminal指令。用terminal:true指定自定义terminal指令,可能还需要用 Vue.FragmentFactory来编译partial。下面是一个自定义terminal指令,它编译其内容模板并将 结果注入到页面的另一个地方。代码示例如下：
```js
<body id="example">
<div id="modal"></div> 
<div v-inject:modal> 
    <hl>header</hl> 
    <p>body</p> 
    <p>footer</p>
</div>
</body> 

<script>
var FragrnentFactory = Vue.FragrnentFactory
var remove= Vue.util.remove
var createAnchor = Vue.util.createAnchor 
Vue.directive('inject', {
    terminal: true, 
    bind:function () {
        var container= docurnent.getElernen七Byld(this.arg) 
        this.anchor= createAnchor('v-inject') 
        container.appendChild(this.anchor)
        remove(this.el)
        var factory= new FragrnentFactory(this.vm, this.el)
        this.frag = factory.create(this._host, this._scope, this._frag) 
        this.frag.before(this.anchor)

},
    unbind: function () { 
        this.frag.remove() 
        remove(this.anchor)
    }
})

//创建根实例
new Vue ({ 
    el:'#example'
}) 
</script>
```

如果想编写自定义terminal指令,建议通读内置terminal指令的源码,如v-if和v-for,以 便更好地了解Vue.js的内部机制。

6. priority

可以给指令指定一个优先级。如果没有指定优先级,普通指令默认是1000, terminal指令 默认是2000。同一个元素上优先级高的指令会比其他指令处理得早一些,优先级一样的指令 按照它在元素特性列表中出现的顺序依次处理,但是不能保证这个顺序在不同的浏览器中是一致的。

另外,流程控制指令v-if和v-for在编译过程中始终拥有最高的优先级。


## 常见问题解析

1. v-on可以绑定多个方法吗？

v-on可以绑定多种类型的方法,可以是click事件,可以是focus事件,也可以是change 事件,根据业务需求进行选择。但是,如果用v-on绑定了两个甚至多个click事件,那么v-on 只会绑定第一个click事件,其他的会被自动忽略。
```js
<input type="text" :value="name" @input="oninput" @focus="onFocus" @blur="onBlur" />
```
2. 一个Vue实例可以绑定多个element元素吗？

这个疑问产生的原因是没有理解el的概念。el为实例提供挂载元素,值可以是CSS选择符, 或实际的HTML元素,或返回HTML元素的函数。注意,元素只用作挂载点。如果提供了模 板,则元素被替换,除非replace为false。元素可以用vm.$el访问。

用在Vue.extend中必须是函数值,这样所有实例不会共享元素。

如果在初始化时指定了这个选项,实例将立即进入编译过程;否则,需要调用vm.$mount(), 手动开始编译。

3. 在Vue中如何让v-for循环出来的列表里面的click事件只对当前列表内元素有效？ 比如模板如下,想点击h控制span的显隐：
```js
<li @click="show"> <span>l</span> </li>
```
从数据角度出发,定义好数据结构,然后操作数据：
```js
<body id="example"> 
    <div>
        <ul id="app">
            <li v-for='item in items' @click="toggle(item)"> 
                <span v-show='item.show'>{{item.content}}</span> 
            </li>
        </ul>
    </div>
</body>

<script>
new Vue ({ 
    el:'#app',
    data: function() { 
        return {
            items: [ {
                content:'1item', 
                show: true
                }, {
                content:'2item', 
                show: true
                },{
                content:'3item', 
                show: true
            }]
        }
    }, 
    methods: {
        toggle: function(item) { 
            item.show='item.show';
        }
    } 
})
</script>
```
或者通过$event对象,获取当前事件源,然后操作下面的span元素,方法很多。



## 计算属性

通常我们会在模板中绑定表达式,模板是用来描述视图结构的。如果模板中的表达式存在 过多的逻辑,模板会变得脾肿不堪,维护变得非常困难。因此,为了简化逻辑,当某个属性的 值依赖千其他属性的值时,我们可以使用计算属性。

### 什么是计算属性

计算属性就是当其依赖属性的值发生变化时,这个属性的值会自动更新,与之相关的DOM 部分也会同步自动更新。代码示例如下：
```js
<div id="example">

<input type="text" v-model="didi" /> <input type="text" v-model="family" /> <br>

didi={{ didi }}, family={{family}}, didiFamily = {{didiFamily}} </div>

var vm = new Vue({ 
    el:'#example', 
    data: {
        didi：'didi', 
        family:'family' 
    },
    computed: {
        //一个计算屈性的getter 
        didiFamily: function () {
        //this、指向vm实例
        return this.didi + this.family;
        }
    }
})
```
当vm.didi和vm.family的值发生变化时,vm.didiFamily的值会自动更新,并且会自动同步 更新DOM部分。

前面实例只提供了getter,实际上除了getter,我们还可以设置计算属性的setter。代码示例 如下：
```js
var vm = new Vue({ 
    el:'#example', 
    data: { didi:'didi', family:'family' },
    computed: { 
        didiFamily: {
        //一个计算屈性的getter 
            get: function () {
            //this、指向vm实例
                return this. didi +''+ this. family 
            },
            //一个计算屈性的setter
            set: function (newVal) {
                var names = newVal. split ('') 
                this.didi = names[0] 
                this.family= names[1]
            }
        }
    }
})
```
当设置vm.didiFamily的值时,vm.d心和vm.family的值也会自动更新。

### 计算属性缓存

计算属性的特性的确很诱人,但是如果在计算属性方法中执行大量的耗时操作,则可能会 带来一些性能问题。例如,在计算属性getter中循环一个大的数组以执行很多操作,那么当频 繁调用该计算属性时,就会导致大量不必要的运算。

只有计算属性依赖的属性值发生了改变时才会重 新执行getter。

这样也存在一个问题,就是只有Vue实例中被观察的数据属性发生了改变时才会重新执行 getter。但是有时候计算属性依赖实时的非观察数据属性。代码示例如下：
```js
var vm = new Vue({ 
    data: {
        welcome:'welcome to join didiFamily' 
    },
    computed: {
        example: function (){
            return Date.now() + this.welcome
        }
    }
})
```
我们需要在每次访问example时都取得最新的时间而不是缓存的时间。从Vue.js 0.12.11版 本开始,默认提供了缓存开关,在计算属性对象中指定cache字段来控制是否升启缓存。代码 示例如下：
```js
var vm = new Vue({ 
    data: {
        welcome:'welcome to join didifamily' 
    },
    computed: { 
        example: {
            //关闭缓存,默认为true
            cache: false,
            get: function () {
                return Date.now()+this.welcome
            }
        }
    }
})
```
设置cache为false关闭缓存之后,每次直接访问vm.example时都会重新执行getter方法。

### 常见问颗

在实际开发中使用计算属性时,我们会遇到各种各样的问题,以下是我们搜集到的一些常 见问题以及解决方案。

#### 计算属性getter不执行的场景

从前面章节中我们了解到,当计算属性依赖的数据属性发生改变时,计算属性的getter 方法就会执行。但是在有些情况下,虽然依赖数据属性发生了改变,但计算属性的getter方 法并不会执行。

当包含计算属性的节点被移除并且模板中其他地方没有再引用该属性时,那么对应的计算 属性的getter方法不会执行。代码示例如下：
```js
<div id="example">
    <button @click='toggleShow'>Toggle Show Total Price</button> <p V-if="showTotal">Total Price= {{totalPrice}}</p>
</div>

new Vue({ 
    el:'#example', 
    data: {
        showTotal: true, 
        basePrice: 100
    },
    computed: {
        totalPrice: function () {
            return this.basePrice + 1
        }
    },
    methods:{
        toggleShow: function () { 
            this.showTotal = !this.showTotal
        }
    }
})
```
当点击按钮使showTotal为false时,此时P元素会被移除,在P元素内部的计算属性totalPrice

的getter方法不会执行。但是当计算属性一直出现在模板中时,getter方法还是会被执行。代码 示例如下：
```js
<div id="example">

<button @click='toggleShow'>Toggle Show Total Price</button> <!-- 一直出现在模板中,不会条件性隐藏-->

<p>{{totalPrice}}</p>

<p v-if="showTotal">Total Price= {{totalPrice}}</p> </div>
```


## 表单控件

在Web应用中,我们经常会使用表单向服务端提交一些数据,而通常也会在表单项中绑定 一些如input、change等事件对用户输入的数据进行校验、更新等操作。在Vue.js中、我们可以 使用v-rnodel指令同步用户输入的数据到Vue实例data属性中,同时会对radio、checkbox、select 等原生表单组件提供一些语法糖使表单操作更加容易。

### text

设置文本框v-model为name,代码示例如下：
```js
<span>Welcome {{ name }} join DDFE</span> <br>

<input type="text" v-model="name" placeholder="join DDFE">
```
当用户操作文本框时,vm.name会自动更新为用户输入的值,同时,span内的内容也会随 之改变。

### checkbox

复选框checkbox在表单中会经常使用,下面我们来看看单个checkbox如何使用v-model。

代码示例如下：
```js
<input type="checkbox" id="checkbox" v-model="checked"> <label for="checkbox">{{ checked }}</label>
```
当用户勾选了checkbox时,vm.checked=true,否则vm.checked=false, label中的值也会随 之改变。

大多数时候我们使用的都是多个复选框,即一个复选框组。此时,被选中的值将会放入一 个数组中。代码示例如下：
```js
<input type="checkbox" id="flash" value="flash" v-model="bizLines"> <label for=" flash">快车</label>

<input type="checkbox" id="premium" value="premium" v-model="bizLines"> <label for="premium">专车</label>

<input type="checkbox" id="bus" value="bus" v-model="bizLines"> <label for="bus">巴士</label>

<br>

<span>Checked lines: {{bizLines | json}} </ span>

new Vue ({
    el:'...',
    data: { bizLines: []}
})
```

### radio

当单选钮被选中时,v-model中的变量值会被赋值为对应的value值。代码示例如下：
```JS
<input type="radio" id="flash" value="flash" v-model="bizLine"> <label for="flash">快车</label>

<br>

<input type="radio" id="bus" value="bus" v-model="bizLine"> <label for="bus">巴士</label>

<br>

<span>Picked: {{ bizLine }}</span>
```

### select

因为select控件分为单选和多选,所以v-model在select控件的单选和多选上会有不同的表 现。代码示例如下：
```js
<select v-model="bizLine">

<option selected value="flash">快车</option> <option value="premium">专车</option>

<option value="bus">巴士</option>

</select>

<span>Selected: {{ bizLine }}</span>
```
当被选中的option有value属性时,vm.selected为对应option的value值;否则为对应option 的text值。

对于多选select控件,被选中的值会放入一个数组中。代码示例如下：
```js
<select v-rnodel="bizLines" multiple>

<option selected value="flash">快车</option> <option value="prerniurn">专车</option>

<option value="bus">巴士</option>

</select>

<span>Selected: {{ biztines | json } }</span>
```
我们也可以通过v-for指令来动态生成option, v-for、v-bind指令的具体用法请参阅指令部 分。代码示例如下：
```js
<select v-model="bizLine">
    <option v-for="option in options" :value="option.value"> {{ option.text }}</option>
</select>
<span>bizLine: {{ bizLine }}</span>

new Vue ({
    el:'...',
    data: {
        bizLine:'flash',
        options: [
            {text:'快车',value: 'flash' },
            { text:'专车',value: 'premium'}, 
            { text: '巴士',value: 'bus' }
        ]
    }
})
```
生成的HTML结构代码如下：
```js
<select>

<option yalue="flash">快车</option>

<option value="premium">专车</option> <option value="bus">巴士</option>

</select>
```
### 值绑定

在通常情况下,对千radio、checkbox、select组件,通过v-model绑定的值都是字符串, checkbox除外,checkbox可能是布尔值。代码示例如下：
```js
< !--勾选时'picked'的值是字符串a-->

<input type="radio" v-model="picked" value="a">

< !--勾选时'toggle'的值是布尔值true,否则是布尔值false-->

<input type="checkbox" v-model="toggle"> < !--勾选时'selected'的值是字符串abc-->

<select v-model="selected"> <option value="abc">ABC</option> </select>
```
有时我们会有动态绑定Vuejs实例属性的需求,这时可以使用v-bind来实现这个需求。通 过v-bind来代替直接使用value属性,我们还可以绑定非字符串的值,如数值、对象、数组等。 下面我们举例看看在各form表单中各控件如何使用该指令。

1. checkbox
```js
<input type="checkbox" v-model="toggle" :true-value="a" :false-value="b">
```

- 勾选checkbox时,vm.toggle === vm.a。 
- 未勾选checkbox时,vm.toggle === vm.b。

注：:true-value和:false-value只适合同一个checkbox组只有一个checkbox的情况。如果有 多个checkbox,请使用：value进行值绑定。代码示例如下：
```js
<input type="checkbox" id="flash" :value="flash" v-model="bizLines"> <label for=" flash"> { { flash. name } } </label>

<input type="checkbox" id="premium" :value="premium" v-model="bizLines"> <label for="premium">{{ premium.name }}</label>

<input type="checkbox" id="bus" :value="bus" v-model="bizLines">

<label for="bus">{{ bus.name }}</label> <br>

<span>Checked bizLines: { { bizLines | json } } </ span>

new Vue ({
    el:'...',
    data: {
        flash: {name: '快车'},
        premium: {name: '专车'}, 
        bus: {name: '巴士'},
        bizLines: []
    }
})
```
2. radio
```js
<input type="radio" v-model="pick" :value="a">
```
勾选radio时,vm.pick === vm.a。 

3. select
```js
<select v-model="selected">

<option :value=" { number: 123 } ">123</option> </select>
```

用户勾选时,vm.selected === { number: 123}。

### v-model修饰指令

v-model用来在视图与Model之间同步数据,但是有时候我们需要控制同步发生的时机, 或者在数据同步到Model之前将数据转换为Number类型。我们可以在v-model指令所在的form 控件上添加相应的修饰指令来实现这个需求。

#### lazy

在默认情况下,v-model在input事件中同步输入框的值与数据,可以添加一个lazy特性, 从而改到在change事件中去同步。代码示例如下：
```js
<input v-model="msg" lazy><br/> {{msg}}
```
#### debounce

设置一个最小的延时,在每次敲击之后延时同步输入框的值到Model中。如果每次更新都 要进行高耗操作(例如,在输入提示中AJAX请求)时,它较为有用。代码示例如下：
```js
<input v-model="msg" debounce="500">
```
用户输入完毕500ms后,vm.msg才会被更新。

注：该指令是用来延迟同步用户输入的数据到Model中,并不会延迟用户输入事件的执行。

所以如果要想荻取变化后的数据,我们应该用vm.$watch()来监听msg的变化,而不是在事件中 荻取最新数据。要想延迟DOM事件的执行,请参阅过滤器章节中的debounce过滤器。

#### number

当传给后端的字段类型必须是数值的时候,我们可以在v-model所在控件上使用number指 令,该指令会在用户输入被同步到Model中时将其转换为数值类型,如果转换结果为NaN,则 对应的Model值还是用户输入的原始值。代码示例如下：
```js
<input v-model="age" number>
```


## 过滤器

在了解过滤器之前,我们需要明确一个概念一—过滤器,本质上都是函数。其作用在千用 户输入数据后,它能够进行处理,并返回一个数据结果。Vue.js与AngularJS中的过滤器语法有 些相似,使用管道符(|)进行连接。代码示例如下：
```js
{{'abc' | uppercase}} //'abc'=>'ABC'
```
这里使用了vue.js内置的过滤器uppercase,将字符串中的字母全部转换为大写形式。

Vue.js支待在任何出现表达式的地方添加过滤器。除了上面例子中的Mustache风格(双大 括号)的表达式之外,还可以在绑定指令的表达式后调用。代码示例如下：
```js
<span v-text="message I uppercase"></span>
```
表达式的值可以根据用户的输入来动态改变,也可以像abc一样采用固定值。

过滤器可以接受参数,参数跟在过滤器名称后面,参数之间以空格分隔。代码示例如下：
```js
{{message I filterFunction'argl'arg2 }}
```
需要强调的是,过滤器函数将始终以表达式的值作为第一个参数。带引号的参数会被当作 字符串处理,而不带引号的参数会被当作数据属性名来处理。这里,message将作为第一个参 数,字符串argl作为第二个参数,表达式arg2的值在计算出来之后作为第三个参数传给过滤器。 为避免混淆,下文中传入的参数个数及顺序只根据过滤器后跟的参数来统计。

熟悉Linux shell的读者可能对其中的管道符(|)的作用比较了解,即上一个命令的输出可 以作为下一个命令的输入。Vue.js过滤器中的管道符也同样支持这种方式的使用。这意味着Vue.js的过滤器支持链式调用,上一个过滤器的输出结果可以作为下一个过滤器的输入。代码示例如下：
```js
<span> {{'ddfe' | capitalize | reverse}}</span> 

//->'ddfe'=>'Ddfe'=>'efdD'

//capitalize过滤器：将输入字符串中的单词的首字母大写 
//reverse过滤器：反转字符串顺序
```
Vue.js过滤器链式调用的特性能够让用户随心所欲地处理数据,这种将各种功能相对独立 的过滤器函数组合起来解决复杂数据处理的方式与软件工程中的"高内聚、低耦合"设计思想 有异曲同工之妙。结合后文将要介绍的Vue.js强大的自定义过滤器的功能,用户可以非常灵活 地对数据进行处理,获得想要的数据形式。

### 内置过滤器

Vue.js内置了一系列常用的过滤器,可以直接进行调用。这些内置过滤器都相对比较简单, 如果要实现比较复杂或者需要定制的过滤功能,还是要借助自定义过滤器的方式。当然,这些 内置的过滤器使用时无须定义,比较适合刚上手Vue.js的新人。我们来看一下Vue.js中常用的过滤器。

Vue.js内置了capitalize、uppercase、lowercase三个过滤器用于处理英文字符。注：这三个 过滤器仅针对英文字符串使用。

1. capitalize

capitalize过滤器用千将表达式中的首字母转换为大写形式。代码示例如下：
```js
{{'ddfe' | capitalize } } //'ddfe';>'Ddfe'
```
2. uppercase

uppercase过滤器用千将表达式中的所有字母转换为大写形式。代码示例如下：
```js
{{'ddfe' | uppercase }} II'ddfe'=>'DDFE'
```
3. lowercase

lowercase过滤器用千将表达式中的所有字母转换为小写形式。代码示例如下：
```js
{{'DDFE'I lowercase }} //'DDFE'=>'ddfe'
```

### json过滤器

Vue.js中的json过滤器本质上是JSON.stringify()的精简缩略版,可将表达式的值转换为 JSON字符串,即输出表达式经过JSON.stringify()处理后的结果。json可接受一个类型为Number 的参数,用千决定转换后的JSON字符串的缩进距离,如果不输入该参数,则默认为2。代码 示例如下：
```js
<pre>{{ didiFamily | json 4 }}</pre> 
/*

以四个空格的缩进打印一个对象：

didiFamily: {'name':'ddfe','age': 3) ＝>

'name':'ddfe',

'age': 3

*/
```

### 限制

Vue.js中内置了limitBy、filterBy、orderBy三个过滤器用千处理并返回过滤后的数组,比 如与v-for搭配使用。注意,这三个过滤器所处理的表达式的值必须是数组,否则程序会报错。

1. limitBy

limitBy过滤器的作用是限制数组为开始的前N个元素,其中N由传入的第一个参数指定。

第二个参数可选,用于指定开始的偏移矗,默认为O,即不偏移。如果第二个参数为5,则表示 从数组下标为5的地方开始计数。代码示例如下：
```js
<!--只显示开始的10个元素-->

<div v-for="item in items | limitBy 10"></div>

<!-- 显示第5到15个元素-->

<div v-for="item in items | limitBy 10 5"></div>
```
2. filterBy

filterBy过滤器的使用比较灵活,其第一个参数可以是字符串或者函数。过滤条件是：'string II function'+ in+'optionKeyName'。

如果第一个参数是字符串,那么将在每个数组元素中搜索它,并返回包含该字符串的元素 组成的数组。代码示例如下：
```js
< div v-for="item in items | filterBy 'hello"'></div>
```
上例中,只显示包含hello字符串的元素。

如果item是一个对象,过滤器将递归地在它所有的属性中搜索。为了缩小搜索范围,可以 指定一个搜索字段。代码示例如下：
```js
<div v-for="member in didiFamily | filterBy 'ddfe' in 'name'"></div>
```
上例中,过滤器只在用户对象的name属性中搜索ddfe。最好始终限制搜索范围以提高效 率与性能。

也可以在多个字段中进行搜索,字段与字段之间以空格分隔。代码示例如下：
```js
<li v-for="user in users | filterBy 'Chris' in 'name' 'nickname'"></li>
```
还可以将搜索字段存放在一个数组中,这样当修改搜索字段时只需修改数组即可,无须再 修改View层。代码示例如下：
```js
< ! -- fields = ['fieldA','fieldB'] -->

<div v-for="user in users | filterBy searchText in fields"></div>
```
上面的例子中均使用了静态参数,当然也可以使用动态参数作为搜索目标或搜索字段。结 合v-model,我们可以轻松地实现输入提示效果。代码示例如下：
```js
<div id="dynamic-filter-by"> <input v-model="name">
<ul>
    <li v-for="user in users I filterBy name in'name'">
        {{ user.name}} 
    </li>
</ul>
</div>
new Vue ({ 
    el:'#dynamic-filter-by', 
    data: {
        name:'',
        users: [
            { name:'Bruce'}, { name:'Chuck'}, { name:'Jackie'}
        ]
    }
})
```

上例中,根据输入框中用户输入的数据,可以实时过滤出包含用户输入的字符串的数组元 素,十分高效、简洁。动态参数作为搜索字段的方式与此类似,不再赘述。

如果filterBy的第一个参数是函数,则过滤器将根据函数的返回结果进行过滤。此时filterBy 1 过滤器将调用JavaScript数组中内置的函数filter()对数组进行处理,待过滤数组中的每个元素都 将作为参数输入并执行传入filterBy中的函数。只有函数返回结果为true的数组元素才符合条 件并将存入一个新的数组,最终返回结果即为这个新的数组。

3. orderBy

orderBy过滤器的作用是返回排序后的数组。过滤条件是：'string || array || function'+'order >=0为升序|| order < 0为降序。第一个参数可以是子符串、数组或者函数。第二个参数order 可选,决定结果为升序或降序排列,默认为1,即升序排列。

若输入参数为字符串,则可同时传入多个字符串作为排序键名,字符串之间以空格分隔。

代码示例如下：
```js
<ul>
    <li v-for="user in users | orderBy 'lastName' 'firstName' 'age'">
        {{ user.lastName}}{{user. firstName }} {{ user.age }}
    </li>
</ul>
```
此时将按照传入的排序键名的先后顺序进行排序。

也可以将排序键名按照顺序放入一个数组中,然后传入一个数组参数给orderBy过滤器即 可。代码示例如下：
```js
<!-- sortKey= ['lastName','firstName','age']--> 
<ul>
    <li v-for="user in users I orderBy sortKey">
        {{ user.lastName }} {{ user.firstName }} {{ user.age }} 
    </li>
</ul>
```
当传入第一个参数为函数时,orderBy过滤器与JavaScript数组中内置的sort()函数表现一致。 注：事实上,当传入参数为字符串或者数组时,最终调用的也是sort()函数,只不过Vue.js 提前作了一些处理,比如设置了默认的compare函数等,根据传入的compare函数进行排序。

### currency过滤器

currency过滤器的作用是将数字值转换为货币形式输出。其第一个参数接受类型为String 的货币符号,如果不输入,则默认为美元符号$。第二个参数接受类型为Number的小数位,如 果不输入,则默认为2。注意,如果第一个参数采取默认形式,而需要第二个参数修改小数位, 则第一个参数不可省略。代码示例如下：
```js
{{ amount | currency)) // 12345 => $12,345.00
```
使用其他符号,比如英镑符号,代码示例如下：
```js
{ { amount | currency '£'} } // 12345 => £12, 345.00
```
将小数位调整为3位,代码示例如下：
```js
{{ amount | currency '$' 3)) // 12345 => $12,345.000
```
### debounce过滤器

debounce过滤器的作用是延迟处理器一定的时间执行。其接受的表达式的值必须为函数, 因此其一般与v-on等指令结合使用。debounce接受一个可选的参数作为延迟时间,单位为毫秒。 如果没有该参数,则默认的延迟时间为300毫秒。经过debounce包装的处理器在调用之后将至 少延迟设定的时间再执行。如果在延迟结束前再次调用,则延迟时长将重置为设定的时间。通 常,在监听用户input事件时使用debounce过滤器比较有用,可以防止频繁调用方法。debounce 的用法参考如下：
```js
<input @keyup="onKeyup I debounce 500">
```
### 自定义过滤器

大多数情况下,Vue.js中内置的过滤器并不能满足我们的需求,好在Vue.js还提供了自定 义过滤器的API供用户进行功能扩展。

#### fillter语法

在Vue.js中也存在一个全局函数Vue.filter用于构造过滤器：
```js
Vue.filter(ID,function() {})
```
该函数接受两个参数,其中第一个参数为过滤器ID,作为用户自定义过滤器的唯一标识; 第二个参数则为具体的过滤器函数。过滤器函数以值为参数,返回转换后的值。

1. 单个参数

注册一个名为reverse的过滤器,作用是将字符串反转输出。代码示例如下：
```js
Vue.filter ('reverse', function (value) {
    return value.split(''). reverse (). join ('') ;
})
<span v-text="message | reverse"></span> <!--'abc'=>'cba'-->
```
2. 多参数

过滤器函数除了以值为参数外,还支待接受任意数量的参数,参数之间以空格分隔。代码 示例如下：
```js
Vue.filter('wrap', function (value, begin, end) { 
    return begin+ value+ end
})

<span v-text＝"message | wrap 'before' 'after'"></span> <!--'hello'=>'before hello after'-->
```

3. 双向过滤器

上面的过滤器函数都是在Model数据输出到View层之前进行数据转化的,实际上Vue.js 还支持把来自视图(input元素)的值在写回模型前进行转化,即双向过滤器。代码示例如下：
```js
Vue.filter(id, { 
    //model-> view 
    // read函数可选
    read: function (val) { },

    //view-> model
    // write函数将在数据被写入Model之前调用 
    //两个参数分别为表达式的新值和旧值
    write: function(newVal, oldVal) {}
}) 
```

4. 动态参数

filter语法还有一个需要注意的点：动态参数。如果过滤器参数没有用引号包起来,则它 会在当前vm作用域内动态计算。此外,过滤器函数的this始终指向调用它的vm。代码示例 如下：
```js
<input v-model="userinput">

<span>{{msg | concat userinput}}</span>

<!--此处过滤器接受的参数userinput根据用户输入动态计算--> 
Vue.filter('concat', function (value, input) {
    //input=== `this.userinput·
    return value + input
})
```
#### 教你写—个filter

针对常规过滤器,之前已经给出一个比较简单的过滤器reverse的实现,代码示例 如下：
```js
Vue.filter ('reverse', function (value) { return value.split (''). reverse (). join ('') });
```
需要注意两点：

- 需要给定过滤器一个唯一标识。如果用户自定义的过滤器和Vue.js内置的过滤器冲突, 那么Vue.js内置的过滤器将会被覆盖;如果后注册的过滤器和之前的过滤器冲突,则之 前注册的过滤器层被稷盖。

- 过滤器函数的作用是输入表达式的值,经过处理后输出。因此,定义的函数最好可以返 回有意义的值。函数没有return语句不会报错,但这样的过滤器没有意义。

对于双向过滤器,这里给出一个例子供参考,代码示例如下：
```js
<div id="example"> <p>{{ message }}</p>

<input type='text' v-model="message | filterExample"> 
</div>

Vue.filter('filterExample', { 
    read: function(val) { return'read'+ val; },
    write: function(newVal, oldVal) { return oldVal +'write'};
}) ;

var demo = new Vue ({ 
    el:'it example', 
    data: {
        message:'hello world'
    }
}) ;
```
在初始情况下,页面显示如图6-2所示。message表达式的值经过filterExample中的read 函数处理,输出到View层。当我们在input框中修改message的值时,filterExample中的write 函数将在数据输出到Model层之前处理,这里将返回message的旧值＋'write',然后输出到Model 层,因此message的值变更为'hello world write'并显示在页面上,。


### 常见问题解析

1. filterBy/orderBy过滤后$index的索引

在使用filterBy或者orderBy对表达式进行过滤时,如果同时需要将$index作为参数,此时 的$index将会根据表达式数组或对象过滤后的值进行索引。代码示例如下：
```js
<ul id="example">
    <li v-for="item in terns | orderBy 'age'"> {{item.message }}-{{index}}</li>
</ul>

var example= new Vue({ 
    el:'#example',
    data: {
        items: [
            { message: '顺风车',age: 1},
            { message: '出租车',age: 10}, 
            { message: '快车',age: 6}
        ]
    }
})

//最终显示顺序为：顺风车－O、快车－1、出租车－2
```
2. 自定义filter的书写位置

自定义filter可以写在全局的Vue下,代码示例如下：
```js
Vue.filter('reverse', functon (value) { return value.split('').reverse().join (''); })
```
也可以写在实例当中,代码示例如下：
```js
var demo= new Vue({ 
    el:'#demo',
    data: {},
    filters: {
        //自定义filter事件
        reverse:function(value) {
            return value.split('').reverse().join('') ;
        }
    },
    methods:{}
})
```
二者本质上并无区别,可选择一种使用。但是采用Yue.filter时,需要在实例化Vue对象前 定义,否则自定义的filter将不起作用。

## Class与Style绑定

对千数据绑定,一个常见的需求是操作元素的class列表和它的内联样式。因为它们都是 attribute,我们可以用v-bind处理它们：只需要计算出表达式最终的字符串。不过,字符串拼接 麻烦又易错。因此,在v-bind用千class和style时,Vue.js专门增强了它。表达式的结果类型 除了字符串以外,还可以是对象或数组。

### 绑定HTML Class

#### 对象语法

我们可以传给v-bind:class一个对象,以动态地切换class。注意,v-bind:class指令可以与普 通的class特性共存。代码示例如下：
```js
<div id='example' class="static" v-bind: class=" {'didi-orange': isRipe,'didi-green': isNotRipe }"></div>

var vm = new Vue({
    el:'example', 
    data: {
        isRipe: true, 
        isNotRipe: false
    }
})
```
渲染为：
```js
<div id='example'class="static d过i-orange"></div>
```
当isRipe和isNotRipe变化时,class列表将相应地更新。例如,如果isNotRipe变为true,那么class列表将变为"static didi-orange didi－green"。(当然,一般情况下,v-bind:class绑定的对 象中只有一个class会生效,这取决千用户自己的设置。)

注：尽管可以用Mustache标签绑定class,比如class=" {{ className }} ",但是我们不推荐 这种写法和v-bind:class混用。

我们也可以直接绑定数据中的一个对象,代码示例如下：
```js
<div id='example' v-bind:class="ddfe"></div> 

var vm = new Vue({
    el:'example',
    data: { 
        ddfe: {
            'didi-orange': true, 
            'didi-green': false
        }
    }
})
```
还可以在这里绑定一个返回对象的计算属性。这是 种常用且强大的模式。代码示例如下：
```js
<div id='example' v-bind:class="ddfe"></div> 

var vm = new Vue ({
    el:'example',
    data: {
        didiAge: 4, 
        didiMernber:6000
    },
    computed: {
        ddfe: function() { 
            return {
            'didi-orange': this.didiAge>3? true: false,
            'didi－large': this. die扛Member>lOOO ? true: false
            }
        }
    }
})
```
#### 数组语法

我们可以把一个数组传给v-bind:class,以应用一个class列表。代码示例如下：
```js
<div id='example' v-bind:class="[didiHandsome, didiBeautiful]"> 

var vm = new Vue({
    el:'example',
    data: {
        didiHandsome:'didi-handsome', 
        didiBeautiful:'didi-beautiful'
    }
}}
```
渲染为：
```js
<div id='example'class="didi-handsome didi-beautiful"></div>
```
如果想根据条件切换列表中的class,则可以用三元表达式。代码示例如下：
```js
<div id='example'v-bind:class="[didiHandsome, isRipe? didirange:''] ">
```
此例始终添加didiHandsome,但是只有在isRipe为true时才会添加 didirange。

不过,当有多个条件class时这样写有些烦琐。可以在数组 语法中使用对象语法。代码示例如下：
```js
<div id='example' v-bind:class="[didiHandsome, { didiOrange: isRipe, didiGreen: isNotRipe }]">
```

##3 绑定内联样式

#### 对象语法

v-bind:style的对象语法十分直观一一看着非常像CSS,其实它是一个JavaScript对象。CSS 属性名可以用驼峰式(came!Case)或短横分隔命名(kebab-case)。代码示例如下：
```js
<div id='example' v-bind:style="{ color:didiColor, fontsize: fontsize +'px')"></div> 
var vm = new Vue({
    el:'example',
    data: {
        didiColor:'orange',
        fontSize: 30
    }
})
```
通常直接绑定到一个样式对象更好,让模板更清晰。代码示例如下：
```js
<div id='example' v-bind:style="ddfe"></div> 

var vm = new Vue ({
    el:'example',
    data: {
        ddfe: {
            color: orange, 
            fontSize:'13px'
        }
    }
})
```
同样的,对象语法常常结合返回对象的计算属性使用。代码示例如下：
```js
<div id='example' v-bind:style="ddfe"></div> 

var vm = new Vue ({
    el:'example',
    data: {
        didiAge:4,
        didiMember:6000
    },
    computed: {
        ddfe: function() { 
            return {
                color: this.didiAge>3? orange: green, 
                fontSize: this.didiMernber>1000? 20px: 10px
            }
        }
    }
})
```
#### 数组语法

v-bind:style的数组语法可以将多个样式对象应用到一个元素上。代码示例如下：
```js
<div v-bind:style="[ddfe, didiFamily]">
```

#### 自动添加前缀

当v-bind:style使用需要厂商前缀的CSS属性时,如transform, Vue.js会自动侦测并添加相 应的前缀。在Vue.js源码中采用prefix函数来完成这个功能,源码定义如下：

## 过渡

过渡效果在交互体验中的重要性不言而喻。以往我们使用jQuery添加或移除元素的类,搭 配CSS中定义好的样式,再引用一些JavaScript库之后,可以做出非常复杂、惊艳的动态效果, 不过这一套方法仍略显烦琐。Vue.js内置了一套过渡系统,可以在元素从DOM中插入或移除时 自动应用过渡效果。Vue.js会在适当的时机触发CSS过渡或动画,用户也可以提供相应的 JavaScript钩子函数在过渡过程中执行自定义DOM操作。

应用过渡效果,需要在目标元素上使用transition特性。代码示例如下：
```js
<div v-if="show" transition="my-transition"></div>
```
transition特性可以与以下资源一起搭配使用：

-  v-if
-  v-show
-  v-for(只在插入和删除时触发,使用vue-animated-1 ist插件) 
- 动态组件
- 在组件的根节点上,并且被Vue实例的DOM方法(如vm. $appendTo(el))触发 当插入或者删除带有transition特性的元素时,Vue.js将执行以下操作
- 尝试以ID "my-transition"查找JavaScript过渡钩子对象,该对象通过Vue. transition(id, hooks)或trans山ons选项注册(后文将介绍)。如果找到了,将在过渡的不同阶段调用 相应的钩子。
- 自动嗅探目标元素是否有CSS过渡或动画(按照Vue.js指定的方式添加类名即可),并 在合适时添加／删除CSS类名,免去了用户自已进行相关操作的烦琐。
- 如果没有找到JavaScript钩子并且也没有检测到CSS过渡／动画,DOM操作(插入／删 除)将在下一帧中立即执行。

### css过渡

Vue.js为用户定义了一套规则用千很方便地启用CSS过渡,典型的CSS过渡代码示例如下：
···js
<div v-if="show" transi七ion="expand">hello</div>
```
然后为expand-transtion、expand-enter和expand-leave添加CSS规则,这样Vuejs就会在 相应的阶段检测相应的CSS类的存在并及时添加和删除。添加CSS样式的代码示例如下：
```js
/*必需*/
.expand-transition { 
    transition: all.3s ease; 
    height: 30px;
    padding: l0px; 
    background-color: #eee; 
    overflow: hidden;
}   
/*.expand-enter定义进入的开始状态*/
/*.expand-leave定义离开的结束状态*/ 
. expand-enter,. expand-leave {
    height: 0; 
    padding: 0 l0px; 
    opacity: 0;
}
```
可以在同一个元素上通过动态绑定实现不同的过渡,代码示例如下：
```js
<div v-if="show" :transition="transitionName">hello</div> 
new Vue({
    el:'...',
    data: {
        show: false,
        transitionName:'fade'
    }
})
```
除此之外,还可以提供JavaScript钩子函数,以下为简单示例。
```js
Vue.transition ('expand', { 
    beforeEnter: function (el) { 
        el.textContent ='beforeEnter' 
    },
    enter: function (el) { 
        el.textContent ='enter' 
    },
    afterEnter: function (el) {
        el.textContent ='afterEnter' 
    },
    enterCancelled: function (el) { },
    beforeLeave: function (el) { 
        el.textContent ='beforeLeave' 
    },
    leave: function (el) { 
        el.textContent ='leave' 
    },
    afterLeave: function (el) { 
        el.textContent ='afterLeave' 
    },
    leaveCancelled: function (el) {}
})
```

### 内置Class类名

类名的添加以及切换取决千trans山on特性的值,例如transition ='boom',会有三个内置类名：

- .boom-transition,始终保留在元素上。
- . boom-enter,定义进入过渡的开始状态。只应用一帧,然后立即删除。
- .boom-leave,定义离开过渡的结束状态。在离开过渡开始时生效,在它结束后删除。

值得注意的是,如果trans山on没有指定值,即id为空,则使用默认类名：v-transition、.v-enter、.v-leave。

### 自定义CSS类名

用户可以在过渡的JavaScript中声明自定义的CSS过渡类名。这些自定义的类名会覆盖默 认的类名。当需要和第三方的CSS动画库如Animate.css配合时会非常有用。代码示例如下：
```js
<div v-show="ok" class="animated" transition="bounce">Watch me bounce</div> 
Vue.transition ('bounce', {
    enterClass:'bounceinLeft', 
    leaveClass:'bounceOutRight' 
})
```
### 显式声明CSS过渡类型

Vue.js需要给过渡元素添加事件侦听器来侦听过渡何时结束。基千所使用的CSS,该事件 要么是transitionend,要么是animationend。如果用户只使用了两者中的一种,那么Vue.js将能 够根据生效的CSS规则自动推测出对应的事件类型。但是,在有些情况下,一个元素可能需要 同时带有两种类型的动画。比如用户可能希望让Vue.js来触发一个CSS动画,同时该元素在鼠 标悬浮时又有CSS过渡效果。在这样的情况下,用户需要显式地声明希望Vue.js处理的动画类 型(animation或transition),代码示例如下：
```js
Vue.transition ('bounce', {

//该过渡效果将只侦听｀animationend、事件 
type:'animation'

))
```

### 动画案例

CSS动画的用法同CSS过渡,区别是在动画中v-enter类名在节点插入DOM后不会立即删 除,而是在animationend事件触发时删除。如果要运用JavaScript过渡中的钩子函数,正如上一 节所述需要显式地将传入的hooks对象中的type属性设置为animation。代码示例如下：
```js
<!--为简便起见,省略了animation和transform等兼容性前缀-->

<span v-show="show" transition="bounce">Look at me!</span>

.bounce-transition {
    display: in辽ne-block; /*否则scale动画不起作用*/
}
.bounce-en七er {
    animation: bounce-in.5s;
}
.bounce-leave {
    animation: bounce-out.5s;
}
@keyframes bounce-in { 
    0% {
        transform: scale (0);
    }   
    50% {
        transform: scale (1.5);
    }
    100% {
        transform: scale (1);
    }
}
@keyframes bounce-out{ 
    0% {
        transform: scale (1);
    }
    50% {
        transform: scale(l.5);
    }
    100% {
        transform: scale(O);
    }
}
```
### 过渡流程

我们以如下的结构为例来说明Vue.js内部是如何处理过渡的：
```js
<div v-show="show"七ransition="">Transition example</div>
```
当show属性改变时,Vue.js将相应地插入或删除<div>元素,按照如下规则改变过渡的CSS

类名(以下每一项在用户没有设置时都将会跳过)：

- 如果show变为false, Vue.js将： 
    - 调用beforeLeave钩子;
    - 将v-leave类名添加到元素上以触发过渡; 
    - 调用leave钩子;
    - 等待过渡结束(监听trans山onend事件)： 
    - 从DOM中删除元素并删除v-leave类名; 
    - 调用after Leave钩子。
- 如果show变为true, Vue.js将： 
    - 调用beforeEnter钩子;
    - 将v-enter类名添加到元素上;
    - 把它插入DOM中;
    - 调用enter钩子;
    - 强制一次CSS布局,让v-enter确实生效。然后删除v-enter类名,以触发过渡,回 到元素的原始状态;
    - 等待过渡结束;
    - 调用after Enter钩子。

另外,如果进入过渡还在进行中时删除元素,将调用enterCancelled钩子,以清理变动或 enter创建的计时器;反之,对千离开过渡也是如此。

上面所有的钩子函数在调用时,它们的this均指向其所属的Vue实例。编译规则为：过渡 在哪个上下文中编译,它的this就指向哪个上下文。

最后,enter和leave可以有第二个可选的回调参数,用于显式控制过渡如何结束。因此不 必等待CSS transitionend事件,Vue.js将等待用户手工调用这个回调函数,以结束过渡。代码示例如下：
```js
enter: function (el) (
//没有第二个参数
//由CSS transitionend事件决定过渡何时结束
}
enter: function (el, done) {
//有笫二个参数
//过渡只有在调用 done 时结束
}
```
注：当多个元素一起过度时,Vue.js会批量处理,只强制一次布局。

### JavaScript过渡

也可以只使用JavaScript钩子,不用定义任何CSS规则。当只使用JavaScript过渡时,enter 和leave钩子需要调用done回调,否则它们将被同步调用,过渡将立即结束。

建议只使用JavaScript钩子时,为JavaScript过渡显式声明css: false, Vue.js将跳过CSS检 测。这样也会防止CSS规则对过渡的干扰。

我们使用jQuery来注册一个自定义的JavaScript过渡,代码示例如下：
```js
Vue.transition ('fade', { 
    css: false,
    enter: function (el, done) {
        //元素已被插入DOM中
        //在动画结束后调用done 
        $(el).css('opacity', 0).animate ({ opacity: 1 }, 1000, done) 
    },
    enterCancelled: function (el) { 
        $(el). stop()
    },
    leave: function (el, done) { 
        //与enter相同
        $(el).animate({ opacity: 0 }, 1000, done) 
    },
    leaveCancelled: function (el) {
        $(el). stop()
    }
})
```
然后在transtion特性中声明,代码示例如下：
```js
<p transition="fade"></p>
```
完整地注册一个JavaScript过渡的代码示例如下：
```js
Vue.transition (ID, {enter: function (){}, leave: function (){}})
```
Vue.transtion方法接受两个参数,其中第一个参数是过渡ID,作为用户自定义的transition 的唯一标识;第二个参数是一个对象hooks。hooks必须含有enter和leave两个类型为function 的属性。这便是最基本的一个JavaScript过渡。除此之外,hooks还可以包含其他属性,代码示 例如下：
```js
{
type:'animation'
css: true, 
enterClass:'bounceinLeft', 
leaveClass:'bounceOutRight' 
beforeEnter: function (el) {},
enter: function (el) {}, 
afterEnter: function (el) {}, 
enterCancelled: function (el) {}, 
beforeLeave: function (el) {}, 
leave: function (el){}, 
afterLeave: function (el) { }, 
leaveCancelled: function (el) { }, 
stagger: function(index) {}
}
```
注：以上只是列出hooks对象可以设置的属性,不代表所有属性都需要被设置,属性的值 也仅供参考。而且有些属性存在互斥关系。比如设置了css值为false时,enterClass与leaveClass 的设置将无效。各属性的含义可见其他各节,或者查阅Vue.js官方文档。

### 渐进过渡

transition与v-for一起使用时可以创建渐进过渡,即让v-for中的每个过渡项目可以依次产生过渡效果,而不是一次性同步产生过渡效果。给过渡元素添加一个特性stagger、enter-stagger 或leave-stagger(以毫秒作为单位),分别可以控制每个过渡项目的延迟时间、进入时的延迟时 间以及离开时的延迟时间。我们来看看如何为列表元素添加渐进过渡效果。代码示例如下：
```js
<div v-for="item in list" transition="myStaggeredTransition" stagger="l00"></div> 

.myStaggeredTransition-transition {
    transition: all.Ss ease;
    overflow: hidden;
    margin: 0;
    height: 20px;
}
.myStaggeredTransition-enter,. myStaggeredTransition-leave { 
    opacity: O;
    height: 0;
}
```
或者提供一个钩子stagger、enter-stagger或leave-stagger,以更好地控制。代码示例如下：
```js
Vue.transition ('myStaggeredTransition', {
    stagger: function (index) { 
        //每个过渡项目增加50ms延时 //但是最大延时限制为300ms
        return Math.min(300, index* 50) 
    }
})
```


## Method

Vue.js的事件监听一般都通过v-on指令配置在HTML中,虽然也可以在JavaScript代码中使 用原生addEventListener方法添加事件监听,但Vue.js本身并不提倡如此。看上去这种方式不符 合传统的"关注点分离"(separation of concern)的理念,但其实所有的Vue.js事件处理方法和表 达式都严格绑定在当前视图的View Model上。实际上,采用它提供的v-on指令有如下几点好处：

- 通过查看HTML模板便能轻松定位JavaScript代码中对应的方法。
- 无须在JavaScript中手动绑定事件,View Model和DOM完全解耦,更易千测试。 
- 当一个View Model被销毁时,所有的事件处理器都会自动被删除。

### 如何绑定事件

在原生DOM事件中,我们可以通过JavaScript给HTML文档元素注册不同的事件处理程 序。代码示例如下：
```js
<button onclick="learnVue()">DDFE</button>
```
类似的,Vue.js也采取了这样的方式来绑定事件,下面进行详细介绍。

### 内联方式

Vue.js在HTML文档元素中采用v-on指令来监听DOM事件,代码示例如下：
```js
<div id="example">
<button v-on:click="greet">Greet</button> </div>
```

这里将一个单击事件处理器click绑定到greet方法,该方法在Vue实例中进行定义。

在这种内联方式下一个事件处理器只能绑定一个方法,如需绑定多个方法,仍需在 JavaScript代码中使用addEventListener方法来绑定。

同样的,类似于原生JavaScript以及Angular JS,除了直接绑定到一个方法外,也可以直接 使用内联JavaScript语句。代码示例如下：
```js
<div id="exarnple-2">

<button v-on:click="say('hi')">Say Hi</button>

<button v-on:click="count=count+ l">Say What</button> </div>
```
与内联表达式相仿,事件处理器限制为一个JavaScript语句。

### methods配置

当用户将click事件与某个方法绑定时,需要在Vue实例当中进行定义,所有 定义的方法都放在methods属性下。针对上一节的greet方法定义代码示例如下：
```js
var vm = new Vue({ 
    el:'#example',
//在methods'对象中定义方法 
    methods: {
        greet：function (event) { //方法内 this 指向vm
            alert ('Welcome to Vue.js By DDFE 1') //event·是原生DOM事件
            alert(event.target.tagName)
        }
    }
})
//也可以在JavaScript代码中调用方法 vm.greet()
```

对于say方法,可按照如下方式定义：
```js
new Vue({ 
    el:'#example-2', 
    methods: {
        say: function (msg) { 
            alert(msg)
        }
    }
})
```
需要注意的地方如下：

-  methods中定义的方法内的this始终指向创建的Vue实例。 
- 与事件绑定的方法支持参数event即原生DOM事件的传入。
- 方法用在普通元素上时,只能监听原生DOM事件;用在自定义元素组件上时,也可以 监听子组件触发的自定义事件。

### $events应用

在Vue实例中创建的方法需要访问原生DOM事件时可以直接传入event来获 取。如果在内联语句处理器中需要访问原生DOM事件时,则可以用一个特殊变量$event将其 传入方法中。代码示例如下：
```js
<button v-on:click="say('hello!', $event)">Subrnit</button> 
//...

methods: {
    say: function (msg, event) {
        //现在我们可以访问原生事件对象
        event.preventDefault()
    }
}
```

### 如何使用修饰符

在事件处理器上,Vue.js为v-on提供了4个事件修饰符,即.prevent、.stop、.capture与self,以使JavaScript代码负责处理纯粹的数据逻辑,而不用处理 这些DOM事件的细节。Vue.js还为v-on添加了按键修饰符,用千监听键盘事件。

在使用方式上,事件修饰符可以串联,代码示例如下：
```js
<a v-on:click.stop.prevent="doThat">
```
也可以只有修饰符而不绑定事件,代码示例如下：
```js
<form v-on:submit.prevent></form>
```

### prevent

在事件处理器中经常需要调用event. preventDefault()来阻止事件的默认行为,Vuejs提供了prevent事件修饰符以使之在HTML中便能完成操作。代码示例如下：
```js
<!-- 提交事件不再重载页面-->

<form v-on:submit.prevent="onSubmit"></form>
```
### stop

除了event.preventDefault(),用千阻止事件冒泡的event.stopPropagation()也经常被调用, Vue.js也提供了相应的stop事件修饰符。代码示例如下：
```js
<!--阻止单击事件冒泡-->
<a v-on:click.stop="doThis"></a>
```
### capture

capture事件修饰符表示添加事件侦听器时采用capture即 捕获模式。代码示例如下：
```js
<div v-on:click.capture="doThis">... </div>
```
### self

self事件修饰符表示只当事件在该元素本身(而不是 子元素)触发时触发回调。代码示例如下：
```js
<div v-on:click.self="doThat">... </div>
```
### 按键

监听键盘事件经常需要检测keyCode。Vue.js可以为v-on添加键盘修饰符,代码示例如下：
```js
<!--只有在keyCode是13时调用vm. submit()--> 
<input v-on:keyup.13;"submit">
```
鉴于记住所有的keyCode比较困难,Vue.js为常用的按键提供了别名。代码示例如下：
```js
<!--同上-->

<input v-on:keyup.enter="submit">

<!-- 缩写语法,详见下一节-->

<input @keyup.enter="submit">
```
完整的按键别名如下：

- enter (keycode:13) 
- tab (keycode:9)
- delete (keycode:8,46) 
- esc (keycode:27)
- space (keycode:32) 
- up (keycode:38)
- down (keycode:40) 
- left (keycode:37)
- right (keycode:39)


## Vue实例方法

本章我们介绍Yue实例提供的一些有用的属性和方法,这些属性和方法名都以前缀$ 开头。


### 组件树访问

1. $parent

用来访问当前组件实例的父实例。


2. $root

用来访问当前组件树的根实例,如果当前组件没有父实例,$root表示当前组件实例本身。 

3. $children

用来访问当前组件实例的直接子组件实例。 

4. $refs

用来访问使用了v-ref指令的子组件。

### DOM访问

1. $el

用来访问挂载当前组件实例的DOM元素。 

2. $els

用来访问$el元素中使用了v-el指令的DOM元素。

### 数据访问

1. $data

用来访问组件实例观察的数据对象,该对象引用组件实例化时选项中的data属性。

2. $options

用来访问组件实例化时的初始化选项对象。

### 实例DOM方法的使用

#### $appendTo()

$append To()方法用来将el所指的DOM元素或片段插入到目标元素中。 该方法接受两个参数：

- elementOrSelector(字符串或DOM元素),该参数可以是一个选择器字符串或者DOM 元素。

- callback(可选,函数),回调函数,该回调函数会在el元素被插入到目标元素后被触发。

注：如果在el上应用了过渡效果,则回调会在过渡完成后被触发。

#### $before()

$before()方法用来将el所指的DOM元素或片段插入到目标元素之前。

该方法接受两个参数：

-  elementOrSelector(字符串或DOM元素),该参数可以是一个选择器字符串或者DOM 元素。

-  callback(可选,函数),回调函数,该回调函数会在el元素被插入到目标元素后被触发。

注：如果在el上应用了过渡效果,则回调会在过渡完成后被触发。

#### $after()
$after()方法用来将el所指的DOM元素或片段插入到目标元素之后。

该方法接受两个参数：

-  elementOrSelector(字符串或DOM元素),该参数可以是一个选择器字符串或者DOM 元素。

-  callback(可选,函数),回调函数,该回调函数会在el元素被插入到目标元素后被触发。

注：如果在el上应用了过渡效果,则回调会在过渡完成后被触发。

#### $remove()
$remove()方法用来将el所指的DOM元素或片段从DOM中删除。

该方法接受一个参数：

-  callback(可选,函数),回调函数,该回调函数会在el元素在DOM中被删除后触发。

注：如果在el上应用了过渡效果,则回调会在过渡完成后被触发。

#### $nextTick()
$nextTick()方法用来在下次DOM更新循环后执行指定的回调函数,使用该方法可以保证 DOM中的内容已经与最新数据保持同步。

该方法接受一个参数：

-  callback(可选,函数),回调函数,该回调函数会在下次DOM更新循环后被执行。它 和全局的Vue.nextTick方法一样,不同的是,callback中的this会自动绑定到调用它的 Yue实例上。

### 实例Event方法的使用

#### $on()

$on()方法用来监听实例上的自定义事件。

该方法接受两个参数：

-  event(字符串),该参数可以是一个事件名称。

- callback(函数),回调函数,该回调函数会在执行$emit、$broadcast或者$dispatch后触发。

#### $once()
$once()方法也是用来监听实例上的自定义事件,但只触发一次。

该方法接受两个参数：

-  event(字符串),该参数可以是一个事件名称。

- callback(函数),回调函数,该回调函数会在执行$emit、$broadcast或者$dispatch后触发。

#### $emit()
$emit()方法用来触发事件。

该方法接受两个参数：

-  event(字符串),该参数可以是一个事件名称。 
- args(可选),传递给监听函数的参数。

#### $dispatch()

$dispatch()方法用来派发事件,即先在当前实例触发,再沿着父链一层一层向上,如果对应的监听函数返回false就停止。

该方法接受两个参数：

- event(字符串),该参数可以是一个事件名称。 
- args(可选),传递给监听函数的参数。

#### $broadcast()

$broadcast()方法用来广播事件,即遍历当前实例的$children,如果对应的监听函数返回false 就停止。

该方法接受两个参数：

- event(字符串),该参数可以是一个事件名称。 
- args(可选),传递给监听器的参数。

6. $off()

$off()方法用来删除事件监听器。

该方法接受两个参数：

-  event(字符串),该参数可以是一个事件名称。 
- callback(可选,函数),对应的回调函数。

如果没有参数,即删除所有的事件监听器;如果只提供一个参数——事件名称,即删除它 对应的所有监听器;如果提供两个参数一一事件名称和回调函数,即删除对应的这个回调函数。



## 组件

组件是Vue.js最推崇的,也是最强大的功能之一,核心目标是为了可重用性高,减少重复 性的开发。我们可以把组件代码按照template、style、script的拆分方式,放置到对应的vue文 件中。

Vue.js的组件可以理解为预先定义好行为的View Model类。一个组件可以预定义很多选项, 但最核心的是以下几个：

- 模板(template)一模板声明了数据和最终展现给用户的DOM之间的映射关系。

- 初始数据(data)一一一个组件的初始数据状态。对于可复用的组件来说,通常是私有 的状态。

- 接受的外部参数(props)一组件之间通过参数来进行数据的传递和共享。参数默认 是单向绑定(由上至下),但也可以显式声明为双向绑定。

- 方法(methods) 对数据的改动操作一般都在组件的方法内进行。可以通过v-on指令将用户输入事件和组件方法进行绑定。

- 生命周期钩子函数(lifecycle hooks) 一个组件会触发多个生命周期钩子函数,

比如created、attached、destroyed等。在这些钩子函数中,我们可以封装一些自定 义的逻辑。和传统的MVC相比,这可以理解为Controller的逻辑被分散到了这些钩 子函数中。

### 注册 
#### 全局注册
```js
Vue.component('didi-component', DIDIComponent)
```
如上所示,第一个参数是注册组件的名称(即在HTML中我们可以这样使用组件： <didi-component></didi-component>);第二个参数是组件的构造函数,它可以是Function,也可 以是Object。

-  Function——DIDIComponent可以是用Vue.extend()创建的一个组件构造器。代码示例如下：
```js
var MyComponent = Vue.extend({
//选项．．
})
```
- Object—DIDIComponent传入选项对象,Vue.js在背后自动调用Vue.extend()。代码 示例如下：
```js
//在一个步骤中扩展与注册
Vue.component('didi-component', { template:'<div>A custom component!</div>'})
```
组件在注册之后,便可以在父实例的模块中以自定义元素<小di-component>的形式使用。要 确保在初始化根实例之前注册了组件,代码示例如下：
```js
<body>
<div id="example"> <didi-component></didi-component></div> 
</body> 

<script>
var DIDIComponent = Vue.extend({
    template:'<div>A custom component!</div>' 
})

//注册
Vue.component(didi-component', DIDIComponent)

//创建根实例
new Vue ({ 
    el:'#example'
}) 
</script>
```
注：组件的模板替换了自定义元素,自定义元素的作用只是作为一个挂载点。可以用实例选项replace决定是否替换自定义元素。


#### 局部注册

不需要每个组件都全局注册,可以让组件只能用在其他组件内。我们可以用实例选项 components注册,代码示例如下：
```js
<body>
<div id="example"> <didi-component></didi-component> </div>
</body>

<script>
var Child= Vue.extend({ 
    template:'<div>i am child!</div>', 
    replace: true
})

var Parent= Vue.extend({
    template:'<p>i am parent</p><br/><child></child>', 
    components: {
        // <中di-component>只能用在父组件模板内 
        'child': Child
    }
})

//创建根实例
new Vue({
    el:'#example',
    components: { 'didi-component': Parent}
})

</ script> 
```

为了让事件更简单,我们可以直接传入选项对象而不是构造器给Vue.component()和 components选项。代码示例如下：
```js
//在一个步骤中扩展与注册

Vue.component('didi-component',{ template:'<div>A custom component!</div>' })

//局部注册也可以这么做
var Parent= Vue.extend({ 
    components: { 'didi-component': {
    template:'<div>A custom component!</div>'
})
```
### 数据传递

总结下来,Vue.js组件之间有二种数据传递方式：

-  props
- 组件通信
- slot

下面我们分别对每一种数据传递方式做详细的阐述。

#### props

"props"是组件数据的一个字段,期望从父组件传下来数据。因为组件实例的作用域是孤 立的,这意味着不能并且不应该在子组件的模板内直接引用父组件的数据,所以子组件需要显 式地用props选项来获取父组件的数据。props选项可以是字面量,也可以是表达式,还可以绑 定修饰符。下面我们详细看一下它是如何使用的。

1. 字面量语法
```js
Vue.component('child', { 
    //声明props
        props: ['msg'],
    // prop可以用在模板内
    //可以用this.msg
    template:'<span> {{msg}}, DDFE! </span>'
})
```
向它传入一个普通字符串
```js
<child msg="hello"></child>
```
HTML特性不区分大小写。名字形式为camelCase的props用作特性时,需要转换为 kebab-case形式(短横线隔开)。代码示例如下：
```js
Vue.extend({
    //声明props
    props: ['myCornponent'],
    template:'<div> {{rnyCornponent}} DDFE! </div>', 
    replace: true
})

<!--kebab-case in HTML-->
<child my-cornponent＝"hello1"></child>
```
2. 动态语法

类似于用v-bind将HTML特性绑定到—个表达式,我们也可以用v-bind将动态props绑定 到父组件的数据。每当父组件的数据变化时,该变化也会传导给子组件。代码示例如下：
```js
var Child= Vue.extend({ 
    //声明props
    props: ['didiProps'],
    template:'<div> {{didiProps }} DDFE! </div>', 
    replace: true
})

var Parent= Vue.extend({
    template:'<p>i am parent</p><br/><child :didi-props="hello"></child>', 
    data:function () {
        return {'hello':'hello,'} 
    },
    components: {
        //<child>只能用在父组件模板内 
        'child': Child
    }
})

//创建根实例
new Vue ({
    el:'#example', 
    components: { 'didi-props': Parent}
})
```
3. 绑定修饰符

props默认是单向绑定一—当父组件的属性变化时,将传导给子组件,但是反过来不会。这 是为了防止子组件无意修改父组件的状态一—这会让应用的数据流难以理解。不过,也可以使 用绑定修饰符：

- .sync,双向绑定。 
- .once,单次绑定。 

代码示例如下：
```vue
<!--默认为单向绑定-->
<child :msg="parentMsg"></child> <!--双向绑定-->
<child :msg.sync="parentMsg"></child>
<!--单次绑定-->
<child :msg.once="parentMsg"></child>
```
双向绑定会把子组件的msg属性同步回父组件的parentMsg属性(类似千Angular JS绑定 策略中的＝);单次绑定在建立之后不会同步之后的变化。如果props是一个对象或数组,那么 它是按引用传递的。在子组件内修改它会影响父组件的状态,而不管使用哪种绑定类型。代码 示例如下：
```vue
<body id="example">
    <input type="text" v-model="info.name"/> <child v-bind:msg.once="info"></child> 
</body>

<script>

//创建根实例
new Vue ({ 
    el:'#example', 
    data: function() {
        return { 
            info: {
            name:'顺风车'
            }
        }
    },
    components: {
        'child': {
            //声明 props 
            props: ['msg'],
            template:'<div>{ {msg.name}} DDFamily</div>'
        }
    }
}) 
</script>
```

组件可以为props指定验证要求。当组件给其他人使用时,可以确保其他人正确地使用组件。此时prop的值是一个对象,代码示例如下：
```js
Vue.component ('example', { 
    props: {
        //基础类型检测 (、null、的意思是任何类型都可以)
        propA:'null',
        //多种类型(1.0.21+) propM: [String, Number], //必需且是字符串
        propB: {
            type: String, 
            required: true 
        },
        //数字,有默认值 
        propC: {
            type: Number, 
            default: 100 
        },
        //对象/数组的默认值应当由一个函数返回 
        propD: {
            type: Object,
            default: function () {
                return { msg:'hello'}
            }
        },
        //指定这个prop为双向绑定
        //如果绑定类型不对将抛出一条警告 
        propE: {
            twoWay: true 
        },
        //自定义验证函数 
        propF: {
            validator: function (value) { 
                return value> 10
            }
        }
})
```
type可以是下面的原生构造器：

- String 
- Number 
- Boolean
- Object
- Function
- Array

type也可以是一个自定义构造器,使用instanceof检测。

当props验证失败时,Vue.js将拒绝在子组件上设置此值,如果使用的是开发版本,将会抛 出一条警告。

5. prop转换函数

现在我们可以给prop定义一个coerce函数－~每当prop在父类更新 的时候,prop的值将会通过coerce函数,可以将它理解为prop的单向过滤器,只是它被定义在了子类组件内。
```js
Vue.component('example', {
    props: {
    //转换函数
    //在设罚值之前转换值
        propG: {
            coerce: function (val) {
                return val+''//将值转换为字符串
            }
        },
        propH: {
            coerce: function (val) {
                return JSON.parse(val) //将JSON字符串转换为对象
            }
        }
    })
```

6. props & props Data & data

以上属性均与数据有关,props上面已经介绍,它作用千父子组件之间的数据传递;而data 我们在开发组件或实例化Vue对象时经常使用,它作为组件的私有数据存在;propsData这个属 性则常用来在组件初始化后覆盖props中的属性。

#### 组件通信

Vue.js组件之间的相互通信。子组件可以用this.$parent 访问它的父组件,父组件有一个数组this.$children,包含它所有的子元素,根实例的后代可以 用this.$root访问根实例,不过子组件应当避免直接依赖父组件的数据,尽矗显式地使用props 传递数据。另外,在子组件中修改父组件的状态是非常糟糕的做法,因为：

- 父组件与子组件紧密地耦合。

- 只看父组件,很难理解父组件的状态,因为它可能被任意子组件修改!"在理想情况下, 只有组件自己能修改其状态。

因为作用域是有层次的,所以我们可以在作用域链上传递事件。通常来说,选择事件传递 方式,一个好的经验规则就是：查看要触发事件的作用域。如果要通知整个事件系统,就要向下广播。每个Vue实例都是一个事件触发器： 0 $on()·—监听事件。

- $emit()—把事件沿着作用域链向上派送。

- $dispatch()一—派发事件,事件沿着父链冒泡。

- $broadcast()一—广播事件,事件向下传导给所有的后代。

在解决组件之间通信问题前,我们先来看一下vue的自定义事件接口,用千在组件树中通 信。这个事件系统独立于原生DOM事件,用法也不同,代码示例如下：
```js
<body>

<!--子组件模板-->

<template id="child－template"> 
    <input v-model="msg">
    <button v-on:click="notify">Dispatch Event</button> 
</template>
<!--父组件模板-->
<div id="events-example">
<p>Messages: { { messages | json } } </p> <child></child>
</div>
</body>

<script>
//注册子组件
//将当前消息派发出去

Vue.component('child',{ 
    template:'#child-template', 
    data: function () {
        return {msg:'hello'}
    },
    methods:{
        notify: function () {
            if (this.msg.trim()){ 
                this.$dispatch('child-msg', this.msg) 
                this.msg = ''
            }
        }
    }
})

//初始化父组件
//收到消息时将事件推入一个数组中

var parent = new Vue({ 
    el:'#events-example', 
    data: {
        messages: [] 
    },
    //在创建实例时飞vents、选项简单地调用飞on、
    events: {
        'child-msg': function (msg) {
            //事件回调内的飞his 自动绑定到注册它的实例上
            this.messages.push(msg)
        }
    }
}) 
</script>
```

上面展示了父子组件的通信,只是从父组件的代码中不能直观地看到child-msg事件来自哪 里。如果在模板中子组件用到的地方声明事件处理器则会更好。为此,子组件可以用v-on监听 自定义事件。代码示例如下：
```js
<body>
<!--子组件模板-->
<template id＝"child-template"> <input v-model="msg">

<button v-on:click="notify">Dispatch Event</button> </template>

<!--父组件模板-->

<div id="events-example">
<p>Messages: {{ messages | json}} </p>
<child v-on:child-msg="handleit"></child> 
</div>
</body>

<script>

//注册子组件
//将当前消息派发出去

Vue.component('child', { 
    template:'#child-template', 
    data: function () {
        return { msg:'hello'}
    },
    methods: {
        notify: function () {
            if (this.msg.trim()) {
                this.$dispatch ('child-msg', this. msg) 
                this.msg =''
            }
        }
    }
})

//初始化父组件
//在收到消息时将事件推入一个数组中
var parent= new Vue({ 
    el:'#events-example', 
    data: {
        messages: []
    },
    methods:{
        'handleit': function() { 
            alert("a")
        }
    }
}) 
</script>
```
这样就很清楚了 当子组件触发了child-msg事件时,父组件的handlelt方法将被调用。

所有影响父组件状态的代码都放到父组件的handlelt方法中;子组件只关注触发事件。

尽管有props和events;但是有时仍然需要在JavaScript中直接访问子组件。为此,可以使 用v-ref为子组件指定一个索引ID。代码示例如下：
```js
<comp v-ref:child></comp> 
<comp v-ref:some-child></comp>

//从父组件访问

this.$refs.child 
this.$refs.someChild
```
#### slot分发内容

在使用组件时,常常要像这样组合它们：
```js
<didi> <didi-header></didi-header> <didi-footer></didi-footer> <Id辽扛>
```
注意两点：

- \<didi>组件不知道它的挂载点会有什么内容,挂载点的内容是由\<didi>的父组件决定的。 
- \<didi>组件很可能有它自己的模板。

为了让组件可以组合,我们需要一种方式来混合父组件的内容与子组件自己的模板。这个 处理称为内容分发(或"transcl us ion")。Vue.js实现了一个内容分发 API,参照了当前Web组件规范草稿,使用特殊的\<slot>元素作为原始内容的插槽。

(1)编译作用域

在深入内容分发APT之前,我们先明确内容的编译作用域。假定模板为：
```js
<child v-on:child-msg="handleit">{{msg}}</child>
```
msg应该绑定到父组件的数据,还是绑定到子组件的数据？答案是父组件。简单地说, 组件作用域是：父组件模板的内容在父组件作用域内编译;子组件模板的内容在子组件作用 域内编译。

一个常见的错误是试图在父组件模板内将一个指令绑定到子组件的属性／方法：
```js
<!--无效-->
<child-component v-show="someChildProperty"></child-component>
```
假定someChildProperty是子组件的属性,上例不会如预期的那样工作。父组件模板不应该 知道子组件的状态。

如果要将子组件内的指令绑定到一个组件的根节点,则应当在它的模板内这样做：

```js
Vue.component ('child-component', {

//有效,因为是在正确的作用域内
template:'<div v-show=" someChildProper七y">Child</d攻>', 
data: function () {
    return {
        someChildProperty:true
    }
}
})
```
类似的,分发内容是在父组件作用域内编译的。 

(2)单个slot

父组件的内容将被抛弃,除非子组件模板包含\<slot>。如果子组件模板只有一个没有特性的 slot,父组件的整个内容将插到slot所在的地方并替换它。

\<slot>标签的内容视为回退内容。回退内容在子组件的作用域内编译,当宿主元素为空并且 没有内容供插入时显示这个回退内容。

假定didi-component组件有下面模板：
```js
<div>
    <hl>This is my component!</hl> 
    <slot>
    如果没有分发内容则显示我。
    </slot> 
</div>
```
父组件模板：
```js
<didi-component>
<p>This is some original content</p> 
<p>This is some more original content</p> 
</didi-component>
```
渲染结果为：
```js
<div>
    <hl>This is my component</hl> 
    <p>This is some original content</p>
    <p>This is some more original content</p> 
</div>
```

(3) 具名slot

\<slot>元素可以用一个特殊特性name配置如何分发内容。多个slot可以有不同的名字。具名slot将匹配内容片段中有对应slot特性的元素。

仍然可以有一个匿名slot,作为找不到匹配的内容片段的回退插槽,它是默认slot。如果没有默认slot,这些找不到匹配的内容片段将被抛弃。

例如,假定有一个multi-insertion组件,代码示例如下：
```js
<div>
    <slot name="one"></slot> 
    <slot></slot>
    <slot name="two"></slot> 
</div>
```
父组件模板：
```js
<multi-insertion>
    <p slot="one">One</p> 
    <p slot="two">Two</p> 
    <p>Default A</p>
</multi-insertion>
```
渲染结果为：
```js
<div>
<p slot="one">One</p> 
<p>Default A</p>
<p slot="two">Two</p> 
</div>
```
在组合组件时,内容分发API是非常有用的机制。 

slot在bind回调函数中,根据name获取将要替换插槽的元素,如果在上下文环境中有所 需替换的内容,则调用父元素的replaceChild方法,用替换元素将slot元素替换;否则直接删除 将要替换的元素。如果替换插槽元素中有一个顶级元素,且顶级元素的第一子节点为DOM元 素,且该节点有v一if指令,且slot元素中有内容,则替换模板将增加v-else模板放入插槽中的 内容,如果v一if指令为false,则渲染else模板内容。

### 混合

混合以一种灵活的方式为组件提供分布复用功能。混合对象可以包含任意的组件选项。当 组件使用了混合对象时,混合对象的所有选项将被"混入"组件自己的选项中。代码示例如下：
```js
var myMixin = {
    created: function (){ 
        this.hello()
    },
    methods: {
        hello: function () {
            console.log ('hello from mixin 1')
        }
}

//定义一个组件,使用这个混合对象
var component= Vue.extend({ mixins: [myMixin], template:"<hl>hello~ DIDI</hl>" })

//创建根实例
new Vue ({ 
    el:'#example', 
    components: {
        'my-component': component
    }
})
```

当混合对象与组件包含同名选项时,这些选项将以适当的策略合 并。例如,同名钩子函数被并入一个数组中,因而都会被调用。另外, 混合的钩子将在组件自己的钩子之前调用,代码示例如下：
```js
var myMixin = {
    created: function () { 
        this. hello ()
    },
    methods: {
        hello: function () {
            console. log ('hello from mixin !')
        }
    }
}

//定义一个组件,使用这个混合对象
var component= Vue.extend({ 
    mixins: [myMixin],
    template:"<hl>hello~ DIDI</hl>", 
    created: function () {
        console. log ('component hook called')
    }
})

//创建根实例

new Vue ({ 
    el:'#example', 
    components: {
        'my-component': component
    }
})
```

值为对象的选项,如methods、components和directives将合并到同一个对象内。如果键冲 突,则组件的选项优先。代码示例如下：
```js
var myMixin={ 
    methods: {
        foo: function () { 
            console. log ('foo') 
        },
        conflicting: function () { 
            console. log ('from mixin')
        }
    }
}

//定义一个组件,使用这个混合对象
var myMixin = { 
    methods: {
        foo: function () { 
            console. log ('foo') 
        },
        conflicting: function () { 
            console. log ('from mixin')
        }
    }
}

//定义一个组件,使用这个混合对象

var component=Vue.extend({ 
    mixins: [myMixin], 
    template:'<hl>hello~ DIDI</hl>', 
    methods: {
        bar: function () { 
            console. log ('bar') 
        },
        conflicting: function () { 
            console. log ('from self')  
        }
    }
})

var vm = new component();

vm.foo() // -> "foo"

vm. bar() // -> "bar" vrn.conflicting() //->"from self"
```
注：Vue.extend()使用同样的合并策略。

混合也可以全局注册,但需要小心使用!"一旦全局注册混合,它就会影响所有之后创建的Vue实例。如果使用恰当,则可以为自定义选项注入处理逻辑。代码示例如下：
```js
Vue.mixin{(
    created: function () {
        var myOption = this.$options.my0ption 
        if(myOption){
            console.log(myOption)
        }
    }
})

//定义一个组件,使用这个混合对象

var component= Vue.extend({ template:"<hl>hello~ DIDI</hl>"})

new Vue ({
    el:'#example',
    components: {
        'my-component': component
    }
    myOption:'hello'
})
```
慎用全局混合,因为它会影响到每个所创建的Vue实例,包括第三方组件。在大多数情况 下,它应当只用千自定义选项,就像上面示例一样。

### 动态组件

多个组件可以使用同一个挂载点,然后动态地在它们之间切换。使用保留的\<component> 元素,动态地绑定到它的is特性。代码示例如下：

<body id="example">

<input type="radio" id="one" value="fast" v-model="currentView"> <label for="one">fast</label>

<br>

<input type="radio" id="two" value="bus" v-model="currentView"> <label for="two">bus</label>

<br>

<input type="radio" id="two" value="business" v-model="currentView"> <label for="two">business</label>

<template id="bus">

第11章组件 127

<div>滴滴巴士</div> </template>

<template id="business"> <div>滴滴专车</div> </template>

<templa七e id="fast"> <div>滴滴快车</div> </template>

<component :is="currentView">

<'--组件在vm.currentview变化时改变－－> </component>

</body>

<script>

var bus= Vue.extend({ 七emplate:'#bus',

replace:七rue

)) ;

var business= Vue.extend({ template:'#business',

replace:七rue

})

var fast= Vue.extend({ templa七e:'#fast', replace: true

))

//创建根实例

new Vue ({ el:'#example',

data: { currentView:'fast'

},

components: ( fast: fast, bus: bus,

business: business

}) </script>

通过is属性绑定的vm.currentView变量值,控制展示的组件,效果 如图11-7所示。

图11-7 动态组件

128 Vue.js权威指南

1. keep-alive

如果把切换出去的组件保留在内存中,则可以保留它的状态或避免重新渲染。为此,可以 添加一个keep-alive指令参数。代码示例如下：

<component :is="currentView" keep-alive> <'－－非活动组件将被缓存－－>

</component>

源码定义如下：

< !" －－源码目录：src/ut].1/env.js 7行－－> b].nd: funct].on () {

//省略

// keep-alive cache

this.keepAlive =七his.params.keepAlive if (this.keepAlive) {

this.cache={}

略 省 ／

1I/

),

build: function (extraOpt).ons) { var cached= th).s. get Cached () ).f (cached) {

return cached

Vue」s为其组件设计了一个[keep-alive]的特性,如果这个特性存在,那么在组件被重复创建 时,会通过缓存机制快速创建组件,以提升视图更新的性能。

2. activate钩子

在切换组件时,切入组件在切入前可能需要进行一些异步操作。为了控制组件切换时长, 给切入组件添加activate钩子函数。代码示例如下：

Vue.componen七('acti va te-exarnple', { activate: function (done) {

var self= this

loadDataAsync(func巨on (data) {

第11章组件 129

self.someData = data done()

})

注：activate钩子只作用于动态组件切换或静态组件初始化渲染的过程中,不作用于使用实 例方法手工插入的过程中。

3. transition-mode

trans山on-mode特性用于指定两个动态组件之间如何过渡。

在默认情况下,进入与离开平滑地过渡。这个特性可以指定另外两种模式： 0 in-out—新组件先过渡进入,等它的过渡完成之后当前组件过渡出去。 0 out-in—当前组件先过渡出去,等它的过渡完成之后新组件过渡进入。

<'－－先淡出再淡入－－>

<component

:is="view"

transi巨on="fade" transition-mode="out-in"> </component>

.fade-transition {

transition: opacity.3s ease;

. fade-enter,. fade-leave { opacity: 0;

11.2 相关拓展

11.2.1 组件和v-for

自定义组件可以像普通元素一样直接使用v-for,代码示例如下：

<didi-component v-for="item in items"></didi-component>

因为组件的作用域是孤立的,上面的代码无法将数据传递到组件内部。在11.l.2节中我们

130 Vue.js权威指南

讲述了组件之间通信的三种方式,这里将使用props。代码示例如下：

<didi-component v-for="item in items" :item='飞tem" :index="$index"></didi-component>

注：显式声明数据来自哪里可以让组件复用在其他地方。

11.2.2 编写可复用组件

在编写组件时,时刻考虑组件是否可复用是有好处的。一次性组件跟其他组件紧密耦合没

关系,但是可复用组件一定要定义一个清晰的公开接口。

Vue.js组件API来自三部分——prop、事件和slot,关于这三部分上面已作详尽说明。 0 prop允许外部环境传递数据给组件。

O事件允许组件触发外部环境的action。

0 slot允许外部环境将内容插入到组件的视图结构内。

使用v-bind和v-on的简写语法,模板的缩进清楚且简洁。代码示例如下：

<my-component :foo="baz" :bar="qux"

@even七－a="doThis" @event-b="doThat"> <!-- conten七－－>

豆mg slot="icon" src="... ">

<p slot="main-text">Hello!</p> </my-component>

11.2.3 异步组件

在大型应用中,我们可能需要将应用拆分为小块,每小块实现按需加载。为了让事情更简 单,Vue.js允许将组件定义为一个工厂函数,动态地解析组件的定义。Vue.js只在组件需要渲染 时触发工厂函数,并且把结果缓存起来,方便后面的再次渲染。代码示例如下：

Vue.component('async-example', func巨on (resolve, reject) { setTimeout(func巨on () (

resolve ((

template:'<div>I am async!</div>' })

}, 1000) })

第11章组件 131

工厂函数接受一个resolve回调,在收到从服务器下载的组件定义时调用。也可以调用 reject(reason)指示加载失败。这里setTimeout只是为了演示。怎么获取组件完全由我们决定,推 荐配合使用Webpack的代码分割功能。代码示例如下：

Vue. component ('async-webpack-example', function (resolve) {

//这个特殊的require语法告诉Webpack,将编译后的代码分割成不同的块 //这些块将通过AJAX请求自动下载

require(['./my-async-component'], resolve)

})

11.2.4 资源命名约定

一些资源如组件和指令,是以HTML特性或HTML自定义元素的形式出现在模板中的。

因为HTML特性的名字和标签的名字不区分大小写,所以资源的名字通常需使用kebab-case而 不是camel Case形式,这不大方便。

Vue.js支持资源的名字使用camel Case或Pascal Case形式,并且在模板中自动将它们转换为 kebab-case形式(类似千prop的命名约定)。代码示例如下：

//在组件定义中

componen七s: {

//使用camelCase形式注册 myComponent: { *... */ }

<'－－在模板中使用kebab-case形式－－> <my-component></my-component>

ES 6对象字面量缩写也没问题：

// PascalCase

import TextBox from'./components/text-box';

import DropdownMenu from'./components/dropdown-menu';

export default {

components: {

//在模板中写作<text-box>和<dropdown-menu> TextBox,

DropdownMenu

132 Vue.js权威指南

11.2.5 内联模板

如果子组件有in line-template特性,组件将把它的内容当作其模板,而不是把它当作分发内 容且in line-template优先级比template高。这让模板更灵活。代码示例如下：

<didi-component inline-template>

<p>These are compiled as the component's own template</p> <p>Not parent's transclusion content.</p> </didi-component>

但是in line-template让模板的作用域难以理解,并且不能缓存模板编译结果。最佳实践是使 用template选项在组件内定义模板。代码示例如下：

<body id="example"> <div id="items">

<b>inline-template:</b>

<my-item v-for="item in i七ems" : item=" item" inline-template>

<p> ((a} }, ((i七em.text}}</p> </my-item> <b>no-inline-template:</b>

<my-item v-for="item in items" : item="item">

{{a}}, {{iterns[O].七ext}} </my-item>

</div>

</body>

<script>

var items= [

{ number: 1, text:'one'}, { number:2, text:'two')

.'

var vue = new Vue({ el:'#items',

da七a: function() { return {

items: items,

a:"i am in parent"

},

components: { 'my-item': {

第11章组件 133

props: ['i tern'], data: function() ( return (

a:'i am in child'

),

template:'<p江tern模板： { {a}}, {巨tern.text}}; slot: <slot></slot></p>'

}) ; </script>

效果如图11-8所示。

11.2.6 片段实例

图11-8 内联模板

在使用template选项时,模板的内容将替换实例的挂载元素,因而推荐模板的顶级元素始 终是单个元素C

不要这样写模板：

<div>root node 1</div> <div>root node 2</div>

推荐这样写：

<div>

I have a single root node! <div>node 1</div> <div>node 2</div>

</div>

下面几种情况会让实例变成一个片段实例： 0模板包含多个顶级元素。

0模板只包含普通文本。

0模板只包含其他组件(其他组件可能是一个片段实例)。

0模板只包含一个元素指令,如<partial>或vue-router的<router-view>。 0模板根节点有一个流程控制指令,如v一if或v-for。

134 Vue.js权威指南

这些情况让实例有未知数量的顶级元素,它将把其DOM内容当作片段。片段实例仍然会 正确地渲染内容。不过,它没有一个根节点,它的$el指向一个锥节点,即一个空的文本节点(在 开发模式下是一个注释节点)。

但是更重要的是,组件元素上的非流程控制指令,非prop特性和过渡将被忽略,因为没有 根元素供绑定。代码示例如下：

<!"－－不可以,因为没有根元素－－>

<example v-show="ok" transition="fade"></example> <!-- props可以－－>

<example :prop="someData"></example>

<'－－流程控制可以,但是不能有过渡－－>

<example v五f="ok"></example>

当然片段实例有它的用处,不过通常给组件一个根节点比较好。它会保证组件元素上的指 令和特性能正确地转换,同时性能也稍微好些。

11.3 生命周期

在Vue.js中,在实例化Vue之前,它们以HTML的文本形式保存在文本编辑器中。当实例 化后将经历创建、编译和销毁三个主要阶段,如图11-9所示。

生命周期钩子：

1. init

在实例开始初始化时同步调用。此时数据观测、事件和Watcher都尚未初始化。

2. created

在实例创建之后同步调用。此时实例已经结束解析选项,这意味着已建立：数据绑定、计 算属性、方法、Watcher／事件回调。但是还没有开始DOM编译,$el还不存在。

3. beforeCompile 在编译开始前调用。

4. compiled

在编译结束后调用。此时所有的指令己生效,因而数据的变化将触发DOM更新。但是不 担保$el已插入文档。

第11章组件 135

NO

vm.$mount(el) iS

plate•

i

----·---`-------·_______．．已

on

NO Compile •et' In.place as template

NO

iment?>--、

尸

;

insertd into docment for the first time

3dy ----__________----J

vm$destory()

J

图11-9 生命周期 5. ready

在编译结束和$el第一次插入文档之后调用,如在第一次attached钩子之后调用。注意, 必须是由Vue插入(如vm.$appendTo()等方法或指令更新)才触发ready钩子的。

136 Vue.js权威指南

6. attached

vm.$el插入DOM时调用。必须是由指令或实例方法(如$appendTo())插入,直接操作 vm.$el不会触发这个钩子。

7. detached

在vm.$el从DOM中删除时调用。必须是由指令或实例方法删除,直接操作vm.$el不会触 发这个钩子。

8. beforeDestroy

在开始销毁实例时调用。此时实例仍然有功能。 9. destroyed

在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑,所有的子实例也已经被 销毁。如果有离开过渡,destroyed钩子在过渡完成之后调用。

11.4 开发组件

11.4.1 基础组件

如果我们要开发更大型的网页或Web应用,Web组件化的思维是非常重要的,这也是今天 整个前端社区长久不衰的话题。那么如何开发一个组件呢？

在以往的一些小型的前端项目中,我们习惯把逻辑(script)、视图(view)和样式(style) 分开在独立的目录当中,保证三者不耦合在一起。但是随着项目越来越大,这样的结构会让开 发越来越痛苦,比如要增加或修改某个view时,就要在script和style里找到对应这个view的 逻辑和样式进行修改。

为了避免随着项目增大带来的难千维护,我们开始尝试前端组件化,把view拆分成不同的 组件(component),为单个组件编写对应的逻辑和样式：

app/components 尸picker

|尸picker.eJs |尸picker. j s

I L—picker.css

匕－button

尸button.ejs 尸button. j s

匕－button.css

第11章组件 137

这样的开发模式,不仅可以提高代码的可维护性和可重用性,还有利千团队之间的协作, 一个组件由一个人去维护,更好地实现分治。幸运的是,随着React越来越火,组件化的开发 模式也就越来越被大家接受了。

在Yue.js中,可以利用一个vue文件实现组件化,而不需要对每个组件分别建立style、script 和view。这样做的好处是使组件更加直观,而坏处是目前有些编辑器对vue的语法支待还是不 太好。每个文件就是一个组件,同时还包含了组件之间的依赖关系,整个组件从外观到结构到 特性再到依赖关系都一览无余。下面给出一个简单的button组件。代码示例如下：

<template>

<button class="didi-btn" :class="{

'disable': disabled, 'didi-btn-highlight': highlight

)" @click;"handleClick($event)"><slot></slot></button> </template>

<script>

export default { name:'dd-button',

props: {

disabled: Boolean, highlight: Boolean },

methods: {

handleClick: function (even七) {

if (this.disabled) { event.preventDefault() event.stopPropagation()

</script>

<style>

138 Vue.js权威指南

.did工－btn { display: block; padding: 0;

width: 100扣 height: 40px;

巨ne-height: 37px; border-radius: 4px; cursor: pointer; text-align: center;

ver七ical-align: middle;

touch-ac巨on: manipula巨on; background-image: none; white-space: nowrap; outline: none;

font-size: 16px;

color: #878787;

background: #fafafa; border: lpx solid #ccc; box-sizing: border-box

.didi-btn.active,.didi-btn:active { background: #ebebeb

.didi-btn.disable,.didi-btn:disabled { background: #fafafa;

border: lpx solid #e5e5e5;

color: #ccc

.didi-btn-highlight { background: #fa8919; color: #fff;

border: none

.didi-btn-highlight.active,.didi-btn-highlight:active { background: #e67e17

.didi-btn-highlight.disable,.didi-btn-highlight:disabled { background: #e5e5e5;

color: #fff;

border: none

</style>

第11章组件 139

同时,还可以在＊．vue文件中使用其他预处理器：

<style lang="stylus"> .my-component h2 color red

</style>

<template lang="jade"> div.my-component

h2 Hello from { {msg} J </template>

<scr].pt lang="babel">

//利用Babel编译ES2015 export default {

data () { return {

msg:'Hello from Babel!'

使用Webpack就可以自动将vue文件编译成正常的JavaScript代码,我们只需要在Webpack 中配置好vue-loader即可(关于Webpack,第25章将详细介绍)。代码示例如下：

module.exports= { entry: { app:'./src/main.js' ),

output: {

path: config.build.assetsRoot,

publicPath: config.build.assetsPublicPath, 丘lename:'[name].js'

},

resolve: {

extensions: ['','. j s','. vue'],

fallback: [path.join(_d江name,'.. /node_modules')], alias: {

'src': path.resolve(dirname,'.. /src'),

140 Vue.js权威指南

'assets': path. resolve(_ dirname,'.. / src/ assets'), 'components': path. resolve (dirname,'.. / src/ components')

},

resolveLoader: {

fa荨back: [path. join(—尘rname,'.. /node_modules')] },

module: { preLoaders: [

test: /\.vue$/,

loader:'eslin七',

include: projec七Root, exclude: /node modules/

},

test: /\.js$/, loader:'eslint', include: projectRoot, exclude: /node modules/

］,

loaders: [

tes七： ／＼．vue$/, loader:'vue'

},

test: /\.js$/, loader:'babel', include: projectRoot, exclude: /node modules/

},

test: /\.json$/, loader:'j son'

},

test: /\.html$/, loader:'vue-html'

第11章组件 141

},

test: /\. (pngljpe?glgiflsvg) (\?.*)?$/, loader:'url',

query: {

limit: 10000,

name: utils.asse七sPath('img/[name]. [hash:7]. [ext]')

),

test: /\. (woff2?1eotl七tflotf) (\?.*)?$/, load.er:'url',

query: {

l耳nit: 10000,

name: u七ils.asse七sPath('fonts/[name]. [hash:7]. [ext]')

},

eslint: {

formatter: require('eslint-friendly-format七er') },

vue: {

loaders: utils.cssLoaders()

像上面的组件格式,把一个组件的模板、样式、逻辑三要素整合在同一个文件中,既方便 开发,也方便复用和维护。另外,Vue.js本身支持对组件的异步加载,配合Webpack的分块打 包功能,可以极其轻松地实现组件的异步按需加载。

11.4.2 基于第三方组件开发

很多时候我们在开发一些组件时,需要引入第三方组件库,对其进行封装以满足项目 需求。下面介绍如何基千Chart.js开发。代码示例如下：

<template>

<canvas class="vchar七{{chartType}}-chart" v-el:chart-canvas :width="width":height= "height">

</canvas>

142 Vue.js权威指南

</template> <script>

import Chart from'chart.js'

module.exports= { props: {

chart Type: { type: String,

default:'巨ne' },

width: {

type: Number },

height: { type: Number },

labels: {

type: Array, validator (value) {

return value.every(label => typeof label==='string') },

default () { return [] }

},

datasets: {

type: Array, validator (value) {

return value.every(series => {

return Array.isArray(series.data) && series.data.every(val => { return typeof val==='number'

)) }) ),

coerce (val) {

return JSON.parse(JSON.stringify(val)) },

default () { re七urn [] } ),

options: {

七ype: Object,

default () { re七urn {))

第11章组件 143

},

responsive: { type: Boolean, default: null },

legend: {

coerce (val) {

if (typeof val==='boolean') { return {display: val}

),

default: null

},

methods: {

parseCommonOptions (options) { ／ ／

responsive

if (this.responsive !== null) { options.responsive= this.responsive

// legend

if (this.legend!== null) { options.legend= this.legend

return options

},

computed: { chartData () { return {

labels: this.labels, datasets: this.datasets

),

chartOptions () { let options= {)

options= this.parseCornmonOptions(options)

144 Vue.js权威指南

if (this.parseCustomOptions) {

options= this.parseCustomOptions(options)

return Object.assign(this.options, options)

},

wa七ch: { datasets: {

II don't need deep handler (val, oldVal) {

this.char七Instance.data.datasets= val this.chartinstance.update()

},

data () {

return { chartinstance: null

},

ready () {

const chartCanvas = this.$els.chartCanvas const ctx = chartCanvas. getContext {'2d') this. chart Instance = new Chart (ctx, {

type: this.chartType,

data: this.chartData, options: this.chartOptions

})

</script>

组件使用：

<template>

<div id="app">

<dd-chart : datasets="datasets" : labels=" labels" : wid七h="width" : height="height"> </dd-chart>

</div>

</template>

第11章组件 145

<script>

import ddChart from'./components/ddChart

export default { data: function (} {

return { width: 500, height: 200,

labels: ['1月','2月','3月','4月','5月','6月'］, datase七s: [ {

label.: '数据一I'

data: [110, 90, 100, 81, 106, 75, 88] },

label: '数据二',

data: [100, 80, 90, 71, 96, 65, 78]

),

label: '数据三',
data: [90, 70, 80, 61, 86, 55, 68]
),	
label:'数据四',
data: [80, 60, 70, 51, 76, 45, 58]
},	
label: '数据五',
data: (70, 50, 60, 41, 66, 35, 48]
},	
label: '数据六',
data: [60, 40, 50, 31, 56, 25, 38]
},	
label: '数据七',

data: [50, 30, 40, 21, 46, 15, 28]

} ］

},

146 Vue.js权威指南

componen七s: { ddChart

</script>

效果如图11-10所示。

110 100 90 80 70 60 50 40 30 20 10

1月

2月

3月

4月

5月

6月

图11-10 chart

11.5 常见问题解析

1. camelCase & kebab-case

HTML标签中的属性名不区分大小写。设置prop名字为camel Case形式的时候,需要转换 为kebab-case形式(短横线隔开)在HTML中使用。代码示例如下：

Vue. component ('child', {

//这里可以是camel Case形式 props: ['myMessage'],

template:'<span>{ { myMessage } }</span>' }}

<'－－对应在HTML中必须是短横线分隔－－>

<child my-message="hello!"></ch工ld>

2.字面量语法＆动态语法

初学者常犯的一个错误是使用字面量语法传递数值。代码示例如下：

<!"－－传递了一个字符串"1" -->

<comp some-prop="l"></comp>

第11章组件 147

因为它是一个字面prop,它的值是字符串"l ",而不是以实际的数字传下去。如果想传递一 个真实的JavaScript类型的数字,则需要使用动态语法,从而让它的值被当作JavaScript表达式 计算。代码示例如下：

<!"－－传递实际的数字 －－>

<comp :some-prop="l"></comp>

3.组件选项问题

传入Vue构造器的多数选项也可以用在Vue.extend()中,不过有两个特例：data和elo试想, 如果简单地把一个对象作为data选项传给Vue.extend(),代码示例如下：

var data = {· a: 1 }

var MyComponent = Vue.ex七end({ da七a: data

这样做的问题是MyComponent所有的实例将共享同一个data对象!"这基本不是我们想要 的,因此应当使用一个函数作为data选项,让这个函数返回一个新对象。代码示例如下：

var MyCornponent = Vue.extend({ data: function () {

return { a: 1)

})

4.模板解析

Vue的模板是DOM模板,使用浏览器原生的解析器而不是自己实现一个。相比字符串模 板,DOM模板有一些好处,但是也有问题,它必须是有效的HTML片段。一些HTML元素对 什么元素可以放在它里面有限制。常见的限制有：

0 a不能包含其他的交互元素(如按钮、链接)。 0 ul和ol只能直接包含lio

0 select只能包含option和optgroup。

0 table只能直接包含thead、tbody、tfoot、tr、caption、col、colgroup。 0 tr只能直接包含th和td。

148 Vue.js权威指南

在实际应用中,这些限制会导致意外的结果。尽管在简单的情况下它可能可以工作,但是 我们不能依赖自定义组件在浏览器验证之前的展开结果。例如<my-select><option>... </ option> </my-select>不是有效的模板,即使my-select组件最终展开为<select>... </select>。

另一个结果是,自定义标签(包括自定义元素和特殊标签,如<component>、<template>、 <pa巾al>)不能用在ul、select、table等对内部元素有限制的标签内。放在这些元素内部的自定 义标签将被提到元素的外面,因而渲染不正确。

自定义元素应当使用is特性,代码示例如下：

<table>

<tr is="my-component"><／七r> </table>

<template>不能用在<table>内,这时应使用<tbody>, <table>可以有多个<tbody>。代码示例 如下：

<table>

<tbody v-for="item in items"> <tr>Even row</tr>

<tr>Odd row</tr>

</tbody>

</table>

5.动态组件与异步组件结合

上面的章节中分别讲述了动态组件和异步组件,这里简单展示一下它们如何结合且可以像 正常组件一样,通过props传递数据(其中template用了两种形式展现,只是为了表达它有多 种展现方式,如何使用需要针对业务场景来区分,此处只是为了演示)。代码示例如下：

<body id="example">

<input type="radio" id="one" value="fast" v-model="currentView"> <label for="one">fast</label>

<br>

<input type="radio" id="two" value="bus" v-model="currentView"> <label for="two">bus</label>

<br>

<inpu七type="radio" id="two" value="business" v-model="currentView"> <label for="two">business</label>

<template id="business">

第11章组件 149

<div> { { msg})滴滴专车</div> </template>

<template id="fast">

<div>{ {msg})滴滴快车</div> </template>

<component :is="currentView" :msg="hello"></component> </body>

<script>

var bus = Vue. component ('bus', function (resolve, reject) { se七Timeout(function () {

resolve ({

props: ['msg'],

template: '<div @click="show">{ {msg})滴滴巴士</div>', data: function () { return {} },

methods: {

show: function() { alert("haha~")

})

l, 100);

})

var business= Vue.extend({ //声明props

props : ['msg'], template:'#business', replace: true

})

var fast= Vue.extend({ //声明props

props: ['rnsg'], template:'#fast', replace: true

))

//创建根实例

new Vue ({

150 Vue.js权威指南

el:'#example', data: {

currentView:'fast', hello:'hi'

},

components: { fast: fast, bus: bus,

business: business

))

</scrip七>

6.如何解决数据层级结构太深的问题

在开发业务时,经常会出现异步获取数据的情况,有时候数据层次比较深。代码示例如下：

<span class="airport" v-text="ticketinfo.flight.frornSegrnents[ticketinfo.flight.frornSegrnents.length 1].depAirportZh">

</span>

我们可以使用vm.$set手动定义一层数据,代码示例如下：

vrn. $set ("depAirportZh", ticketinfo. flight. frornSegrnents [ticketinfo. flight. frornSegrnent s.length - 1].depAirportZh)

现在我们来看一下$set方法。 参数：

{String} keypath {*} value

用法：

设置Vue实例的属性值。在多数情况下应当使用普通对象语法,如vm.a.b = 123。这个方

法只用千下面情况：

0使用keypath动态地设置属性。 O设置不存在的属性。

如果keypath不存在,将递归地创建并建立追踪。如果用它创建一个顶级属性,实例将被

第11章组件 151

强制进入"digest循环",在此过程中重新计算所有的Watcher。代码示例如下：

var vm = new Vue ({ data: {

a: {

b: 1

})

// keypath存在 vm.$set('a.b', 2) vm.a.b II-> 2

// keypath不存在 vrn.$set ('c', 3) vm.c II-> 3

7.后端数据交互

如果配合vue-resource,代码示例如下：

new Vue (( el:'#app', data: { todos: [ l },

ere a ted: func巨on() { this.$http

.get ('我们的代码体')

. then ((data) => { this.todos = data;

})

}) ;

如果配合jQuery的AJAX,代码示例如下：

new Vue (( el:'#app',

152 Vue.js权威指南

da七a: { todos: [ l },

ere a ted: function () { $.get('我们的API')

. done ((da七a) => { this.todos = data;

,' ．．

.' ．． ．

8. data中没有定义计算属性,它是如何被使用的 代码示例如下：

<div id="example">

a={{ a}}, b={{ b }} </div>

var vm = new Vue({ el:'#example',

data: { a: 1

),

computed: {

b: function () {

return七his.a+ 1

})

对千上面计算属性b是怎么被使用的,源码定义如下：

< !" －－源码目录：src\instance\internal\sta七e.js 207行－－> Vue.pro七otype._initComputed = func巨on () {

var computed=七his.$options.computed

if (computed) {

for (var key in computed) { var userDef = computed[key] var def= {

第11章组件 153

enumerable: true, configurable: true

辽(typeof userDef ==='function') {

def.get= makeComputedGe七ter(userDef, this) def.set= noop

} else {

def.get= userDef.get

? userDef.cache 1== false

? makeComputedGetter(userDef.get, this) : bind(userDef.get, this)

: noop

def.set= userDef.set

? bind(userDef.set, this) : noop

Object.defineProperty(this, key, def)

这里并没有把计算数据放到$data里面去,而是通过Object.defineProperty(this, key, def)直接 定义到了实例上。

第12章

表单校验

表单校验在Web应用中是很重要的一环,在Vue.js应用中,我们可以使用vue-validator 2.1.3 插件对表单进行校验,以下讲解均基千vue-validator 2.1.3版本,后面介绍将不加版本号了。

12.1 安装

vue-validator提供了npm、手动编译等安装方式,可以根据业务需要选择其中一种方式进行 安装。下面介绍npm和手动编译两种安装方式的安装方法及适合场景。

1. npm

当业务代码使用Webpack等支持CommonJS规范的模块化打包器来构建时,可以使用npm 包的方式来安装：

$ npm install vue-validator

因为vue-validator是Yue.js的一个插件,所以vue-validator需要使用Yue. use(Pl ugi nContructor) (Vue.js用此方法来注册插件)注册到Vue对象上,在vue-validator内部会检测window.Yue对 象是否存在,如果存在则会自动调用Vue.use()方法;否则需要使用者手动调用 Yue. use(Vue Validator)来确保校验插件注册到Vue中。在Webpack等支待CommonJS规范的环境 中,Vue对象并不会暴露到全局window对象中,而是会通过module.exports形式输出,因此需 要使用者手动注册。代码示例如下：

var Vue = require ('vue') ;

var VueValidator = require ('vue-valida七or'); //安装vue-validator

Vue.use(VueValidator);

第12章表单校验 155

2.手动编译

当想尝试一些Vue中并未发布的新特性时,可以直接clone源码,手动构建来实现。由千 在未正式发布之前,有些特性可能会被移除,所以不建议在生产环境中使用手动编译方式安装。 执行以下命令：

$ git clone https://github.com/vuejs/vue-validator.git node_modules/vue-validator $ cd node_modules/vue-validator

$ npm install

$ npm run build

12.2 基本使用

为了快速入门,我们来看一个完整的例子。代码示例如下：

new Vue({ el:'#app' ))

<div id="app">

<validator name="validation"> <form novalidate>

<div class="username-field">

<label for="username">username:</label>

<input id="username" type="tex七"v-validate:username="['required']"> </div>

<div class="comment-field">

<label for="comment">comment:</label>

<input id="comment" type="text" v-validate:comment="{ maxlength: 256)"> </div>

<div class="errors">

<p v-if="$validation.username.required">Required your name.</p>

<p v-if="$validation.comment.maxlength">Your comment is too long.</p> </div>

<input type="submit" value="send" v-if="$validation.valid"> </form>

</validator>

</div>

我们可以看到要校验的表单元素包裹在validator自定义元素指令中,而在要校验的表单控

156 Vue.js权威指南

件元素的v-validate属性上绑定相应的校验规则。验证结果会保存在组件实例的$validation属性 下,$validation是由validator元素的name属性和$前缀组成的。

注：validator元素的name属性请不要使用Vue.js中内置的属性名称,如$event。

12.3 验证结果结构

在12.2节中,我们了解到vue-validator将验证结果存储在组件实例上以validator元素name 属性值及$前缀为键名的属性下。下面我们来看一下验证结果的结构。代码示例如下：

//表单整体验证结果

valid: true, invalid: false, 七ouched: false,· unde丘ned: true, dirty: false,

pris七ine: true, modified: false, errors: [ (

field:'fieldl', validator:'required', message:'required fieldl'

),... {

field:'fieldX', validator:'customValidator', message:'invalid fieldX'

} ],

//字段一验证结果 fieldl: {

required: false,

// vue-validator内置校验器,表示是否已填写,true表示校验通过,false表示校验失败 ema辽：true, I I自定义校验器

url: 'invalid url format', I I自定义校验器

customValidatorl: false, //自定义校验器 //校验状态屈性

valid: false, invalid: true, touched: false, undefined: true, dirty: false,

第12章表单校验 157

pristine: true, modified: false, errors: [ {

validator:'required', message:'required fieldl'

} ］

},

//字段x验证结果 丘eldX: {

min: false, //内贺校验器

customValidator: true,

//校验状态屈性

valid: false, invalid: true, touched: true, undefined: false, dirty: true, pristine: false, modified: true, errors: [ {

validator:'customValidator', message:'invalid fieldX' }]

从以上校验结果的结构中我们可以了解到,校验结果由两部分组成,即表单整体校验结果 和单个字段校验结果。

单个字段校验结果包括以下校验属性：

0 Valid—字段校验是否通过,通过返回true,失败返回false。

0 invalid—valid取反。

0 touched—校验字段所在元素获得过焦点时返回true,否则返回false。

0 untouched——touched取反。

0 modified-—当元素值与初始值不同时返回true,否则返回false。

158 Vue.js权威指南

0 dirty—字段值改变过至少一次返回true,否则返回false。 0 pristine - dirty取反。

0 errors—如果校验没通过,则返回错误字段信息数组,否则返回undefined。

表单整体校验结果包括以下校验属性：

0 valid—一所有字段校验是否通过,通过返回true,失败返回false。

0 invalid—valid取反。

0 touched——只要有一个校验字段所在元素获得过焦点就返回true,否则返回false。

0 untouched—touched取反。

0 modified 只要有一个字段对应元素值与初始值不同就返回true,否则返回false。

0 dirty 只要有一个校验字段对应元素值改变过至少一次就返回true,否则返回false。

0 pristine - dirty取反。

0 errors——如果整体校验没通过,则返回错误字段信息数组,否则返回undefined。

12.4 验证器语法

v-validate指令语法如下：

v-validate [: f).eld]="array 1).teral I object 1).teral I b).nd).ng"

下面我们来了解一下field的含义,以及v-validate校验规则的格式。

12.4.1 校验字段名field

field用来标识校验字段,之后可以用该字段来引用校验结果。

在vue-validator版本小于等于2.0-alpha时,校验时依赖v-model指令。代码示例如下：

<1-- ~1.4.4版本校验语法－－> <form novalidate>

<input type="text" v-model="comment" v-validate="minLength: 16, maxLength: 128"> <div>

第12章表单校验 159

<span v-show="validation.comment.minLength">Your comment is too short.</span> <span v-show="validation.comment.maxLength">Your comment is too long.</span> </div>

<input type="submit" value="send" v-if="valid"> </form>

在2.0-alpha及以后版本中,使用v-validate指令进行校验。代码示例如下： <!-- 2.0-alpha及以后版本校验语法－－>

<validator name="validation">

<form novalidate>

<input type="七ext" v-validate:comment="(minlength: 16, maxlength: 128 }"> <div>

<span v-show="$validation.comment.minlength">Your comment is七oo short.</span> <span v-show="$validation.comment.maxlength">Your comment is too long.</span> </div>

<input type="submit" value="send" v-if="valid"> </form>

</validator>

和指令命名规则一样,在HTML中我们可以用连字符(-)来命名field,如以下例子中的 user-name,然后通过驼峰式命名法来引用它。代码示例如下：

<validator name="validation"> <form novalidate>

釭nput type="text" v-validate:user-name="{ minlength: 16 }"> <div>

<span v-if="$validation.userName.minlength">Your user name is too short.</span> </div>

</form>

</validator>

当需要动态绑定校验字段的名称时,我们可以在要校验的元素上使用field属性。代码示例 如下：

<div id="app">

<validator name="validation">

<form novalidate>

<p class="validate-field" v-for="field in fields"> <label :for="field.id">{{field.label))</label>

<input type="text" :id="field.id" :placeholder="field.placeholder" field="{{field. name))" v-validate="field.validate">

</p>

160 Vue.js权威指南

<pre> { { $validation I j son } } </pre> </form>

</validator>

</div>

new Vue ({

el:'#app',

data: {

丘elds: [ {

id:'username',

label:'username',

name:'username',

placeholder:'input your username', validate: { required: true, max length: 16 }

),(

id:'message',

label:'message',

name:'message',

placeholder:'input your message', validate: { required: true, minlength: 8 }

) ］

})

12.4.2 校验规则定义

v-validate指令用来定义校验规则,其值可以是数组字面最、对象字面量、组件实例数据属 性名。

1.数组字面量

当校验器不需要额外参数时,我们可以使用数组字面量的形式。如required校验器,只要 出现就代表该校验器所在元素是必填项。代码示例如下：

<valida七or name="validation"> <form novalidate>

Zip: <input type="text" v-validate:zip="['required']"><br /> <div>

<span v-if="$validation.zip.required">Zip code is required.</span>

</div>

</form>

</validator>

第12章表单校验 161

2.对象字面量

对象字面量语法适合需要额外参数的校验器。如限制输入长度的校验器minlength,需要说 明最小长度限制是多少。代码示例如下：

<validator name="validation"> <form novalidate>

ID: <input type="text" v-validate:id="{ required: true, minlength: 3, maxlength: 16 }"><br />

<div>

<span v-if="$validat工on.id.required">ID is required</span>

<span v江f="$validation.id.minlength">Your ID is too short.</span> <span v-if="$validation.id.maxlength">Your ID is too long.</span>

</div> </form> </validator>

我们还可以使用对象字面量语法通过rule字段来自定义验证规则。代码示例如下：

<validator name="validation"> <form novalidate>

ID: <input type="text" v-validate: id=" { minlength: { rule: 3 }, max length: { rule: 16 l }"><br />

<div>

<span v-if="$validation.id.minlength">Your ID is too short.</span> <span v-if="$validation.id.maxlength">Your ID is too long.</span> </div>

</form>

</validator>

3.实例数据属性

v-validate的值可以是组件实例的数据属性,这样可以用来动态绑定校验规则。代码示例 如下：

new Vue ({ el:'#app',

data: {

rules: { minlength: 3, maxlength: 16

162 Vue.js权威指南

))

<div id="app">

<valida七or name="validation"> <form novalidate>

ID: <input type="text" v-validate:id="rules"><br /> <div>

<span v-if="$validation.id.minlength">Your ID is too short.</span> <span v-if="$validation.id.maxlength">Your ID is too long.</span> </div>

</form>

</validator>

</div>

4.与terminal指令同时使用

当与v-if、v-for等terminal指令同时使用时,需要把可验证的目标元素包裹在<template>之 类的不可见标签内。因为v-validate指令不能与terminal指令同时使用,所以包裹在了div元素 中。代码示例如下：

new Vue ({ el:'tlapp',

da七a: { enable: true

))

<div id="app">

<validator name="validation"> <form novalidate>

<div class="username">

<label for="username">username:</label>

<input id="username" type="tex七" @valid="this.enable = true" @invalid="this.enable = false" v-validate:username="['required']">

</div>

<div v-if="enable" class="password"> <label for="password">password:</label>

<input id="password" type="password" v-validate:password="{

第12章表单校验 163

required: { rule: true }, rninlength: { rule: 8 } } "/>

<div>

</form>

</validator>

</div>

12.5 内萱验证规则

为了提高开发效率,vue-validator为我们提供了一些常用的内置的验证规则,如图12-1所示。

／

c:?,i required 轮入值不粽为空

----奇三三一轮入值不能大于max衰示内值 图12-1 内置验证规则

12.5.1 required

必填校验器,该校验器用来校验字段值是否不为空。 可以使用该校验器的元素有：

0 input[type="text"] 0 input[type="radio"]

0 input[type="checkbox"] 0 input[type=11number11]

164 Vue.js权威指南

0 input[type="password"] 0 input[type="email"]

0 input[type="tel"]

0 input[type="url"] 0 select

0 textarea

源码定义如下：

<!"－－源码目录：src/validators.js --> export function required (val) { if (Array. isArray (val)) {

if (val. length ! == 0) {

let valid= true

for (let i = 0, 1 = val. length; i < l; i++) { valid= required(val[i])

if (!valid) {

break

return valid } else ( return false

} else江(七ypeof val ==='number'I I typeof val ==='func巨on') { return true

} else if (typeof val ==='boolean') { return val

) else江(typeof val ==='string') { return val.length> 0

} else if (val ! == null && typeof val ==='object') { return Object.keys(val).length> 0

) else if (val === null I I val === undefined) { return false

第12章表单校验 165

12.5.2 pattern

正则匹配校验器,校验元素值是否匹配pattern所表示的正则表达式。 可以使用该校验器的元素有：

0 input[type="text"]

0 input[type="number"] 0 input[type="password"] 0 input[type="email"]

0 input[type="tel"] 0 input[type="url"]

0 textarea

源码定义如下：

< !" －－源码目录：src/validators.js --> export function pattern (val, pat) {

if (typeof pat !=='s七ring') { return false }

let ma七ch= pat.match(new RegExp('~/(.*?)/([gimy]*)$')) if (!match) { return false }

return new RegExp(match[l], match[2]).test(val)

12.5.3 minlength

最小长度校验器,校验元素的长度是否大千min length。 可以使用该校验器的元素有：

0 input[type="text"]

0 input[type="checkbox"] 0 input[type="number"]

166 Vue.js权威指南

0 input[type="password"] 0 input[type="email"]

0 input[type="tel"]

0 input[type="url"]

0 select

0 textarea

源码定义如下：

< !" －－源码目录：src/validators.js --> export function minlength (val, min) { if (typeof val ==='string') {

return isinteger(min, 10) && val.length>= parseint(m江,10) } else if (Array.isArray(val)) {

return val.length>= parseint(min, 10) } else {

return false

12.5.4 maxlength

最大长度校验器,校验元素的长度是否小千max length。 可以使用该校验器的元素有：

0 input[type="text"]
0 input[type="checkbox"]
0 input[type="number"]
0 input[type="password"]
0 input[type="email"]
0 input[type="tel"]
第12章表单校验 167

0 input[type="url"] 0 select

0 textarea

源码定义如下：

<'－－源码目录：src/validators.js -->

export func巨on maxlength (val, max) { if (typeof val ==='string') {

return isinteger(max, 10) && val.length<= parseint(max, 10) } else if ·(Array. isArray (val)) {

return val. length <= parseint (max, 10) } else {

return false

12.5.5 min

最小长度校验器,校验元素的值是否大千min的值。 可以使用该校验器的元素有：

0 input[type="text"]

0 input[type="number"] 0 textarea

源码定义如下：

<!"－－源码目录：src/validators.js --> export function min (val, arg) (

return !isNaN(+(val)) && !isNaN(+(arg)) && (+(val) >= +(arg))

12.5.6 max

最大长度校验器,校验元素的值是否小千max的值。

168 Vue.js权威指南

可以使用该校验器的元素有：

0 input[type="text"]

0 input[type="nurnber"] 0 textarea

源码定义如下：

< !" －－源码目录：src/validators.js --> export function max (val, arg) {

return !isNaN(+(val)) && 1isNaN(+(arg)) && (+(val) <= +(arg))

12.6 与v-model同时使用

vue-validator会自动校验通过v-model动态设置的值。代码示例如下：

<div id="app">

<validator name="validationl"> <form novalidate>

message: <input type="tex七"v-model="msg" v-validate: message=" { required: true, min length: 8 } "><br />

<div>

<p v-if="$validationl.message.required">Required your message.</p> <p v-if="$validationl.message.minlength">Too short message.</p> </div>

</form>

</validator>

</div>

var vm = new Vue({ el:'#app',

data: {

msg:''

))

setT工meout (function () { vm.msg ='hello world! 1' l, 2000 I

第12章表单校验 169

12.7 重宣校验结果

我们可以通过在Vue组件实例上调用$reset Validation()力法来动态重置校验结果。代码示例 如下：

<div id="app">

<validator name="validationl"> <form novalidate>

<div class="username-field">

<label for="username">username:</label>

<input id="username" type="text" v-validate:username="['required']"> </div>

<div class="comment-field">

<label for="comment">comment:</label>

<input id="comment" type="tex七"v-validate:comment="{ maxlength: 256 }"> </div>

<div class="errors">

<p V江f="$valida巨onl.username.required">Required your name.</p>

<p v-if="$validationl.comment.maxlength">Your comment is too long.</p> </div>

<input type="submit" value="send" v-if="$validationl.valid"> <button type="button" @click="onReset">Reset Validation</button>

</form>

<pre>{ { $validationl I json } }</pre> </validator>

</div>

new Vue ({

el:'#app',

methods: {

onReset: function () { this. $resetValidation ()

))

12.8 表单元素

由千表单元素checkbox、radio、select等的特殊性,我们有必要单独介绍一下vue-validator

170 Vue.js权威指南

在这些表单元素上的使用。

复选框checkbox:

<div id="app">

<validator name="validationl"> <form novalidate> <hl>Survey</hl>

<fieldset>

<legend>Which do you like fruit ?</legend>

<input id="apple" type="checkbox" value="apple" v-validate:fruits="{ required: { rule: true, message: requiredErrorMsg),

min length: { rule: 1, message: minlengthErrorMsg),

maxlength: { rule: 2, message: maxlengthErrorMsg)

) ">

<label for="apple">Apple</label>

<input id="orange" type="checkbox" value="orange" v-valida七e:fruits> <label for="orange">Orage</label>

<input id="grape" type="checkbox" value="grape" v-validate:fruits> <label for="grape">Grape</label>

<input id="banana" type="checkbox" value="banana" v-validate:fruits> <label for="banana">Banana</label>

<ul class="errors">

<li v-for="msg in $valida巨onl.fruits.errors"> <p>{ {msg.message))<Ip>

</li>

</ul>

</fieldset>

</form>

</validator>

</div>

new Vue ({

el:'#app',

computed: {

requiredErrorMsg: function () { return'Required fruit ! !'

),

minlengthErrorMsg: function () {

return'Please chose at least 1 frui七I I' ),

第12章表单校验 171

maxlengthErrorMsg: function () { return'Please chose at most 2 fruits ! !'

})

单选钮radio

<div id="app">

<validator name="validationl"> <form novalidate> <hl>Survey</hl>

<fieldset>

<legend>Which do you like fruit ?</ legend>

<input id="apple"七ype="radio" name="fruit" value="apple" v-validate:fruits="{

required: { rule: true, message: requiredErrorMsg } }">

<label for="apple">Apple</label>

<input id="orange" type="radio" name="fruit" value="orange" v-validate:fruits> <label for="orange">Orage</label>

<input id="grape" type="radio" name="fruit" value="grape" v-validate:fruits> <label for="grape">Grape</label>

<input id="banana" type="radio" name="fruit" value="banana" v-validate:fruits> <label for="banana">Banana</label>

<ul class="errors">

<li v-for="msg in $validationl.frui七s.errors"> <p> { {msg. message} } </p>

</li>

</ul>

</fieldset>

</form>

</validator>

</div>

new Vue ({

el:'#app',

computed: {

requiredErrorMsg: function () { return'Required fruit ! !'

))

172 Vue.js权威指南

下拉列表select:

<div id="app">

<validator name="validationl">

<form novalidate>

<select v-validate:lang="{ required: true)">

<option value="">----- select your favorite programming language -----</option> <option value="javascript">JavaScript</option>

<option value="ruby">Ruby</option>

<option value="python">Python</option>

<option value="perl">Perl</op七ion>

<option value="lua">Lua</op巨on>

<option value="go">Go</option>

<option value="rus七">Rus七</op巨on>

<option value="elix立">Elix立</option> <option value="c">C</option>

<option value="none">Not listed here</option> </select>

<div class="errors">

<p v-if=" $validationl. lang. required">Required 1 1 </p> </div>

</form>

</validator>

</div>

new Vue ({ el:'#app'})

12.9 各校验状态对应的class

为了提升用户体验,有时候我们需要基千校验结果来对表单元素应用不同的样式。

vue-validator会基于校验结果自动在元素上添加一些校验状态的class。代码示例如下：

<input id="username" type="text" v-validate:username="{ required: { rule: true, message:'required you name ! 1'} } ">

在页面初始化后,以上代码的输出结果类似千：

<input id="username" type="text" class="invalid untouched pris七ine">

第12章表单校验 173

各校验状态对应的class如表12-1所示。

表12-1 各校验状态对应的class

校验状态	对应class(默认)
valid	valid
mvahd	mvahd
touched	touched
untouched	untouched
pnstme	pnstme
dirty	dirty
modified	modified
12.9.1 自定义校验状态class

有时候我们可能需要使用自定义的状态class,这时我们可以通过classes属性来自定义各状 态对应的class。代码示例如下：

<valida七or name="validationl"

:classes="{ touched:'touched-validator', dirty:'dirty-validator'}"> <label for="username">username:</label>

<input id="username"

type="text"

: classes=" { valid:'valid-username', invalid:'invalid-username'} "

v-validate: username=" { required: { rule: true, message:'required you name ! !')) "> </validator>

注：classes属性只能在validator元素或应用了v-validate的元素上使用有效。

12.9.2 在其他元素上使用校验状态class

一般校验状态class会被添加到v-validate指令的元素上,有时候我们需要将class添加到 v-validate指令所在元素的包裹元素上,这时我们可以在相应的包裹元素上使用v-validate-class 指令。代码示例如下：

<validator name="validationl"

:classes="{ touched:'touched-validator', dirty:'dirty-validator')"> <div v-validate-class class="username">

<label for="username">username:</label>

174 Vue.js权威指南

<input id="username" type="text"

:classes=" { valid:'valid-username', invalid:'invalid-username'} "

v-valida七e: username=" { required: { rule: true, message:'required you name ! !'} } ">

</div>

</validator>

在页面初始化后,以上代码的输出结果为：

<div class="username invalid-username untouched pristine"> <label for="username">username:</label>

<input id="username" type="text">

</div>

12.10 分组校验

vue-validator支持分组校验。如输入密码时,我们可以将第一次输入密码与再次输入密码确 认放入同一个校验组内,只有两次校验都通过了,该组校验才算通过。代码示例如下：

<validator name="validationl" :groups="['passwordGroup']">

username: <input type="text" v-validate:username="['required']"><br>

password:红nput type="password" group="passwordGroup" v-validate :password=" { minlength: 8, required: true }"/><br>

confirm password: <input type="password" group="passwordGroup" v-validate: password­confirm="{ minlength: 8, required: true }"/><br>

<span v-if="$validationl.username.invalid">Invalid username!</span><br>

<span v-if="$validationl.passwordGroup.invalid">Invalid password input!</span> </validator>

以上代码只有当password规则和password-confirm规则都校验通过后,passwordGroup.valid 才会返回true。

12.11 错误信患

在校验失败时,我们需要获得相应的错误提示信息,错误信息可以直接存储在校验规则中。

代码示例如下：

<validator name="valida七ionl"> <div class="username">

第12章表单校验 175

<label for="username">username:</label>

<input id="username" type="text" v-validate:username="{ required: { rule: true, message:'required you name 1 !'} } ">

<span v-if="$validationl.username.required"> {{ $validationl.username.required }} </span>

</div>

<div class="password">

<label for="password">password:</label>

<input id="password"七ype="password" v-validate:password="{

required: { rule:七rue, message:'required you password ! !'}, minlength: { rule: 8, message:'your password short too ! 1'}

} "/>

<span v-if="$validationl.password.required"> {{ $validationl.password.required }} </span>

<span v-if="$validationl.password.minleng七h"> {{ $validationl.password.minlength }} </span>

</div>

</validator>

1.输出所有错误信息

如果需要输出当前所有校验失败的错误信息,则可以通过v-for指令来循环errors数组。代 码示例如下：

<valida七or name="validationl"> <div class="username">

<label for="username">username:</label>

<input id="username" type="text" v-validate:username="{ required: { rule: true, message:'required you name ! !'} } ">

</div>

<div class="password">

<label for="password">password:</label>

<input id="password" type="password" v-validate:password="{ required: { rule: true, message:'required you password ! !'}, minlength: { rule: 8, message:'your password short too ! !'}

} "/>

176 Vue.js权威指南

</div>

<div class="errors">

<ul>

<li v-for="error in $validationl.errors"> <p> { {error. field} } : { {error. message}} </p> </li>

</ul>

</div>

</validator>

2.输出单个校验错误信息

我们可以输出单个校验规则或者单个分组的错误信息。代码示例如下：

<div id="app">

<va巨dator :groups="['profile','password']" name="va巨dationl"> <div class="username">

<label for="username">username:</label>

<input id="username" type="text" group="profile" v-va巨date:username="{ required: { rule: true, message:'required you name ! !'}

} ">

</div>

<div class="url">

<label for="url">url:</label>

釭nput id="url" type="text" group="profile" v-validate:url="{ required: { rule:七rue, message:'required you name ! 1'}, url: { rule: true, message:'invalid url format'}

} ">

<Id攻>

<div class="old">

<label for="old">old password:</label>

豆nput id="old" type="password" group="password" v-validate:old="{ required: { rule: true, message:'required you old password ! !'}, minlength: { rule: 8, message:'your old password short七00 ! !'}

} "/>

</div>

<div class="new">

<label for="new">new password:</label>

<input id="new" type="password" group="password" v-valida七e:new="{ required: { rule: true, message:'required you new password ! 1'}, minlength: { rule: 8, message:'your new password short too ! !'}

第12章表单校验 177

} "/> </div>

<div class="confirm">

<label for="confirm">confirm password:</label>

<input id="confirm" type="password" group="password" v-validate:confirm="{ required: { rule: true, message:'required you confirm password 1 1'}, min length: { rule: 8, message:'your confirm password short too ! !'}

} "/>

</div>

<div class="errors">

<validator-errors group="profile" :validation="$validationl"> </vali'da七or-errors>

</div>

</validator>

</div>

Vue. validator ('url', function (val) {

return /A(http\:\/\/lhttps\:\/\/) (.{4,))$/.test(val) ))

new Vue({ el:'#app'))

12.11.1 错误信息输出组件

在上节示例中,我们使用v-for指令来遍历输出错误信息。在vue-validator中,可以使用 validator-errors组件来更便捷地输出错误信息。代码示例如下：

<validator name="validat]_onl"> <div class="username">

<label for="username">username:</label>

<]_nput id="username" type="text" v-validate:username="{

requ]_red: { rule: true, message:'requ]_red you name ! !'} } ">

</div>

<div class="password">

<label for="password">password:</label>

<]_nput]_d="password" type="password" v-val]_date:password="{ requ]_red: { rule: true, message:'required you password 1 !'}, m]_nlength: { rule: 8, message:'your password short too ! !'}

} "/> </div>

178 Vue.js权威指南

<div class="errors">

<validator-errors :validation="$validationl"></validator-errors>

</div>

</validator>

在页面初始化后,以上代码的输出结果类似于：

<div class="username">

<label for="username">username:</label> <input id="username" type="text"> </div>

<div class="password">

<label for="password">password:</label> <input id="password" type="password"> </div>

<div class="errors"> <div>

<p>password: your password short too ! !</p> </div>

<div>

<p>password: required you password! !</p> </div>

<div>

<p>usernarne: required you name ! !</p> </div>

</div>

如果不喜欢默认的错误信息模板,我们还可以自定义错误信息模板,validator-errors提供了 Component模板、Partial模板两种定义方式。

1. Component模板

<div id="app">

<validator name="valida巨onl"> <div class="username">

<label for="username">username:</label>

豆nput id="username" type="七ext" v-validate:username="{

required: { rule:七rue, message:'required you name ! !'} } ">

</div>

<div class="password">

第12章表单校验 179

<label for="password">password:</label>

<].nput].d="password" type="password" v-val].date:password="{ requ].red: { rule: true, message:'requ].red you password!!'}, m].nlength: { rule: 8, message:'your password short too ! !'}

} "/>

</div>

<div class="errors">

<validator-errors :component="'custom-error'" :validation="$val].dationl"> </validator-errors>

</div>

</val].dator>

</d].v>

Vue. component ('custom-error', {

props: ['f].eld','val].dator','message'],

template:'<p class="error- { { field})一{ {val].dator}} "> {{message}} </p>' })

new Vue ({ el:'#app'))

2. Partial模板

<div id="app">

<validator name="validationl"> <div class="username">

<label for="username">username:</label>

<input id="username" type="text" v-validate:username="{ required: { rule: true, message:'required you name ! !'} } ">

</div>

<div class="password">

<label for="password">password:</label>

<input id="password" type="password" v-validate:password="{ required: { rule: true, message:'required you password ! !'}, minlength: { rule: 8, message:'your password short too ! !'} )"/>

</div>

<div class="errors">

<validator-errors partial="myErrorTemplate" :validation="$validationl"> </validator-errors>

</div>

</validator>

</div>

180 Vue.js权威指南

Vue. partial ('myErrorTemplate','<p> { {field} } : { {validator}} : { {message}} </p>') new Vue ({ el:'#app'})

12.11.2 动态设置错误信息

在服务端验证失败时,我们可以用组件实例方法$setValidationErrors来动态设置错误信息。

代码示例如下：

<div id="app">

<validator name="validation"> <div class="username">

<label for="username">username:</label>

<input id="username" type="text" v-model="username" v-validate:username="{ required: { rule: true, message:'required you name ! !'}

} ">

</div>

<div class="old">

<label for="old">old password:</label>

<input id="old" type="password" v-model="passowrd.old" v-validate:old="{ required: { rule: true, message:'required you old password ! !'}

} "/>

</div>

<div class="new">

<label for="new">new password:</label>

勺nput id="new" type="password" v-model="password.new" v-validate:new="( required: (rule: true, message:'required you new password ! !'l,

min length: { rule: 8, message:'your new password short七00 ! !')

) "/>

</div>

<div class="confirm">

<label for="confirm">confirm password:</label>

釭nput id="confirm" type="password" v-validate:confirm="(

required: (rule: true, message:'required you confirm password ! !'), confirm: (rule: passowd.new, message:'your confirm password incorrect 1 !'l l "/>

</div>

<div class="errors">

<validator-errors :validation="$validation"></validator-errors> </div>

第12章表单校验 181

<but七on type="button" v-if="$valida巨on.val过"@click.prevent="onSubmit">update</button> </validator>

</div>

new Vue ({

el:'#app',

data: (

id: 1,

username: password: (

old:'' new:

),

validators: (

confirm: function (val, target) ( return val=== target

),

methods: {

onSubm江：function () { var self= this

var resource = this. $resource ('/user I: id') resource. save ({ id: this. id J, {

username: this.username, password: this.new

), function (data, stat, req) {

//成功回调

I I...

)).error(function (data, s七at, req) { // handle server error self.$setValidationErrors([

{ field: data.field, message: data.message } ］)

))

,

．' ． ．

182 Vue.js权威指南

12.12 事件

在校验状态发生变化时,vue-validator会触发相应的事件,我们可以通过Vue.js中的事件注 册方法来注册相关事件。vue-validator会触发单个字段校验事件和整个表单校验事件。

12.12.1 单个字段校验事件

对千每个v-validate所在元素,我们可以监听以下事件： 0 valid-—当字段验证结果变为有效时触发。

0 invalid—当字段验证结果变为无效时触发。

0 touched-—当字段失去焦点时触发。

0 dirty—当字段值首次变化时触发。

0 modified—当字段值与初始值不同时或变回初始值时触发。

<div id="app">

<validator name="validationl"> <div class="comment-field">

<label for="comment">comment:</label> <input type="text"

@valid="onValid" @invalid="oninvalid" @touched="onTouched" @dirty="onDirty" @modified="onModified" v-validate:comment="['required']"/>

</div> <div>

<p>{ {occuredValid} }</p> <p> { { occuredinvalid}} </p> <p> { { occuredTouched} } </p> <p>{{occuredDirty}}</p> <p>{ {occuredModified} }</p>

</div> </validator>

第12章表单校验 183

</d坟>

new Vue(( el:'#app',

data: ( occuredValid:''

occuredinval过：'', occuredTouched:'', occuredDirty:'', occuredModi f ied:''

},

methods: (

onValid.: func巨on () (

this.occuredValid ='occured valid event' this.occuredinvalid =''

},

oninvalid: function () (

this.occuredinvalid ='occured invalid event' this.occuredValid =''

},

on Touched: function () (

this.occuredTouched ='occured touched event' ),

onDirty: func巨on () (

this.occuredDirty ='occured dirty event' },

onModified: function (e) (

this.occuredModified ='occured modified event:'+ e.modified

})

12.12.2 整个表单校验事件

除了监听单个字段的校验事件,我们也可以在validator元素上监听整个表单的校验事件。

在validator元素上我们可以监听以下事件：

0 valid—当全局验证结果变为有效时触发。 0 invalid—当全局验证结果变为无效时触发。

184 Vue.js权威指南

0 touched 当任意验证字段失去焦点时触发。

0 dirty 当任意字段首次改变时触发。

0 modified 当任意字段首次改变时或所有字段恢复初始值时触发。

<div id="app">

<validator name="validationl" @valid="onValid" @invalid="oninvalid" @touched="onTouched" @dirty="onDirty"

@modi丘ed="onModi丘ed"> <div class="comment-field">

<label for="username">username:</label> 釭nput type="text"

v-valida七e:username="['required']"/> </div>

<div class="password-field">

<label for="password">password:</label> <input type一"password"

v-validate:password="{ required: true, minlength: 8 }"/> </div>

<div>

<p>{ {occuredValid} }</p>

<p>{{occuredinval过} } <／p> <p>{{occuredTouched}}</p> <p>{{occuredDirty}}</p>

<p>{{occuredMod习五ed} }</p> </div>

</validator>

</div>

new Vue ({

el:'#app',

data: { occuredValid:'' occuredinvalid:'', occuredTouched:'', occuredDirty:'', occuredModified:''

第12章表单校验 185

},

methods: {

on Valid: function () {

this.occuredValid ='occured valid event' 七his.occuredinvalid =''

},

oninvalid: function () {

this.occuredinva巨d ='occured inva巨d event' this.occuredValid =''

},

onTouched: func巨on () {

this.occuredTouched ='occured touched event' },

onDi江y: function () {

this.occuredDir七y ='occured dirty event' },

onModified: funct工on (modified) {

this. occuredModified ='occured modified event:'+ modified

))

12.13 延迟初始化

在validator元素上设置lazy属性可以延迟校验,只有在组件实例上调用$activate Validator 方法才会初始化校验。当要校验的数据需要异步加载时,该特性可以避免数据加载之前出现错 误提示。

当评论数据从服务端返回时,才进行校验。代码示例如下：

<div> <hl>Preview</hl> <p>{{comment)}</p>

<validator lazy name="valida巨onl">

<input type="text" :value="comment" v-validate:commen七＝"(required: true, maxleng七h:

256 }"/>

<span v-if="$validationl.comment.required">Required your comment</span> <span v-if="$validationl.comment.maxlength">Too long comment ! !</span> <button type="button" value="save" @click="onSave" v-if="valid">

186 Vue.js权威指南

<Iva巨dator> </div>

Vue. component ('comment', { props: (

id: Number, ),

data: function () { return (comment:'') ),

activate: function (done) (

var resource= this.$resource('/comments/:id'); resource.get({ id: this.id), function (comment, stat, req) { this.commont = comment.body

//激活validator

this.$activateValidator()

done()

).bind(this)).error(function (data, stat, req) (

//请求失败逻辑

done() ))

), methods: (

onSave: function () {

var resource= this.$resource('/comments/:id');

resource.save({ id: this.id), { body: this.comment), function (data, stat, req) {

//请求成功逻辑

)). error (funct].on (data, sta, req) {

//请求失败逻辑 ))

})

12.14 自定义验证器

除了内置的验证器,我们也可以根据需求自定义验证器。

第12章表单校验 187

12.14.1 注册自定义验证器

我们可以通过全局或局部两种注册方式来注册验证器。 1.全局注册

// E-mail格式验证器

Vue. validator ('email', function (val) (

return / A (([A<>() [ \] \ \., ; : \ s@\"] + (\. [A<> () [ \ l \ \., ; : \ s@\"] +) *) I (\". + \")) @ ((\ [ [ 0-

9] (1, 3} \. [ 0-9 J { 1, 3} \. [ 0-9 J (1, 3} \. [ 0-9 l (1, 3} \ l) I (([ a-zA-Z\-0-9 l + \.) + [ a- zA-Z l (2, })) $ /. t est (val)

))

new Vue ({ el:'#app' data: { email:''

))

<div id="app">

<validator name="validationl">

address: <input type="text" v-validate:address="['email']"><br /> <div>

<p v-show="$validationl.address.email">Invalid your mail address format.</p> </div>

<validator>

</div>

2.局部注册

可以通过组件的validators选项来注册只能在组件内使用的验证器。验证器方法返回true 表示校验通过,返回false表示校验失败。

下例中注册了numeric和url两个自定义验证器。

new Vue { { el:'#app',

validators: { //、numeric、and、url、custom validator is local registra七ion

．．

numeric: function (val/*, rule*/) {

return /A(-+]?(0-9]+$/.test(val) ),

url: function (val) {

188 Vue.js权威指南

return r(http\:\/\/lhttps\:\/\/) (.{4,))$/.test(val)

, ,

．． {1

,1 :a arn te

,a }d

})

<div id="app">

<validator name="validationl">

username: <input type="七ext" v-validate:username="['required']"><br /> email: <input type="text" v-validate:address="['email']"><br />

age: <input type="text" v-validate:age="['numeric']"><br />

site: <input七ype="text" v-validate:site="['url']"><br />

<div class="errors">

<p v-if="$validationl.username.required">required username</p> <p V一if="$validationl.address.email">invalid email address</p> <p V一if="$validationl.age.numeric">invalid age value</p>

<p V一if="$validationl.site.url">invalid site uril format</p> </div>

<validator>

</div>

12.14.2 错误信息

在注册自定义验证器时,我们可以指定校验未通过时的错误信息。代码示例如下： //全局注册、email、自定义验证器

Vue. validator ('ema工l,, {

message: 'invalid email address', //校验未通过时错误信息 check: func七ion (val) { // define validator

return I A (([ A<> () [ \] \ \., ; : \ s@\"] + (\. [ A<> () [ \] \ \., ; : \ s@\"] +) *) I (\". + \")) @ ((\ [ [ 0-

9] {1,3)\. (0-9] {1,3)\. [0-9] {1,3)\. [0-9] {1,3)\]) I (([a-zA-Z\-0-9]+\.)+[a-zA-Z] {2,)))$/.t es七(val)

})

//重置内置验证器required｀校验未通过时错误信息

Vue. validator ('required', {

message: function (field) { //校验未通过时错误信息 return'required"'+field+'" field'

),

第12章表单校验 189

check: Vue. validator ('required') //调用内置验证器

))

new Vue (( el:'#app', validators: (

numeric: (//注册｀numeric·自定义验证器 message:'invalid numeric value', check: function (val) {

return /A[-+]?[0-9]+$/.test(v

},

url: { //注册url自定义验证器,用来验证输入的url是否合法 message: function (field) { return'invalid"'+field+'" url format field'

check: function (val) {

return /A(http\:\/\/lhttps\:\/\/) (.{4,))$/.test(val)

},

data: { email:''

))

<div id="app">

<validator name="validationl">

username: <input type="text" v-validate:username="['required']"><br /> email: <input七ype="text" v-validate:address="['email']"><br />

age: <input type="七ext" v-validate:age="['numeric']"><br />

site: <input type="text" v-validate:site="['url']"><br />

<div class="errors">

<validator-errors :validation="$validationl"></validator-errors> </div>

<validator>

</div>

12.15 自定义验证时机

在默认情况下,vue-validator会在初始化完成后根据validator和v-validate指令自动进行验

190 Vue.js权威指南

证。但是,有时候在初始化时我们并不需要验证,这时可以通过initial属性或者v-validate验证 规则来关闭自动验证。代码示例如下：

<div id="app">

<validator name="validationl"> <form novalidate>

<div class="username-field">

<label for="username">username:</label>

<1--'inital'attribute is applied the all validators of targe七element (e.g.

required, exis七) －－>

釭npu七id="username" type="tex七"initial="off" v-validate: username=" ['required', 'exist']">

<Id江>

<div class="password-field">

<label for="password">password:</label>

< ! --'initial'optional is applied with、v-validate、validator (e.g. required only) --> 红nput id="password" type="password" v-validate:passowrd="{ required: { rule: true,

initial:'off'}, minlength: 8 }">

</div>

<input type="submit" value="send" v-if="$validationl.valid">

</form> </validator> </div>

在validator初始化完成后,voe-validator会在DOM元素的input、blur、change事件触发 时自动验证。可以使用detect-change和detect-blur属性来关闭这些事件的自动验证。代码示 例如下：

<div id="app">

<validator name="validation">

<form novalidate @submit="onSubmit"> <hl>user registration</hl>

<div class="username">

<label for="username">username:</label> <input id="username" type="text"

detect-change="off" detect-blur="off" v-validate:username="{ required: { rule:七rue, message:'required you name ! !')

) " />

</div>

<div class="password">

第12章表单校验 191

<label for="password">password:</label>

<input id="password" type="password" v-model="password" detect-change="off" detect-blur="off" v-validate:password="{ required: { rule: true, message:'required you new password ! !'J, minlength: { rule: 8, message:'your new password short too ! !')

} " /> </div>

<div class="confirm">

<label for="confirm">confirm password:</label> <input id="confirm" type="password"

detect-change="off" detect-blur="off" v-validate:confirm="{

required: { rule: true, message:'required you confirm password ! 1'J, confirm: { rule: password, message:'your confirm password incorrect ! !'J

) " /> </div>

<div class="errors" v-if="$valida七ion.touched">

<validator-errors :validation="$validation"></validator-errors> </div>

<input type="subrni七"value="register" /> </form>

</validator>

</div>

new Vue ([

el:'#app',

data: {

password:'' ),

validators: (

confirm: func巨on (val, target) ( return val=== target

), methods: {

onSubm江：function (e) { // validate manually var self= this

this. $validate (true, function () {

192 Vue.js权威指南

1.f (self. $validation. invalid) ( e. preventDefaul t ()

))

))

12.16 异步验证

当需要在服务端验证数据或其他需要异步验证的场景时,我们可以使用vue-validator的异 步验证功能。

12.16.1 注册异步验证器

异步验证器的注册和同步验证器的注册流程一样,唯一的区别就是验证器方法的返回值不 同,返回以下两种类型的值都为异步验证器。下面我们用setTimeout来说明如何注册异步验证器。

0返回值为function,签名为function(resolve, reject)。调用resolve()表示校验通过,调用 reject()表示校验失败。代码示例如下：

//自定义异步验证器

Vue. validator ('exist', function (val) { return function (resolve, reject) {

setT耳neout (func巨on () {

辽(Math.random() >.5) {

//校验通过

resolve(); ) else {

//校验失败

reJ ect () ;

}, 500);

};

})

new Vue ({ el:'#app'

第12章表单校验 193

data: {

user:

})

<div id="app">

<validator name="valida巨on">

user: <inpu七七ype="text" v-validate:user="['exist']"><br /> <div>

<p v-show="$valida巨on.user.exist">the user is already registered.</p> </div>

<validator>

</div>

O返回值为promise对象。promise被resolve表示校验通过,promise被reject表示校验失 败。代码示例如下：

//自定义异步验证器

Vue. validator ('exist', function (val) {

var promise = new Promise (function (resolve, reject) ( set Timeout (function () {

辽(Math.random() >.5) { //校验通过

resolve(); } else {

II校验失败

reject() ;

}, 500); )) ;

//返回promise对象

return promise;

})

new Vue ({ el:'#app' data: {

user:

})

194 Vue.js权威指南

<div id="app">

<validator narne="valida巨on">

user: <inpu七type="text" v-valida七e: user=" ['exist') "><br /> <div>

<p v-show="$validation.user.exist">the user is already registered.</p> </div>

<validator>

</div>

12.16.2 验证器函数context

验证器函数context是绑定到Validation对象上的。Validation对象提供了一些属性,这些属 性在实现特定的验证器时有用。

1. vm属性

暴露了当前验证所在的Vue实例,代码示例如下：

new Vue ({

data () { return { check)_ng: false }), val)_dators: {

exist (val) {

this.vm.checking =true// spinner on return fetch('/validat)_ons/ex)_st', {

I I...

}). then ((res) => { // done this.vrn.checking =false// spinner off return res. j son ()

}).then((json) => {

return Promise.resolve() }). catch ((error) => {

return Prornise.reject(error.rnessage)

})

))

第12章表单校验 195

2. el属性

暴露了当前验证器的目标DOM元素。下面展示了结合International Telephone Input jQuery 插件使用的例子。

new Vue (( validators: {

phone: function (val) {

return $(this.el).intlTelinput('isValidNumber')

})

第13章

与服务端通信

Vue.js可以构建一个完全不依赖后端服务的应用,同时也可以与服务端进行数据交互来同 步界面的动态更新。Vue.js本身并没有提供与服务端通信的接口,但是通过插件的形式实现了 基千AJAX、JSONP等技术的服务端通信。

vue-resource是一个通过XMLHttpRequest或JSONP技术实现异步加载服务端数据的Vue.js插件。该插件提供了一般的 HTTP请求接口和RESTful架构 请求接口,并且提供了全局方法 和Vue组件实例方法。一般的 HTTP请求接口按照调用的便捷 程度又分为底层方法和便捷方 法,便捷方法是对底层方法的封 装。在vue-resource中我们可以 全局配置。同时,它提供了数据 获取各个阶段的钩子,使得我们 可以对数据获取过程进行更好的 控制。以下内容讲解都是基千 vue-resource 0. 7.2版本,后面介

绍中就不加版本号了。

vue-resource插件提供的公 开方法总览图如图I 3-1所示。

!"低圾方法一一 归．httP

？全禺调用 ::．如中砰

I \e便捷方法一旦巨三

忑HTT屯丛 We.m01-

,／ －一一

／ ' 低级方法一· tl1il.$http

二

\ r

。组件实例谓用 < 们"hltp.get

vue.resource公开方法

....$http.post

O便捷方法 － －

....$http.put

lhlsSht中patch时..Shttpdelete 钊3劝ttp.J心p

\ :::=.:"

p全局调用一一·

心．""U咄)．q叩

V噙"sou,a,().upda也

\ /,心．"IOU咄~=·

/ Vue,.sou元)d础心

＼

飞但STful调用

\.... u-~

组件实例调用一一...

加s.$resour氓)q叩

加'.S,e沁u,氓)．如叩 印｀｀esoum叫)－ 印急e.兀臼ou,ce()...,.,.

图13-1 vue-resource公开方法总览

第13章与服务端通信 197

13.1 vue-resource安装及配宣

13.1.1 安装

vue-resource提供了npm、bower、手动编译等安装方式,可以根据业务需要选择其中一种 方式进行安装。三种安装方式的安装方法及适合场景如下：

1. npm

如果项目基于npm包方式来开发,则可以使用npm来安装vue和vue-resource,执行如下 命令：

$ npm i vue vue-resource --save-dev

然后在项目中引入Vue.js和vue-resource,并且在Vue.js中注册vue-resource插件,代码示 例如下：

//引入Vue. j s和vue-resource var Vue = require ('vue') ;

var VueResource = require('vue-resource'); //注册vue-resource插件

//注意,假如Vue. j s已经在html中直接引入,则不需要再执行此步骤 //此时vue-resource会自动调用Vue.use方法来注册 Vue.use(VueResource);

2. bower

当业务代码使用bower来管理时,可以使用bower安装到指定目录。为了便千举例,假定 该目录为js/vendor,执行如下命令：

$ bower install vue-resource

在HTML中,在vue文件之后引入vue-resource,代码示例如下：

<'--引入vue -->

<script src="js/vendor/vue.js"></script> < !" －－引入vue-resource -->

<script src="js/vendor/vue-resource.js"></script>

3.手动编译

当想尝试一些Vue中并未发布的新特性时,可以直接clone源码,手动构建来实现。由于 在未正式发布之前,有些特性可能会被移除,所以不建议在生产环境中使用手动编译方式安装。

198 Vue.js权威指南

执行如下命令：

$ git clone https://github.com/vuejs/vue-resource.g江 $ cd vue-resource

$ npm install

$ npm run build

编译后的文件在dist目录中。

13.1.2 参数配置

vue-resource将请求配置分为全局配置、组件实例配置和调用配置三部分。这三部分的优先 级依次增高,优先级高的配置会覆盖优先级低的配置。接下来我们将详细讲解每部分应如何配 置。现在让我们先来看一下全局配置默认参数,如图13-2所示。

／一一三

／

图13-2 全局配置option属性

以上参数的详细说明请参阅13.1.5节。 1.全局配置

Vue.http.options.root='/root'

2.组件实例配置

在实例化组件时可以传入http选项来进行配置,代码示例如下：

new Vue ({

http: { root:'/root', headers: {

第13章与服务端通信 199

Author).zation:'Bas).c Yxsdlfju).'

})

3.方法调用时配置

在调用vue-resource请求方法时传入选项对象,代码示例如下：

new Vue ({

ready: function () { // get请求

this.$http.get({url:'/someUrl', headers: { Authorization:'Basic Yxsdlfjui'}})

. then (f~nction (response) {

//请求成功回调

}, function (response) {

//请求失败回调 })

})

13.1.3 headers配置

在13.1.2节中,我们了解到可以通过headers属性来配置请求头。合并策略遵循参数配置合 并策略。除了参数配置headers属性可以设置请求头外,在vue-resource中也提供了全局默认的 headers配置,如图13-3所示。

{'Content-Type':'application/json'l

{'Content-Type':'application/json'}

('Content-Type':'application/json'}

('Content-Type':'applic的on/json'}

{'Accept','application/json, te,<t/plain,．广}

{'X-Requested-With':'XMLHttpRequest')

图13-3 全局默认headers配置

200 Vue.js权威指南

在图13-3中,我们可以看到Yue.http.headers键值可以是HTTP方法名、common、custom 三种类型。这三种类型的配置会进行合并,优先级从低到高依次是common、custom、HTTP 方法名。

其中common对应的请求头会在所有请求头中设置,custom对应的请求头在非跨域时设置, HTTP方法名对应的请求头只有在请求的method匹配方法名时才会被设赏。

13.1.4 基本HTTP调用

基本HTTP调用即普通的GET、POST等基本的HTTP操作,实际上执行增、删、改、查 是前后端开发人员共同约定的并非通过HTTP的请求方法如GET代表获取数据、PUT代表写入 数据、POST代表更新数据。后者为RESTful调用,后面我们会详细介绍RESTful调用方法。 底层方法和便捷方法执行后返回一个Promise对象,可以使用Promise语法来注册成功、失败回 调,详情请参阅13.1.10节。

1.底层方法

全局的Vue.http方法和Vue组件的实例方法this.$http都属千底层方法,它们根据所传option 参数的method属性米判断请求方式是GET还是POST,抑或是其他HTTP的合法方法。

(I)全局调用

Vue.http(option)

(2)组件实例调用

this.$http(option)

以上两种调用方式接受相同的option参数,都返回Promise对象。不同的是,全局调用方 式回调中的this指向window,而组件实例调用方式回调指向组件实例。

option对象请参阅13.1.5节。

我们以组件实例调用方式为例来了解一下如何发送POST请求,代码示例如下：

new Vue ((

ready: func巨on () ( II POST请求

this. $http (( url:'lbook', method:'POST',

第13章与服务端通信 201

//请求体中发送的数据

data: {

cat:'1' },

//设笠请求头

headers: { 'Content-Type':'x-www-form-urlencoded'

}).then(function (response) {

//请求成功回调

}, function (response) {

//请求失败回调 })

其他请求请参阅13.1.5节。 2,便捷方法

不同千底层方法,便捷方法是对底层方法的封装,在调用时可以省去配置选项option中的

method属性。以下为vue-resource提供的便捷方法列表：

0 get(url, [data], [options])

0 post(url, [data], [options])

0 put(url, [data], [options])

0 patch(url, [data], [options])

0 delete(url, [data], [options])

。jsonp(url, [data], [options])

便捷方法接受三个参数：

0 url(字符串),请求地址,可被options对象中的url属性覆盖。

0 data(可选、字符串或对象),要发送的数据,可被options对象中的data属性覆盖。 0 options,请参阅13.1.5节。

202 Vue.js权威指南

我们以POST请求为例来了解便捷方法的使用,代码示例如下：

this.$h七tp.post( 'http://example.com/book/create',

//请求体中要发送给服务端的数据

cat:'l', name:'newbook'

},

'headers': { 'Content-Type':'x-www-forrn-urlencoded'

). then (function (response) {

//成功回调

console.log(response.data) }, function (response) (

//失败回调

console. log ('something wrong')

))

13.1.5 请求选项对象

在调用HTTP请求方法时,可以传入选项对象来控制请求。例如：

Vue.http(option)

下面我们来看看option对象的各属性及含义。 1. Llrl (字符串)

请求的URL地址。

2. method (字符串)

默认值为GET,请求的HTTP方法(GET、POST等)。 3. data (对象或字符串)

默认值为",需要发送给服务端的数据。注意,data属性的值对千method为POST、PUT、 DELETE等请求会作为请求体来传送,对千GET、JSONP等方式的请求将会拼接在url查询参

第13章与服务端通信 203

数中。

4. params (对象)

默认值为{},用来替换url中的模板变量,模板变量中未匹配到的属性添加在URL地址后 边作为查询参数。代码示例如下：

Vue.http({ url:'http://example.com/{book)', par ams: {

book:'vue',

cat:'1'

))

最终URL为http://example.com/vue?cat=l。 5. headers (对象)

默认值为{},设置HTTP请求头。 6. xhr (对象)

默认值为null,该对象中的属性都会应用到原生xhr实例对象上。源码定义如下：

].f (_.].sPla].nObj ect (request. xhr)) { .extend(xhr, request.xhr);

7. upload (对象)

默认值为nu11,该对象的属性都会应用到原生xhr实例对象的upload属性上。源码实现如下：

if {_. isPlainObj ect (request. upload)) { _.extend(xhr.upload, request.upload);

8. jsonp (字符串)

默认值为callback, JSONP请求中回调函数的名字。代码示例如下：

Vue.http({ url:'http://example.com/book', method:'JSONP',

jsonp:'cb'

))

204 Vue.js权威指南

最终URL地址为http://example.com/book?cb=xxx,其中xxx为vue-resource生成的随机串。

源码实现如下：

var callback='_jsonp'+ Math.random().toString(36).substr(2); request.params[request.jsonp] = callback;

9. timeout (数值)

默认值为O,单位为ms,表示请求超时时间,0表示没有超时限制。超时后,将会取消当 前请求。vue-resource内部通过拦截器注入超时取消逻辑。源码定义如下：

辽(reques七．七imeout) {

timeout= setTimeout(function () { request.cancel();

}, request.七imeout);

//超时后Promise会被reject,错误回调会被执行 10. beforeSend (函数)

默认值为null,该函数接受请求选项对象作为参数。该函数在发送请求之前执行, vue-resource内部在拦截器的最前端调用该方法。源码定义如下：

辽(_.isFunc巨on (request.beforeSend)) ( request.beforeSend.call(this, request);

11. emulateHTTP (布尔值)

默认值为false,当值为true时,用HTTP的POST方法发送PUT、PATCH、DELETE等请 求,并设置请求头字段HTTP-Method-Override为原始请求方法。源码定义如下：

if (request.emulateHTTP && /~(PUTIPATCHIDELETE)$/i.test(request.method)) { request.headers['X-HTTP-Method-Override'] = request.method;

reques七．method='POST';

12. emulateJSON (布尔值)

默认值为false,当值为true并且data为对象时,设置请求头Content-Type的值为application/ x-www-form-urlencoded。源码定义如下：

if (request.emulateJSON && _.isPlainObject(request.data)) ( request.headers['Content-Type'] ='application/x-www-form-urlencoded'; request.data= _.url.params(request.data);

第13章与服务端通信 205

13. crossOrigin (布尔值)

默认值为null,表示是否跨域,如果没有设置该属性,vue-resource内部会判断浏览器当前 URL和请求URL是否跨域。源码定义如下：

if (request. crossOrigin === null) { request.crossOrigin = crossOrigin(request);

辽(request. crossOrigin) {

辽(1 xhrCors) { request.client= xdrClient;

request.emulateHTTP = false;

如果最终crossOrigin为true并且浏览器不支待CORS,即不支持XMLHttpRequest2时,则 会使用XDomainRequest来请求。目前XDomainRequest只有IE 8、IE 9两款浏览器支持用来进 行AJAX跨域。XMLHttpRequest2和XdomainRequest的具体细节请参阅13.1.9节。

13.1.6 response对象

response对象包含服务端返回的数据,以及HTTP响应状态、响应头等信息。下面展示了

response对象的各属性及其含义。

0 data(对象或字符串)：服务端返回的数据,已使用JSON.parse解析。

0 ok(布尔值)：当HTTP响应状态码在200~299区间时该值为true,表示响应成功。 0 status(数值)：HTTP响应状态码。

0 statusText(字符串)：HTTP响应状态文本描述。

0 headers(函数)：获取HTTP响应头信息,不传参表示获取整个响应头,返回一个响应 头对象;传参表示获取对应的响应头信息。

0 request(对象)：请参阅13.l.5节。

13.1.7 RESTful调用

RESTful调用方式就是客户端通过HTTP动词来表示增、删、改、查实现对服务端数据操

206 Vue.js权威指南

作的一种架构模式。

vue-resource提供全局调用Vue.resource或者在组件实例上调用this.$resource。这两种调用 方式接受相同的参数：

resource (url, [params], [actions], [options])

1. url (字符串)

请求地址,可以包含占位符(花括号所包围的内容即为占位符),它会被params对象中的 同名属性的值替换,详「青请参阅13.1.11节。

this. $resource ('/books/ (cat}', {cat:'1'))

最终实际URL为/books/I。 2. params (可选,对象)

参数对象,可用来替换url中的占位符,多出来的属性会拼接成url的查询参数。 3. actions (可选,对象)

可以用来对已有的action进行配置,也可以用来定义新的action。默认的action配置如下：

Resource.actions= {

get: {method:'GET'},

save: {method:'POST'}, query: {method:'GET'}, update: {method:'PUT'}, remove: {method:'DELETE'}, delete: {method:'DELETE'}

我们可以定义新的action,代码示例如下：

this.$resource( '/books/ {cat}',

cat:'1'

},

charge:

method:'POST', pa rams: {

第13章与服务端通信 207

charge: true

上面我们定义了一个名为charge的action,它使用POST方法来请求资源。

注：actions对象中的单个action如charge对象可以包含options中的所有属性,且其优先

级高于options对象。

4. options (可选,对象) 请参阅13.1.5节。

resource方法执行后返回一个包含了所有action方法名的对象,其包含自定义的action方法, 这些方法都返回Promise对象,详情请参阅13.1.10节。下面让我们看看完整地使用resource来 请求数据的例子。代码示例如下：

var resource = this. $resource ('/books/ {id}');

//查询

//第一个参数为params对象,优先级高于resource方法的params参数 resource. get ({id: 1}).七hen (response) {

this. $set ('i tern', response. i tern) }

//保存

//第二个参数为要发送的数据

resource. save ({id: 1}, { i七em: this. i tern)). then (function (response) {

//请求成功回调

}, function (response) {

//诸求失败回调 })

resource. delete ({id: 1}).七hen (function (response) {

//成功回调

}, function (response) {

//失败回调 })

13.1.8 拦截器

可以全局进行拦截器设置,拦截器可以在请求发送前或响应返回时做一些特殊的处理。

208 Vue.js权威指南

1.拦截器的注册

Vue.http.interceptors.push({

request: function (request) {

//更改请求类型为POST

request.method='POST' re亡urn request

},

response: function (response) {

//修改返回数据

response.data= [{ custom:'custom'

) ］

return response

))

2.工厂函数注册

Vue.ht七p. interceptors. push (function () { return {

request: function (request) { return request

),

response: function (response) { return response

})

13.1.9 跨域AJAX

很多人认为AJAX只能在同域的情况下发送成功,很早的时候,由于浏览器安全策略,AJAX 确实只能在同域的情况下发送。但是目前很多浏览器已经开始支待XMLHttpRequest2。 XMLHttpRequest2引入了大量的新特性,例如跨域资源请求(CORS)、上传进度事件、支持二 进制数据上传／下载等。

本节我们将会介绍vue-resource中用到的CORS特性,以及XMLHttpRequest2的替代品 XDomainRequest。

第13章与服务端通信 209

1. XMLHttpRequest2 CORS

XMLHttpRequest2是第二代XMLHttpRequest技术,提交AJAX请求还是和普通的 XMLHttpRequest请求一样,只是增加了一些新特性。

在提交AJAX跨域请求时,首先我们需要知道当前浏览器是否支持XMLHttpRequest2,判 断方法是使用m操作符检测当前XMLHttpRequest实例对象是否包含with Credentials属性,如 果包含则支持CORS。代码示例如下：

var xhrCors ='withCredentials'in new XMLHttpRequest()

在支持CORS的情况下,还需要服务端启用CORS支持。

假如我们想从http://example.com域中提交请求到http://crossdomain.com域,那么需要在 crossdomain.com域中添加如下响应头：

Access-Control-Allow-Origin: http://example.com

如果crossdomain.com要允许所有异域都可以AJAX请求该域资源,则添加如下响应头：

Access-Control-Allow-Origin: *

服务端开启CORS支持后,在浏览器中我们就可以和提交普通的AJAX请求一样提交跨域 请求了。代码示例如下：

var xhr = new XMLHttpRequest ()

xhr. open ('GET','http://www. crossdomain. com/hello. j son') xhr. onload = function (e) {

var data= JSON.parse(this.response)

xhr. send()

2. XDomainRequest

如果想在IE 8、IE 9中支持CORS (IE 10及以后版本支持XMLHttpRequest2),我们可以 使用XdomainRequest(该属性目前已废弃,不建议使用)。如果vue-resource不支持 XMLHttpRequest2,则会降级使用此种方式。代码示例如下：

//实例化

XDomainReques七

var xdr = new XDomainRequest()

xdr. open ("get", "http://crossdomain.com/hello. j son") xdr. onprogress = function () {

//进度回调

210 Vue.js权威指南

xdr. on timeout = function () {

//超时回调

xdr. onerror = function () {

//出错回调

xdr. onload = function () {

//成功回调

//success(xdr.responseText)

set Timeout (function () {

//发送请求

xdr. send () )'0)

注：XDomain只支持GET和POST两种请求,如果要在vue-resource中使用其他方法请求, 请设置请求选项对象的emulateHTTP为true。在定时器中调用xhr.send()方法,是为了防止多个 XDomainRequest请求同时发送时部分请求丢失。

13.1.1 O Promise

vue-resource基本HTTP调用和RESTful调用action方法执行后都会返回一个Promise对象, 该Promise对象提供了then、catch、finally等常用方法来注册回调函数。代码示例如下：

var promise= this.$http.post( 'http://example.com/book/create',

//请求体中要发送给服务端的数据

cat:'1', name:'newbook'

},

'headers': { 'Content-Type':'x-www-form-urlencoded'

prom乓se. then (function (response) {

第13章与服务端通信 211

//成功回调

console.log(response.data) }, function (response) {

//失败回调

console. log ('something wrong')

})

promise.catch(function (response) {

//失败回调

console. log ('something wrong')

})

promise. fin.ally (function () {

//执行完成功或者失败回调后都会执行此逻辑 })

注：所有回调函数的this都指向组件实例。

13.1.11 url模板

vue-resource使用url-template库来解析url模板。我们来看一个使用url-template解析url 模板的例子。代码示例如下：

//引入url-template库

var template = require ('url-template');

var ema过Url = template.parse('/{email}/{folder}/{id}'); //返回'/user@domain/test/42'

ema过Url.expand({

email:'user@domain', folder:'test',

id: 42

在vue-resource方法请求传参时我们可以在url中放置花括号包围的占位符,vue-resource 内部会使用url-template将占位符用params对象中的属性进行替换。代码示例如下：

th].s.$resource('/books/{cat}', {cat:'l'})

最终实际URL为/books/1。

注：url-template: https://github.com/bramstein/url-template。

212 Vue.js权威指南

13.2 vue-async-data

vue-async-data是一个异步加载数据状态指示的插件,它本身并不支持异步获取服务端数据 的功能,仅仅指示数据目前是处千加载状态还是已经加载完毕。通过不同的状态我们可以设置 加载动画效果等。

13.2.1 安装

如果项目基千npm包方式来开发,则可以使用npm来安装vue和vue-async-data。执行如 下命令：

$ npm i vue vue-async-data --save-dev

然后在项目中引入Vue.js和vue-async-data,并且在Vue.js中注册vue-async-data插件。代 码示例如下：

//引入Vue. j s和vue-async-data var Vue = require ('vue')

var VueAsyncData = require ('vue-async-data') //注册vue-async-data插件 Vue.use(VueAsyncData)

13.2.2 使用

在创建Vue组件实例时,在选项中增加asyncData方法。代码示例如下： //假设为CommonJS环境

var Vue = require ('vue')

var VueAsyncData = requ].re ('vue-async-data') //安装vue-async-data插件 Vue.use(VueAsyncData)

//在创建组件实例时,在选项中增加asyncData方法

Vue.component('example', { data: funct].on {

return {

msg:'not loaded yet...'

},

asyncData: function (resolve, reject) {

第13章与服务端通信 213

//数据加载成功时调用resolve (data),告诉vue-async-data数据加载成功,此时$loadingAsyncData //会被设笠为false

//数据加载失败时调用reject (reason),告诉vue-async-data数据加载失败

//以下为了便于举例,我们用se七Timeout来模拟异步数据请求,实际上可以调用任何数据请求插件,如

II vue-resource

set Timeout (function () {

II以下方法调用后,vue-router会自动调用vm.$set('msg','hi'), vm.$set('$loadingAsyncData',true)

resolve ({

msg:'hi'

))

}, 1000)

))

假设上面的example组件对应的视图模板如下：

<div v-if="$loadingAsyncData">Loading... </div>

<div v-if="!$loadingAsyncData">Loaded. Put your real content here.</div>

那么,当组件创建时会展示Loading 内容;当数据成功返回时会展示Loaded. Put your real content here.内容。

有时候我们需要手动去服务端获取最新数据来更新界面,这时需要调用组件的实例方法来 重新加载数据。代码示例如下：

vm. reloadAsyncData ()

注：必须调用vm.reloadAsyncData(),而不是vm.asyncData()。因为在vue-router内部实现 时,在调用vm.reloadAsyncData()方法时首先会将vm.$loadingAsyncData设置为true,在数据成 功返回时会设置vm.$1oadingAsyncData为false。这样模板就会根据$loadingAsyncData的真假来 判断该展示Loading效果还是实际内容。

13.3 常见问题解析

13.3.1 如何发送JSONP请求

首先我们需要知道JSONP是利用JavaScript可以跨域的特性从服务端请求数据的。也就是 说,在跨域的情况下才有必要使用JSONP来发送请求。vue-resource提供了三种调用方式。

214 Vue.js权威指南

1．全局方法

Vue.http({

url:'http: //example.com/books', //参数部分,将会拼接在url之后

params: {

cat: 1

}, method:'JSONP'

}). then (function (response) {

// response.data为服务端返回的数据 console.log(response.da七a)

}). catch (function (response) {

//出错处理

console.log(response)

})

2.实例底层方法

七his. $http ({ url:'http://example.com/books', //参数部分,将会拼接在url之后

params: {

cat: 1

}, method:'JSONP'

}). then (function (response) { // th乓;指向当前组件实例 console.log(this)

}). catch (function (response) { //出错处理

console.log(response)

})

3.实例便捷方法

this. $http. j sonp ( 'http://example.com/books', //参数部分,将会拼接在url之后

cat: 1

). then (func巨on (response) {

第13章与服务端通信 215

// this指向当前组件实例 console.log(this) }).catch(function (response) {

//出错处理

console.log(response)

))

13.3.2 如何修改发送给服务端的数据类型

在默认情况下,对千PUT、POST、PATCH、DELETE等请求,请求头中的Content-Type 为application/json,即JSON类型。有时我们需要将数据提交为指定类型,如application/x-www­form-urlencoded、mu !ti part/form-data、text/plain等。下面我们以POST请求为例来说明。

1.全局headers配置

Vue.http.headers.post['Content-Type'] ='application/x-www-form-urlencoded'

2.实例配置

this.$http.post( 'http://example.com/books',

//成功回调

func巨on {data, status, request) { if (status == 200) { console.dir(data)

},

{

//配罚请求头

headers: { 'Content-Type':'multipart/form-data'

注：实例配置的优先级高于全局配置,因此最终Content-Type为multipart/form-data。

13.3.3 跨域请求出错

跨域请求需要服务端开启CORS支持,详情请参阅13.1.9节。

216 Vue.js权威指南

13.3.4 $.http.post方法变为OPTIONS方法

在跨域的情况下,对千非简单请求(PUT、DELETE、Content-Type为application/json),浏 览器会在真实请求前额外发起一次类型为OPTIONS的请求。只有服务器正确响应了OPTIONS 请求后,浏览器才会发起真实请求。

因此,为了在跨域的情况下使用POST提交Content-Type为applicatio叨son的数据或PUT、 DELETE等非简单请求,首先服务端需要开启CORS支持,详情请参阅13.1.9节。

同时需要设置如下响应头：

Access-Control-Allow-Methods: POST, GET, PUT, DELETE, OPTIONS

第14章

路由与视图

同AngularJS一样,Vue.js也很适合用来做大型单页应用。Vue.js本身并没有提供路由机制, 但是官方以插件(vue-router)的形式提供了对路由的支持。vue-router 0.7.13支待嵌套路由、组 件惰性载入、视图切换动画、具名路径等特性。以下内容讲解都是基千vue-router 0. 7.13版本, 后面就不加版本号了。

14.1 如伺安装

vue-router提供了npm、bower、手动编译等安装方式,可以根据业务需要选择其中一种方 式进行安装。这三种安装方式的安装方法及适合场景如下：

1. npm

当业务代码使用Webpack等支待CommonJS规范的模块化打包器来构建时,可以使用npm 包的方式来安装：

$ nprn install vue-router

因为vue-router是Vue.js的一个插件,所以vue-router需要使用Vue.use(PluginContructor) (Vue.js用此方法来注册插件)注册到Vue对象上,在vue-router内部会检测window.Vue对象是 否存在,如果存在则会自动调用Vue.use()方法,否则需要使用者手动调用Vue.use(VueRouter) 来确保路由插件注册到Vue中。在Webpack等支持CommonJS规范的环境中,Vue对象并不会 暴露到全局window对象中,而是会通过module.exports形式输出,因此需要使用者手动注册。

var Vue = require ('vue')

var VueRouter = require ('vue-rou七er') //安装vue-router

Vue. use (VueRouter)

218 Vue.js权威指南

2. bower

当业务代码使用bower来管理时,可以使用bower安装到指定目录。为了便于举例,假定 该目录为js/vendor。

$ bower install vue-router

在HTML中,在vue文件之后引入vue-router:

< !" －－引入vue -->

<script src="js/vendor/vue.js"></script> <!" －－引入vue-router -->

<script src="js/vendor/vue-router.js"></script>

3.手动编译

当想尝试一些Vue中并未发布的新特性时,可以直接clone源码,手动构建来实现。由于 在正式发布之前,有些特性可能会被移除,所以不建议在生产环境中使用手动编译方式安装。

$ git clone https://github.com/vuejs/vue-router.g江 $ cd vue-router

$ npm install

$ npm run build

14.2 基本使用

为了快速入门,我们先来看一个基千Webpack构建的简单示例。代码示例如下：

<div id="app"> <hl>Hello App1</hl> <p>

<!"－－使用指令v-link进行导航－－>

<av-link="{ path:'/foo'}">Go to Foo</a> <av-link="{ path:'/bar'}">Go to Bar</a>

<Ip>

<!"－－路由外链－－> ／

<router-view></router-view>

</div>

//引入Vue. j s

var Vue = require ('vue') ; //引入vue-router

var VueRouter = require('vue-router');

第14章路由与视图 219

//定义各路由组件

var Foo = Vue. extend ({ template:'<p>This is foo ! </p>' })

var Bar = Vue. extend ({

template:'<p>This is bar! </p>' })

II路由器需要一个根组件

//出于演示的目的,这里使用一个空的组件,直接使用HTML作为应用的模板

var App= Vue.extend({})

//创建一个路由器实例

//创建实例时可以传入配置参数进行定制。为保持简单,这里使用默认配置

var router= new VueRouter()

//定义路由规则

//每条路由规则应该映射到一个组件。这里的"组件"可以是一个使用Vue.extend //创建的组件构造函数,也可以是一个组件选项对象

//稍后我们会讲解嵌套路由

router. map ({ '/foo': {

componen七：Foo },

'/bar': { component: Bar

))

//现在我们可以启动应用了

II路由器会创建一个App实例,并且挂载到选择符＃app匹配的元素上 router.start(App,'#app')

14.3 卒见图部分

视图部分用来给用户提供导航以及导航结果展示区域。

14.3.1 v-link

在原生HTML中,我们用<a>标签的href属性来导航。在vue-router应用中,我们还是使用 <a>标签,不同的是,我们使用v-link属性而不是href属性。代码示例如下：

<av-link="{ path:'/join/DDFE'}">Join DDFE</a>

220 Vue.js权威指南

当用户在页面上点击Join DDFE时,vue-router会在路由映射中匹配path为/join/DDFE的 路由规则,如果成功匹配到,则会将对应路由组件的模板内容渲染到router-view区域中。

v-link是一个Vue.js指令,它的值是一个JavaScript表达式,可以接受一个表示path的字符 串或者包含name或path属性的对象。如果属性值既不是字符串也不是对象字面量,则会被当 作对应组件的数据属性来解析。代码示例如下：

<I-－字面扯路径,表示path。注意：符要用单引号把字符串内容括起来－－>

<a v-link;"'/home'">Home</a>

<'--值为对应组件的数据屈性,效果同上－－> Vue. component ('app', {

data: (

homeLinkMap: {

path:'/home'

})

<a v-link="homeLinkMap">l-lome</a>

<'－－值是一个包含path屈性的对象,效果同上－－> <av-link="{ path:'/home'}">Horne</a>

<!"－－值是一个包含name屈性的对象－－>

<av-link="{ name:'order', pararns: { status: O}}">order</a>

当v-link解析后的值是对象时,该对象可以有以下属性。 1. params (对象)

包含路由中的动态片段和全匹配片段的键值对。动态片段和全匹配片段请参阅14.6节。

2. query (对象)

包含路由中添加到路径path后的键值对。代码示例如下：

<av-link="{ path:'/home', query: {isAuthed: true} }">Home</a>

当该path被匹配时,地址栏URL为:/home打sAuthed=true。 3. replace (布尔值)

默认值为false。当该值为true时,此次导航不会产生历史记录。

第14章路由与视图 221

4. append (布尔值)

默认值为false。当该值为true时,如果此次导航的目的path为相对路径,则实际URL中 的路径是当前path后拼接目的path。假设当前path为／a,代码示例如下：

<'－－不加append屈性(默认值为false),目的URL路径为／b -->

<a V－让nk="{ path:'b'J">b</a>

<!-- append为true, l=I的URL路径为／alb--> <av-link="(path:'b', append: true}"> /alb <la>

5. activeClass (字符串)

默认值为v-link-active,指带有v-link指令的a元素处于激活状态时的class名称。该值也 可以在创建路由器实例时通过选项的linkActiveClass属性来进行全局设置。

注：在判断当前v-link指令所在元素是否处于激活状态时默认使用的是包含匹配。也就是 说,当前实际匹配的路由path中完全包含v-link所指path时该元素处于激活状态。1主意是实际 匹配路由中的path,而不是浏览器地址栏hash中的path部分,强调这个是因为当我们配置路由 别名时,地址栏的path和实际路由的path并不一致。我们也可以通过exact:true来设置只有当 v-link中的path和实际路由的path完全相等时才算匹配。代码示例如下：

<a v-link~" (path:'/exact', exact: true}" >exac七active</a>

注：使用v-link而不是href来设置URL,原因如下。

0 v-link是一个Vue.js指令,它会根据它的值来设置href的值。

0在hash模式和HTML5 history模式下,vue-router会统一行为,这样在改变模式时不需 要做任何改变。

0在HTML5 history模式下,v-link指令会监听点击事件,防止浏览器重新加载页面。

0在HTML5 history模式下,如果使用root选项,不需要在v-link的path中包含root路 径。

0在Vue.js 1.0绑定语法中,不支待Mustache插值标签,可以使用常规的JavaScript表达 式代替,例如v-link = "'user/'+ user.name"。

222 Vue.js权威指南

14.3.2 router一view

视图部分用来展示匹配路由的模板内容,在vue-router中使用router-view来渲染匹配的组 件。router-view是一个Vue组件,它具有以下一些特性。

0通过props传递数据。

0支持v-transition和transition-mode,代码示例如下： <'－－可以使用transi巨on指令在路由切换时提供过渡效果－－>

<router-view transi七ion="demo" transi七ion-mode="out-in"></router-view>

0支持v-ref,被渲染的组件会注册到父级组件的this$对象中。

0支持slot, router-view中的HTML内容会被插入到相应路由组件模板的slot中。

14.4 路由实例

在开始使用vue-router开发路由应用时,首先我们需要实例化vue-router。代码示例如下：

var VueRouter = require ('vue-router')

var router= new VueRouter(vueRouterConfig)

实例化VueRouter时可以传入一个可选的vueRouterConfig路由选项对象来自定义路由器的 行为。返回router路由器实例,router实例暴露了一些实例属性和实例方法,我们可以用来控制 整个路由应用。接下来介绍路由选项对象和路由器实例属性、方法。

1.路由选项

创建路由器实例时,可以传入路由选项来自定义路由器行为。

可选参数如下：

(1) hashbang(布尔值)

默认值为true。当该值为true时,表示匹配的路由在浏览器地址栏中以hash模式显示。例 如：假设当前浏览器地址栏中的地址为http://example.com/path?query,当用户点击home链接时, 浏览器地址栏中的地址会显示为http://example.com/path?query#!/home。

<a V－巨nk="(pa比：'／ddfe')">Join DDFE</a>

第14章路由与视图 223

(2) history(布尔值)

默认值为false。当该值为true时,会以HTML5 h飞tory API进行导航。当history值为true 时,需要注意以下问题：

0假如当前页面地址为http://example.com/home,而在路由配置中配置了/home/welcome 路径,那么当用户直接访问http://example.com/home/welcome路径时,服务器端应确保 返回http://example.com/home页面,而不是http://example.com/home/welcome页面;否 则有可能因为/home/welcome页面不存在而返回404错误。

0当history值为true时,不论hashbang值是否为true,总会以history模式进行导航。

0当history值为true,而浏览器并不支持HTML5 history API时,vue-router会自动降级 为hashbang模式。

(3) saveScrollPosition(布尔值)

默认值为false,该值只在history值为true时生效。当该值设置为true时,在点击浏览器后 退按钮时页面会定位到上一次该路由对应视图所在位置。

(4) transitionOnLoad(布尔值)

默认值为false。当该值为true时,在页面第一次加载时router-view会有路由切换动画,默 认为直接渲染。

(5) suppress Trans山onError(布尔值)

默认值为false。当该值为true时,在组件路由切换钩子中产生的异常不会被抛出。 (6) link:ActiveClass(字符串)

默认值为v-link-active,表示v-link所在元素处千激活状态时vue-router加在该元素上的 类名。

(7) root(字符串)

默认值为null,该值只在history值为true时生效。定义路由根路径,所有路径被匹配时, 浏览器地址栏URL会显示为根路径＋匹配路径。

224 Vue.js权威指南

2路由器实例属性

router实例暴露了两个属性：

(1) app(根组件实例)

vue-router应用的根Vue实例,由调用router.start(App,'#app')时传入的组件构造器App创建得到。 (2) mode(字符串)

可能值有html5、hash、abstract。

0 html5:当创建router实例时,所传配置对象history值为true,并且浏览器支待HTML5 history API时。

0 hash:当创建router实例时,所传配置对象hash值为true,或者history值为true,但浏

览器不支持HTML5 history API时。

0 abstract,当宿主环境中没有window对象(例如非浏览器环境)时,会自动退化为此模式。 3.路由器实例方法

router实例对外暴露了很多力法,用来提供启动、路由映射、重定向、路由切换全局钩了

等功能。具体的方法名及实现功能如下。

(I) start(App,el)

启动路由应用。该方法接受两个参数： 0 App(函数或对象)

App可以是一个Vue组件构造器或者组件选项对象,当为组件选项对象时,在vue-router

内部会调用Vue.extend来创建App构造器。

0 el(字符串或DOM元素)

el可以是一个CSS选择器或者DOM元素,用来挂载路由应用的根组件。 (2) On(path,config)

添加顶级路由配置。该方法接受两个参数： 0 path(字符串)

要匹配的路径,请参阅"路由匹配"部分。

第14章路由与视图 225

0 config(对象)

路由配置对象,请参阅"路由配置对象"部分。 (3) Map(routerMap)

批量定义路由映射规则,内部调用router.on方法实现。该方法接受一个参数： 0 routerMap(对象)

参数routerMap为对象,键为路径,值为路由配置对象。在vue-router内部会对routerMap 对象中的每个键值对调用router.on()方法来进行路由映射。路径定义请参阅"路由匹配"部分, 路由配置对象请参阅"路由配置对象"部分。

(4) go(path)

导航到指定path的路由。该方法接受一个参数： 0 path(字符串或对象)

当path为字符串时,会当作普通路径来解析。如果路径是相对路径(不以"I"开头),则 会以相对千当前路径的方式进行解析。

当path为对象时,对象中只包含path属性：

{path:'/a/b)

或者

name:'order', params: {id: 1),

query: { fieldName:'address'}

包含name的路径及具名路径,可参阅"具名路径"部分。

当path为对象时,两种格式都支持可选replace和append属性：

►replace,布尔类型,默认值为false。当该值为true时,跳转不产生新的历史记录。

►Append,布尔类型,默认值为false。当该值为true时,假如要跳转到的路径是相对路

226 Vue.js权威指南

径,则实际路径是当前路径拼接要跳转到的路径。假设当前路径为/a,目的路径为b, 当append值为false时,则实际跳转后路径为lb;为true时,则实际跳转后路径为/alb。

(5) replace(path)

和router.go(path)类似,但不会创建新的历史记录。其参数与replace.go(path)的参数相同。 (6) redirect(redirectMap)

定义全局重定向规则。如果要访问的路径匹配重定向规则,则路径会被重定向到指定的路 径,以重定向后的路径在浏览器中生成历史记录,原本访问的路径不会生成历史记录。该方法 接受一个参数：

0 redirectMap(对象)

该参数格式为{fromPath: toPath},即当前访问的路径到实际路径的映射关系。fromPath和 toPath请参阅"路由匹配"部分。

(7) Alias(aliasMap)

配置别名规则。和重定向不同的是,重定向的地址栏显示的是toPath,实际匹配的也是

toPath;酰lj名实际地址栏显示的是frornPath,而路由实际匹配的是toPath。该方法接受一个参数：

►aliasMap(对象)

该参数格式为{ frornPath: to Path}, frornPath和toPath请参阅"路由匹配"部分。 (8) BeforeEach(hookFunction)

该方法用来全局注册前置钩子。它会在整个路由切换的最前端被调用,优先千各路由组件 中的路由钩子执行,因此这里可以做一些全局的访问控制。当钩子被reject时,整个路由切换 将取消,页面将保待原来的状态。

我们可以用该方法来注册多个钩子函数,这些钩子会按照注册的顺序调用。但是,需要注 意的是,后一个钩子只有在前一个钩子被resolve之后才会调用。

0 hookFunction(函数)

钩子函数,它接受一个transition对象作为参数。关于transition对象请参阅"trans山on对象" 部分。

第14章路由与视图 227

(9) router.afterEach(hookFunction)

该方法用来全局注册后置钩子函数,该钩子会在每次canDeactivate和canActivate钩子被 resolve之后执行,并不能保证所有的activate钩子被resolve。

我们可以用该方法注册多个全局后置钩子,这些钩子会按照注册顺序调用。但和全局前置 钩子不同的是,后一个钩子并不会等前一个钩子执行完才执行,它们是并行执行的。

0 hook.Function(函数)

该函数接受一个transition对象作为参数,但只能从该对象访问from和to属性,这两个属 性分别是当前和将要切换到的路由对象。在后置钩子中,transition对象没有提供任何控制路由 流程的方法。关千transition对象请参阅"transition对象"部分。

14.5 组件路由配宣

在vue-router应用中,每一个路由对应一个组件,在路由组件中我们可以配置route字段来 实现在路由切换的各个阶段对组件进行更好的控制：

var Message= Vue.extend({ route: {

canActivate: function (transition) { transition.next()

))

以上示例中,route对象中的canActivate方法用来在组件即将切入之前判断是否可以激活, 只有可以激活才会成功切入。在route对象中还可以配置其他阶段的钩子方法,以便更好地控制 切换流程。

14.5.1 路由切换的各个阶段

vue-router将路由切换分为三个阶段。为了更好地理解各个阶段完成的工作,我们先假定当 前匹配的路径为／a/b/c,此路径对应三个嵌套的router-view,如图14-1所示。

如图14-2所示,当用户接下来要访问的路径是a/die时,我们需要从a/b/c路径对应的组件 树切换到a/die对应的组件树。

228

Vue.js权威指南

Path: a/b/c

GO勹

c ／

。

b

thAOQ a

p

二》

e ／

h丿00 t

a

p

图14-1

路径a/b/c对应的嵌套组件树

图14-2

a/b/c和a/die对应的组件树

在以上路由切换过程中,我们需要做以下工作：

0可以重用组件A,因为重新渲染后,组件A依然保持不变。 0需要停用并移除组件B和C。

0启用并激活组件D和E。

0在执行步骤2和3之前,需要确保切换效果有效,也就是确保切换中涉及的所有组件都 能按照所期望的那样被停用／激活。

使用vue-router,我们可以通过实现切换钩子函数来控制这些步骤。在讲解如何做的细节之 前,我们先来了解一下大局。

路由切换的各个阶段如下：

1.

可重用阶段

如图14-3所示,检查当前视图结构中是否存 在可以重用的组件。这是通过对比两棵新的组件 树,找出共用的组件,然后检查它们的可重用性 (通过canReuse选项)来判断的。在默认情况下, 所有组件都是可重用的,除非是定制过的。

2.验证阶段

0 0 lc.nReuge, o o

O O

如图14-4所示,检查当前组件是否能够停用, 图14-3 可重用阶段

以及新组件是否可以被激活。这是通过调用路由配置阶段的can Deactivate和canActivate钩子函

第14章

路由与视图

229

数来判断的。

注：canDeacti v ate按照从下至上的冒泡顺序检查,

而canActivate则是从上至下。

3. canDeactivate

2. canoe釭tiva1e

丿) ..

.... ..

.. ..

．．

"．：．

。 ... o

丿

.0

4, canActivate

5. canActivate

图14-4

验证阶段

任何一个钩子函数都可以终止界面切换。如果在验证阶段终止了界面切换,路由器会保持 当前应用状态,恢复到前一个路径。

3.激活阶段

如图14-5所示,一旦所有的验证钩子函数都被调用而且没有终止切换,切换就可以认定是 合法的,路由器则开始禁用当前组件并启用新组件。

7. deactivate

6. deactivate

0丿 ........ ::::.v

气

．．．．．．．．．． 暴· ....

。

0Q

8. activate - > data

9. activate - > data

图14-5

激活阶段

此阶段对应钩子函数的调用顺序和验证阶段相同,其目的是在组件切换真正执行之前提供 一个进行清理和准备的机会。界面的更新会等到所有受影响组件的deactivate和activate钩子函 数执行之后才进行。

230 Vue.js权威指南

data这个钩子函数会在activate之后被调用,或者在当前组件可以重用时也会被调用。 接下来介绍一下在切换过程中各个钩子函数的细节。

14.5.2 各阶段的钩子函数介绍

在路由切换的各个阶段,vue-router都提供了相应的钩子函数,这些钩子函数包括：

0 canReuse

0 canActivate

0 activate

0 data

0 canDeactivate

0 deactivate

可以在实例化组件时在route选项中实现这些钩子函数,代码示例如下：

var Message= Vue.extend(( route: (

canActivate: function (transition) { transition.next()

})

每个钩子函数都会接受一个trans山on对象作为参数,详见14.7节。

1.钩子函数异步resolve

通常我们会在钩子函数中进行一些异步操作,在异步操作被resolve之前,切换会处千暂停 状态。钩子函数resolve遵循以下规则：

O如果钩子函数返回一个Promise对象,则钩子函数何时resolve取决于该Promise何时 resolve。代码示例如下：

route {

activate: function () { //返回Promise对象

第14章路由与视图 231

return new Promise (function (resolve, reject) { if (Math.random()> 0.5) {

// resolved

resolve ('resolved') } else {

// rejected

reject ('rejected') }

))

O如果钩子函数既不返回Promise对象,也没有任何参数,则该钩子函数将被同步resolve。

代码示例如下：

route: {

activate: function (/ *没有参数＊／) {

//如果不返回Promise对象,则同步resolve

O如果钩子函数不返回Promise对象,但是有一个参数(transition),则钩子函数会等到 trans山on.next()、transition.abort()或transition.redirect()之一被调用时才resolve。代码示 例如下：

route: {

activate: function (transition) { II 1秒后resolve

setTimeout(transi七ion.next, 1000)

0在验证类钩子函数如canActivate、canDeactivate以及全局beforeEach钩子函数中,如果 返回值是一个布尔值(Boolean),也会使得钩子函数被同步resolve。

2.在钩子函数中返回Promise对象

0当在钩子函数中返回一个Promise对象时,系统会在该Promise被resolve之后自动调用

transition.next。

O如果Promise在验证阶段被reject,系统会调用transition.abort。

232 Vue.js权威指南

O如果Promise在激活阶段被reject,系统会调用transition.next。

0对千验证类钩子函数(canActivate和canDeactivate),如果Promise被resolve之后的值 是假值(falsy value),系统会中断此次切换。

O如果一个被reject的Promise抛出了未捕获的异常,这个异常会继续向上抛出,除非在 创建路由器时启用了参数suppressTransitionError。

3.钩子函数合并

和组件本身的生命周期钩子函数一样,以下路由生命周期钩子函数：

0 data

0 activate

0 deactivate

也会在合并选项时(扩展类或使用mixins)被合并。举例来说,如果组件本身定义了一个路由 data钩子函数,而这个组件所调用的mixin也定义了一个路由data钩子函数,则这两个钩子函 数都会被调用,并且各自返回的数据将会被最终合并到一起。

需要注意的是,验证类钩子函数如canActivate、can Deactivate和canReuse在合并选项时会 直接被新值覆盖。

4.钩子函数介绍

(I) canReuse

该钩子函数用来判断组件是否可以重用。若可以重用,则不会创建新的组件实例,只会调 用data钩子函数来更新数据,而不会调用其他钩子函数;若不可重用,则会创建新的组件实例, 此时各个钩子函数都会被调用。

canReuse可以是一个布尔值或者同步返回布尔值的函数,默认值为true。当其为函数时, 可接受一个参数：

0 transition(可选,对象)

在canReuse钩子函数中只能访问trans山on.to和transition. from,详见"trans山on对象"部分。 必须返回布尔类型,其他等效假值会按false对待。

第14章路由与视图 233

注意：实际上判断组件是否可重用不仅仅依赖该钩子函数的值,当根路径不一样时,不论 canReuse钩子函数是否可重用,组件都会被重新实例化,各个阶段的钩子函数都会被调用。只 有当前路径和目的路径有共同的根路径时,canReuse钩子函数才会起作用。

(2) canActivate

在验证阶段,当一个组件将要被切入时被调用。该函数可以接受一个参数： 0 transition(可选,对象)

调用trans山on.next()可以resolve该钩子函数,调用trans山on.abort()可以取消此次切换。详 见"transition对象"部分。

可以返回Promise对象,以下是等价的Promise和transition操作：

resolve(true) -> transition.next()

resolve(false)->七ransi七ion.abcr七()

reject(reason) -> transi巨on.abort(reason)

或者返回布尔值,以下是等价的布尔值和transition操作：

true-> transition.next() false-> transition.abort()

该钩子函数的调用顺序是从上至下。子级组件视图的canActivate钩子函数仅在父级组件的 canActivate被断定(resolved)之后调用。

(3) activate

在激活阶段,当组件被创建而且将要切换进入时被调用。该函数可以接受一个参数： 0 transition(可选,对象)

调用transition.next()可以resolve该钩子函数,调用transition.abort()不可以取消此次切换, 因为在执行到该钩子函数时验证已经合法了。详见"transition对象"部分。

可以返回Promise对象,以下是等价的Promise和trans山on操作：

resolve-> transi巨on. next ()

rejec七(reason) -> transi七ion.abort(reason)

该钩子函数用来控制视图切换和数据获取的时机。在该钩子函数被resolve之后,会同时进 行视图的切换和data钩子函数的调用。

234 Vue.js权威指南

该钩子函数的调用顺序是从上至下。子级组件视图的activate钩子函数仅在父级组件的 activate被断定(resolved)之后调用。

(4) data

在激活阶段,activate钩子函数被resolve时调用,用于加载和设置当前组件的数据。该函 数可以接受一个参数：

0 trans山on(可选,对象)

调用transition.next(data)会为组件的data相应属性赋值。例如使用{ a: I, b: 2 },路由会调用 cornponent.$set('a', 1)以及cornponent.$set('b', 2)。

可以返回Promise对象,以下是等价的Promise和transition操作：

resolve(data) -> transition.next(data)

reject(reason) -> transi巨on.abort(reason)

data钩子函数会在activate被断定(resolved),以及界面切换之前被调用。切换进来的组件 会得到一个名为$loadingRouteData的元属性,其初始值为true,在data钩子函数被断定后会被 赋值为false。这个属性可用来对切换进来的组件展示加载效果。

data和activate钩子函数的不同之处在于：

data在每次路由变动时都会被调用,即使当前组件可以被重用,但是activate仅在组件是新 创建时才会被调用。

假设有一个组件对应千路由/message门d,当前用户所处的路径是/message/I。当用户浏览 /message/2时,当前组件可以被重用,所以activate不会被调用。但是我们需要根据新的id参数 去获取和更新数据,所以在大部分情况下,在data中获取数据比在activate中更加合理。

activate的作用是控制切换到新组件的时机。data钩子函数会在activate被断定(resolved) 以及界面切换之前被调用,所以数据的获取和新组件的切入动画是并行进行的,而且在data被 断定(resolved)之前,组件会处千"加载"状态。

从用户体验的角度来看一下两者的区别：

如果等到获取到数据之后再显示新组件,用户会感觉在切换前界面被卡住了;相反(指不 用等到获取数据后再显示组件),应立刻响应用户的操作,切换视图,展示新组件的"加载"状 态。如果我们在CSS中定义好相应的效果,这正好可以用来掩饰数据加载的时间。

第14章路由与视图 235

这么说的话,如果想等到数据获取之后再切换视图,则可以在组件定义路由选项时,添加 waitForData: true参数。代码示例如下：

//调用trans].tion.next route: {

data: funct].on (transition) { setT].meout(funct].on () {

transit].on.nex七({

message:'da七a fetched!' })

}, 1000)

<!"－－在模板中使用$loadingRouteData --> <div class="view">

<div v-if="$loadingRouteData">Loading... </div> <div v-if="!$loadingRou七eData">

<user-profile user="{{user))"></user-prof工le> <user-post v-repeat="post in posts"></user-post>

</div> </div>

(5) canDeactivate

在验证阶段,当一个组件将要被切出时被调用,用来验证该组件是否可以被卸载。该函数 可以接受一个参数：

0 transition(可选,对象)

调用transition.next()可以resolve该钩子函数,调用trans山on.abort()可以取消此次切换。详 见"transition对象"部分。

可以返回Promise对象,以下是等价的Promise和transition操作：

resolve(true) -> transition.next() resolve (false) -> transition. abort()

reject(reason) -> trans工七ion.abort(reason)

或者返回布尔值,以下是等价的布尔值和transition操作：

true-> transit工on. next () false-> transition.abort()

236 Vue.js权威指南

该钩子函数的调用顺序是从下至上。组件的canDeactivate钩子函数仅在子级组件的 canDeactivate被断定(resolved)之后调用。

(6) deactivate

在激活阶段,当一个组件将要被禁用和移除时被调用。该函数可以接受一个参数：

0 transition(可选,对象)

调用transition.next()可以resolve该钩子函数,调用transition.abort()不可以取消此次切换, 因为在执行到该钩子函数时验证已经合法了。详见"transition对象"部分。

可以返回Promise对象,以下是等价的Promise和trans山on操作：

resolve-> transition.next()

reJect(reason) -> transition.abort(reason)

在该钩子函数被resolve之后,新组件的activate钩子函数会被调用。

该钩子函数的调用顺序是从下至上。父级组件的deactivate钩子函数仅在子级组件的 deactivate被断定(resolved)之后调用。

14.6 路由匹配

vue-router做路径匹配时支持动态片段、全匹配片段以及查询参数(片段指的是URL中的 一部分)。对千解析过的路由,这些信息都可以通过路由上下文对象(从现在起,我们会称其为 路由对象)访问。在使用了vue-router的应用中,路由对象会被注入每个组件中,赋值为 伽s.$route,并且当路由切换时,路由对象会被更新。

14.6.1 动态片段

动态片段使用以冒号开头的路径片段定义,例如在user/:usemame中, username就是动态 片段,它会匹配注入／user/foo或者／user/bar之类的路径。当路径匹配一条含有动态片段的路由规 则时,动态片段的信息可以从$route.params中获得。代码示例如下：

router.map ({ '/user/:username': { component: {

第14章路由与视图 237

template: '<p>用户名是{{$route.params.username))</p>'

一条路径中可以包含多个动态片段,每个片段都会被解析成$route.params的一个键值对。

14.6.2 全匹配片段

动态片段只能匹配路径中的一部分,而全匹配片段则基本类似千它的贪心版。例如,／foo/*bar 会匹配任何以／foo／开头的路径。匹配的部分也会被解析成$route.params的一个键值对。

因为"*"可以匹配任何路径,所以我们可以用它来匹配默认路由。代码示例如下：

router. map ({

'*': {

componen七： {

template:'<p>default view</p>'

当所有路由都不匹配时,会默认匹配"*"对应的路由。

14.6.3 具名路径

在有些情况下,给一条路径加上一个名字能够让我们更方便地进行路径跳转。我们可以按 照下面的示例给一条路径加上名字：

router.map ({

'/user I: user Id': {

name: 'user', //给这条路径加上一个名字 component: {... }

})

可以用v-link链接到该路径,代码示例如下：

<av-link="(name:'user', params: (userid: 123))">User</a>

同样的,也可以用router.go()切换到该路径,代码示例如下：

router.go({ name:'user', params: { userid: 123 }})

以上两种情况,路由最终都会切换到／user/123。

238 Vue.js权威指南

14.6.4 路由对象

路由对象$route存储了当前路由的信息,包括以下属性：

0 path一字符串,等千当前路由对象的路径,会被解析为绝对路径,如"/foo/bar"。

0 params 对象,包含路由中的动态片段和全匹配片段的键值对,详情见14.6.1节和

14.6.2节。

0 query一对象,包含路由中查询参数的键值对。例如,对千／foo?user=l,会得到

$route.query.user== 1。

0 router-—管理当前路由器的vue-router实例。

0 matched一数组,包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。

0 name 字符串,当前路径的名字(请参阅14.6.3节)。

除了内置属性,在用router.map配置路由映射规则时定义的字段也会复制到最终的路由对 象上。代码示例如下：

router.map ({

'／

user': {

auth: true, component: {

七empla七e: , <p>用户名是{{$route.params.username}}</p>'

在/user被匹配时,当前路由对象$route.auth的值是true。基千此,我们可以在全局钩子函 数中进行身份验证。代码示例如下：

router.beforeEach(function (transi七ion) { 1f (七ransition.to.auth) {

//对用户身份进行验证．．．

}}

第14章路由与视图 239

14.7 transition对象

每个钩子函数都会接受一个trans山on对象作为参数。transition对象并不是动画对象,它提

供了很多方法来控制路由切换的时机。该对象包含以下属性：

0 to(路由对象)一一表示将要切换到的路由对象。关千路由对象请参阅14.6.4节。 0 from(路由对象)一—表示当前路径的路由对象。

0 next(函数)——－调用此函数处理切换过程的下一步。

0 abort(函数)一一调用此函数来终止或者拒绝此次切换。 0 redirect(函数) －－取消当前切换并重定向到另一个路由。

14.8 嵌套路由

嵌套路由和嵌套组件之间的匹配是—个很常见的需求,使用vue-router可以很简单地实现 这个需求。

假设有一个应用,代码示例如下：

<div id="app"> <router-view></router-view> </div>

<router-view>是一个顶级的外链,它会渲染一个和顶级路由匹配的组件。代码示例如下：

router. map ({ '/foo': {

II路由匹配到／foo时,会渲染一个Foo组件

component: Foo

同样的,在组件内部也可以包含自己的外链,嵌套的<router-view>。例如,我们在组件Foo 的模板中添加了一个<router-view>,代码示例如下：

var Foo; Vue.extend({ template:

'<div class;"foo">'+

240 Vue.js权威指南

'<h2>This is Foo!</h2>'+

'<router-view></router-view>'十// <－嵌套的外链 '</div>'

))

为了能够在这个嵌套的外链中渲染相应的组件,我们需要更新路由配置。代码示例如下：

router.map ({

'/foo': { component: Foo,

II在／foo下设置一个子路由 subRoutes: {

'lbar': {

//当匹配到／foolbar时,会在Foo的<router-view>内渲染 II一个Bar组件

component: Bar },

'/baz': {

II Baz也是一样的,不同之处是匹配的路由会是／foolbaz

componen七：Baz

使用以上配置,当访问／foo时,Foo的外链中不会渲染任何东西,因为在配置中没有任何 子路由匹配这个地址。或许我们想渲染一些内容,此时可以设置一个子路由匹配"I"。代码示 例如下：

router. map ({

'/foo': { component: Foo,

//在／foo下设置一个子路由 subRoutes: {

'I': {

//当匹配到／foo时,会在Foo的<router-view>内渲染 component: Default

},

'/bar': {

//当匹配到／foo/bar时,会在Foo的<router-view>内渲染 //一个Bar组件

第14章路由与视图 241

component: Bar

),

'/baz': {

II Baz也是一样的,不同之处是匹配的路由会是／foolbaz component: Baz

))

14.9 动态加载路由组件

当我们使用Webpack或者Browserify时,在基于异步组件编写的Vue项目中也可以较为容 易地实现惰性加载组件。不再是之前所述的直接引用一个组件,现在需要像下面这样通过定义 一个函数返回一个组件。代码示例如下：

router. map ({ '/async': {

component: func巨on (resolve) {

// MyComponent通过Require JS从服务端加载 resolve(MyComponent)

Webpack已经集成了代码分割功能,我们可以使用AMD风格的require来标识代码分割点。

代码示例如下：

require (['. /MyComponent. vue'], function (MyComponent) { //执行MyComponent组件加载完后的逻辑

})

和路由配合使用,代码示例如下：

router. map ({ '/async': {

component: function (resolve) {

require (['. /MyComponent. vue'], resolve)

})

242 Vue.js权威指南

现在,只有当／async需要被渲染时,MyComponent.vue组件才会自动加载它的依赖组件, 并且异步加载进来。

14.10 实战

在学习了vue-router应用的基本组成之后,现在我们运用所学到的知识来进行实战。首先 我们会看一个直接在浏览器中引用相关文件的完整实例,接下来会基于Webpack构建工具做一 个动态加载路由组件的高级实例。

14.10.1 浏览器直接引用

为了便千理解,我们会在一个HTML文件中完成实例分析。代码示例如下：

<!DOCTYPE html>

<html lang="en"> <head>

<meta charset="UTF-8">

<title>vue router demo</t工tle> <style>

.v-link-active { color: green;

</style> </head> <body>

<div id="app"></div>

<script src="/vue/1.0.24/vue.min.js"></script>

<script src="/vue-router/0.7.13/vue-router.min.js"></script> <'－－根组件模板－－>

<script type="text/vue-tempalte" id="rootTemplate"> <div class="wrapper">

<div class="nav">

<a v-link="{path:'/home')">Home</a> <a v-link=" {path:'/about') ">About</ a> </div>

<div class="router-view"> <router-view></router-view> </div>

第14章路由与视图 243

</div> </script> <script>

II路由组件定义,路由组件可以是通过Vue.extend创建的构造函数,或者是 个组件配置对象 //当为组件对象时,vue-router内部会自动调用Vue. extend创建构造函数

//构造函数形式

var Home ; Vue. extend ({

template:'This Is Home Page' })

//组件配置对象形式

var About; (

七emplat.e:'This Is About Page'

//根组件,VueRouter实例会用此根组件来启动应用

var App = Vue. extend ({

templa七e: document.querySelector('#rootTemplate').textContent ))

//实例化VueRouter

var router= new VueRouter()

II路由映射配置

router. map ({ '/home': { component: Home ),

'/about': { component: About

)) /*

以上路由映射等价于通过此种方式调用,实际上调用

router.map时在vue-router内部会对每个键值对 调用router.on方法来完成路由规则映射

router.on( '/home',

component: Home

,

,_, ,

router.on(

244 Vue.js权威指南

'/abou七',

component: About

*/

//默认访问重定向到／home

router.redirect(( 'I':'/home'

))

router. start (App,'#app') </script>

</body>

</html>

14.10.2 Webpack模块化开发

当项目变得非常复杂时,很有必要采用模块化方式来开发。通常我们会用Webpack将各路 由组件直接打包到一个文件中,实际上这种方式会导致不必要的代码被加载,因为有些模块用 户可能不会访问到。

对千以上问题,我们可以结合Webpack的代码分割以及Vue组件的resolve来实现只有当 用户访问某一个路由时,才去服务端获取相应的组件代码。这样做可以加快页面渲染速度,同 时可以节省流量。下面我们来看看具体如何实现以上需求。

首先我们来看看目录结构：

example

I- componen七s I- about.vue I- home.vue

I- not-found.vue I- app.vue

I- index.html I- index.js

I- router-config.js I- package.Json

I- webpack.config.Js

第14章路由与视图 245

各目录及文件含义如下：

0 components目录用来存放各个路由组件模块。

0 app.vue是应用的根组件,vue-router用该组件来启动路由应用。 0 index.html是项目的入口HTML文件。

0 index.js是项目的入口JS文件。

0 package.json是npm包信息文件。

0 router-config.js包含路由配置规则。

0 webpack.config.js是Webpack构建工具的配置文件。 接下来我们按源码执行顺序来进行解析。

index.html路由应用的入口页面,定义了根组件挂载的元素,以及引入Webpack打包后的 JavaScript文件。代码示例如下：

<!--example/index.html--> <!DOCTYPE html>

<html lang="en">

<head>

<meta charset="UTF-8">

<巨tle>vue-loader advanced example<／七itle> </head>

<body>

<'－－用来挂载根元素－－>

<div id="app"></div>

<script src="/build/build.js"></script> </body>

</html>

build.js是源码打包后的入口文件,实际上源码入口是index.js。

index」s用来引入Vue.js和vue-router,实例化并启动路由应用,是整个应用的JS入口。

// example/index.JS

//注意：依赖Vue.js 0.12.10及以后版本 //加载Vue. j s和vue-router

var Vue = require ('vue') ;

var VueRouter = require('vue-router');

246 Vue.js权威指南

var configRouter = require('./router-config');

//这里必须调用Vue.use方法来安装vue-router插件,因为使用CommonJS规范 II Vue对象不会暴露为window对象的属性,因此vue-router没法自动安装 Vue.use(VueRouter)

//创建router实例

var router= new VueRouter({ }) ;

//用来配置路由映射规则

configRouter(router)

//启动主组件,以此来启动整个路由应用

var App= require('./app.vue'); router. start (App,'#app');

router-config.js用来配置路由映射规则、重定向、别名、全局钩子函数等,并利用Webpack 的代码分割功能和vue-router的组件动态resolve的功能提供组件的动态加载。

注意源码中如require (['./components/home.vue'], resolve)是Webpack提供的代码分割语法, 采用AMD形式：

require(['./asyncModule'], function (module) ( module.doSomething()

也就是说,Webpack在编译时遇到以上AMD语法,并不会直接加载asyncModule源码, 而是在浏览器中执行到此处时,才会去服务端动态加载,加载完后会执行回调方法,回调接受 的参数是请求的module。

在vue-router中,假如组件定义时component字段是一个方法,而不是对象或Vue组件构 造函数,那么此方法的参数是一个resolve方法。结合Webpack的代码分割功能,将resolve作 为require的回调,那么当用户访问一个本地没有的路由组件的路由时,Webpack首先会去服务 端请求该路由组件模块,请求完之后会执行resolve回调,在resolve回调中,vue-router会将该 组件渲染出来。

// exarnple/router-config.Js

rnodule.expor七s = function configRouter (router) {

//定义路由映射规则

router.map ({

//常规组件(一级组件)

'/home': {

第14章路由与视图 247

component: function (resolve) { require(['./components/home.vue'], resolve)

),

//常规组件(一级组件) '/about': {

component: func巨on (resolve) { require(['./components/about.vue'], resolve)

},

//未匹配时的路由组件

'*': {

component: func巨on (resolve) {

require (['. / componen七s/not-found.vue'], resolve)

})

II路由别名配笠

router.alias({ 'lhomelalias':'lhome'

})

II路由重定向

router.redirect({ 'I':'lhome'

))

//全局前罚钩子函数,在路由开始切换前执行,优先千路由组件钩子函数

router.beforeEach (function (transition) { // transition.to表示将要跳转到的路由对象

// transition.from表示当前路由对象

1.f (transi巨on.to.path==='/forbidden') { router.app.authenticating = true setTimeout(() => { router.app.authenticating = false

//终止路由切换,应用保待

transition. abort() ), 3000)

) else { transition.next()

})

248 Vue.js权威指南

在以上路由定义中,require了根目录下的app.vue和components目录下的home.vue、

about.vue、not-found. vue四个组件定义文件,每个文件都代表一个路由组件模块。下面我们看 看路由组件的定义。

app.vue定义了根组件,该组件定义了v-link导航部分以及根视图router-view,一级组件都 会渲染到该router-view中。

II examplelapp.vue <style> .v-link-active {

color: green;

[v-cloak] { display: none;

</style> <template>

<div class="wrapper"> <div class="nav">

<a v-link="{path:'/horne'}">Horne</a> <a v-link="{path:'/about'}">About</a> </div>

<div class="router-view">

／

<router-view></router-view>

</div>

</div>

</template>

<script>

module.exports= {}

</script>

home.vue、about.vue、not-found.vue三个都是路由组件,是平行关系,这里主要以home.vue 组件来进行分析。

home.vue组件匹配path值为／home。在组件的配置对象中,除了常规Vue」s组件的属性外, 还可以传入路由配置对象route属性,用来控制路由切换过程中的各个阶段。route是一个对象, 它可以接受5个钩子函数属性分别用来控制切换时的5个阶段。

第14章路由与视图 249

// exarnple/cornponents/horne.vue <template>

This Is {{ti七le)) Page </ternpla七e>

<script>

//组件配罪对象

module.exports= {

II路由配笠对象

route: { ／ ＊ ＊

＊判断组件是否可重用

＊只有当前组件和要切换到的组件的根路径相同时才会调用该钩子函数

＊／

canResuse: function () { return true;

),

／＊＊

＊从其他路由切换到该组件时,会调用此钩子函数判断

＊可否切换到该组件,当该组件返回true或者被resolve时 ＊才会认为可切换到此组件,否则将会取消路由切换,同时

＊停止执行之后的钩子函数

*/

canActi vate: function () { return true;

},

／＊ ＊

＊被resolve后视图开始切换的同时会调用

＊注意：当组件可重用时,不会触发该钩子函数

＊／

activate: function() { var self= this;

this. timer = setTimeout (function () { self.counter+= l;

l, 3000);

},

／＊ ＊

* activate被resolve后,调用该函数获取数据 */

data: function () {

250 Vue.js权威指南

return { counter: 0

) ; ),

／ ＊ ＊

* canDeactivate被resolve后调用该函数,可以在 ＊函数中进行一些组件移除前的清理工作,如移除

＊定时器等

＊ ／

deactivate: function () {

//清理ac巨vate钩子函数中的定时器 clearTimeout(this.timer);

},

//组件初始化时数据

data: function () { return { title:'Home', counter: 0

</script>

14.11 常见问题解析

1. saveScrollPosition不生效

有时候我们希望在路由视图切换后,切换进来的视图保待在最后一次停留的位置。根据官方 文档,我们需要在实例化vue-router时设置saveScrollPosition参数值为true。但是当设置该参数值 为true时,点击v-link元素导航切换到新视图,发现视图并没有停留在最后一次出现的位置。

对千这个问题,我们需要知道：

0 saveScrollPosition只在HTML5模式下生效,在实例化vue-router时,需要同时设置history 值为true。代码示例如下：

var rou七er= new VueRouter({ saveScrollPosition: true,

第14章路由与视图 251

II设置为HTML5模式 history: true

})

0视图位置重置只发生在用户点击浏览器后退按钮时,因为在vue-router中通过监听 HTML5 history的popstate事件来重置视图位置。因此在点击v-link元素切换视图时, 视图位置不会发生重置。

通过实际测试发现,在HTML5模式下尽管saveScrollPosition参数值为falseO,但是对千 Chrome和Firefox浏览器在点击前进、后退按钮时视图位置也会被重置为最后一次出现的位置 (浏览器特性)。

2.监听不到查询参数

有时候我们需要改变hash地址中的查询参数,比如从＃1/books/search?cat= 1到 #!/books/ search? cat=2。这时我们希望根据新的cat参数重新向服务端获取数据。因为此时只有 查询参数发生了变化,vue-router认为组件是可重用的,所以只会执行data钩子函数。因此,我 们需要在data钩子函数中执行相应的逻辑。代码示例如下：

var Search= Vue.extend({ route: {

data: function (transition) { console.log(this.$route.pararns.cat)

})

3.判断当前路径和目的路径

有时候我们需要根据当前路径和将要跳转到的路径来决定下一步的操作,这时可以在全局 钩子函数beforeEach中进行判断。代码示例如下：

var router= new VueRouter()

router.beforeEach(function (transi七ion) { //七ransition.from为当前路由对象

辽(transi巨on.from.path==='/noleaving') { console. log ('can not leave /noleaving')

II取消此次路由切换,停留在当前页面

transit].on.abort() return

// transition.to为目的路由对象

252 Vue.js权威指南

lf (七ransition.to.path ==='/forbidden') { console. log ('can no七go to /forbidden')

//取消此次路由切换,停留在当前页面

transition.abort() return

transition.next()

})

关千transition对象请参阅14.7节。 4.切换路由时修改页面标题

通常在切换路由改变视图后需要更新页面标题,这里我们介绍一下使用afterEach全局钩子 函数来更新页面标题的方法。代码示例如下：

II路由组件定义,路由组件可以是通过Vue.extend创建的构造函数,或者是一个组件配甡对象 //当为组件对象时,vue-router内部会自动调用Vue.extend创建构造函数

//构造函数形式

var Home~ Vue.extend({ template:'This Is Home Page' }) ;

//组件配置对象形式

var About= (

templa七e:'This Is About Page' ) ;

//根组件,Vue Router实例会用此根组件来启动应用

var App= Vue.extend({

template: document.querySelector('#rootTemplate').textContent )) ;

//实例化VueRouter

var router= new VueRouter()

II路由映射配罚

rou七er.map ({ 'lhome': ( component: Home,

//组件对应的页面标题

docTitle:'Home Page' },

'/about': {

component: About, docTitle:'About Page'

第14章路由与视图 253

))

//该钩子泊数在目的路由canActivate被resolve之后执行 router.afterEach(function(七ransi七ion) {

// transition.to为目的路由映射对象 document.title= transition.to.docTitle })

//启动vue-router app router.start(App,'#app')

5. canReuse配置无效

在14.5.1节中我们了解到,第一阶段为组件可重用阶段。在这个阶段中,vue-router首先会 判断两个路由有无相同的根组件,如果没有则认为不可复用,而不管canReuse的值是否为true。 如果有相同的根组件,才会进一步判断用户设置的canReuse的值。判断组件是否可复用流程如 图14-6所示。

图14-6 判断组件是否可复用流程图

第15章

vue-cli

使用Vue.js开发大型应用时,我们需要考虑代码目录结构、项目构建和部署、热加载、代 码单元测试等事情。如果每个项目都要手动完成这些工作,那无疑效率是低下的,所以通常我 们会使用一些脚手架工具来帮助完成这些事情。在Vue.js生态中我们可以使用vue-cli脚手架工 具来快速构建项目。

15.1 安装

vue-cli是用node编写的命令行工具,我们需要进行全局安装。打开命令行终端,输入如下 命令：

$ npm install -g vue-cli

注：请确保node版本为4.x、5.x及以上。 安装完成后执行如下命令：

$ vue -V

如果能显示vue-cli的版本号,则表示安装成功,如图15-1所示。

图15-1 查看vue-cli版本号

15.2 基本使用

我们可以使用vue-cli来快速生成一个基于Webpack构建的项目。打开命令行终端,输入如 下命令：

$ vue init webpack my-project

第15章vue-cli 255

执行命令后,会有一些命令行交互,我们可以初始化一些项目信息,如图15-2所示。

图15-2 vue-cl i init命令初始化项目

项目初始化完成后,会在当前目录下生成my-project目录。进入my-project目录,安装项 目的依赖,执行如下命令：

$ npm install

依赖安装完成后,我们来看一下项目的目录结构,如下所示：

I-my-project I - build

I- config

I- node modules 1-src

I- assets

I- components I- App.vue

I- main.js

I- static 1- test

I- indext.html

I-.eslin七re. j s I- package.json

I-.

(构建脚本目录) (构建配咒目录)

(依赖的node工具包目录) (源码目录)

(资源目录)

(组件目录)

(页面级Vue组件)

(页面入口JS文件) (静态文件目录)

(测试文件目录)

(入口页面)

(ES语法检查配置) (项目描述文件)

我们启动项目,执行如下命令：

$ npm run dev

打开浏览器,输入h ttp://localhost:8080,生成的页面如图15-3所示。

256 Vue.js权威指南

Hello World!

Welcome to your Vue.js appl

To get a better understanding of how this boilerplate works, check out Its

1. It is also recommended to go through the docs for Webpack and If you have any issues with the setup, please file an issue at this

boilerplate's repository.

You may also want to checkout vue-router for routing and vuex for state management

图15-3 vue-cli脚手架生成的初始页面

接下来我们打开src/components/Hello.vue,修改一行代码,如下所示：

export defaul七( data {) {

return {

// note: changing this巨ne won't causes changes

// with hot-reload because the reloaded component // preserves its current state and we are modifying // its initial state.

msg:'Hello DDFE I'

然后刷新浏览器,可以看到内容发生了变化,如图15-4所示。

图15-4 vue-cli修改代码后的页面

第15章vue-cli 257

我们可以根据项目需求做任何修改,可以在脚手架的基础上构建任何复杂的应用。

15.3 命令

vue-cli安装后的全局命令是vue,它支持以下两个子命令：

$ vue init<七empla七e-name><project-name> $ vue list

15.3.1 init

init命令用来基千指定模板生成项目结构。其中template-name为模板名,project-name为要 生成的目录名。关千模板请参阅15.4节。

15.3.2 list

list命令用千列出所有可用的模板,通过查询https://api.github.com/users/vuejs-templates/repos 这个API接口可以得到所有列表。源码实现如下：

<!" －－源码目录bin/vue-list-->

request(( url:'https://api.github.com/users/vuejs-templates/repos', headers: (

'User-Agent':'vue-cli'

), funct~on (err, res, body) { 辽(err) logger.fatal(err)

console. log ('Available official templates:') console. log ()

JSON. parse (body). for Each (function (repo) {

console.log(

''+ chalk. yellow ('*') + ''+ chalk.blue(repo.name) + '-'+ repo.description)

)) ))

258 Vue.js权威指南

15.4 牛莫木反

vue-cli是一个项目脚手架工具,它支待通过模板来生成项目结构。在15.3节中,我们了解 到在执行init命令时可以指定模板的名字。在默认情况下,vue-cli会根据所传入的模板名字去 github中查找模板。

vue-cli的模板分为官方模板、自定义模板和本地模板。

注：所有模板默认对应2.0版本,要安装1.0版本的模板,可以用vue-cli init webpack-simple #1.0 my-project这样的语法。

15.4.1 官方模板

在使用之前,可以先用vue list命令查询都有哪些模板可供使用,之后通过vue init命令来 生成相应模板的项目结构。模板分为基础和高级两个版本,其中基础版本用千快速构建原型; 高级版本用千正式开发。所有模板都支持＊vue组件。

目前官方提供了以下模板：

0 Browserify 拥有高级功能的Browserify +\'Ueify用于正式开发。

0 browserify-simple 拥有基础功能的Browserify + vueify用千快速开发。

0 browserify-simple-2.0 拥有基础功能的Browserify +\'Ueify用千Vue.js 2.0快速开发。

0 simple 单个HTML,用千开发最简单的Vue.js应用。

0 simple-2.0—单个HTML,用千开发最简单的Vue.js 2.0应用。

0 webpack 拥有高级功能的Webpack + vue-loader用于正式开发。

0 webpack-simple 拥有基础功能的Webpack +,'lJe-loader用千快速开发。

0 webpack-simple-2.0 拥有基础功能的Webpack + vue-loader用千Vue.js 2.0快速开发。

15.4.2 自定义模板

当官方模板不能满足需求时,我们可以fork官方模板按照自己的需求修改后,通过vue-cli 命令生成基于自己模板的项目结构：

$ vue init username/repo my-project

第15章vue-cli 259

15.4.3 本地模板

除了从github下载模板外,我们还可以从本地加载模板：

$ vue init ~Ifs/path/to-custom-template my-project

15.5 不错的工具包

vue-cli内部使用了很多第三方npm包来帮助自己实现一些基础功能。接下来我们介绍其中 一些不错的工具包。

15.5.1 commander

commander是一个命令行接口的解决方案,它提供了一些接口方便我们对命令行的命令做 解析。

仓库地址：https://github.com/tj/commander.js 15.5.2 download-git-repo

download-git-repo用来将相应的git库(GitHub、GitLab、Bitbucket)下载到指定的本地 文件夹。

仓库地址：https://githu b.corn/tl ipxfx/download-git-repo

15.5.3 inquirer

inquirer是一个常见的交互式命令行用户页面的集合,它可以简化以下流程： O提供错误反馈。

0询问问题。

0解析输入。

O验证结果。

仓库地址：https://github.com/SBou如as/lnquirer.J s

260 Vue.js权威指南

15.5.4 ora

Ora可以让我们在终端展示加载效果,如图15-5所示。

图15-5 ora加载效果 仓库地址：https://github.com/sindresorhus/ora

第16章

测试开发与调试

任何实际项目的开发都不仅仅是完成编码,规范的开发流程和严谨的测试都是不可或缺的。

合理使用各种工具来进行测试开发与调试,能够极大地提升编写代码的效率,使开发过程事半 功倍、对千提高代码质量、稳定线上服务至关重要。

Vue.js除了是一个前端类库之外,还开发了许多配合使用的工具。比如Chrome下的调试工 具、编辑器下的高亮工具等。正是这样一个完整的生态环境,使得用Vue.js开发变得更加简便。 本章将为大家介绍几个常用的配合Vue.js使用的工具。

16.1 测试工具

16.1.1 ESLint

在日常的团队开发中,为了避免出现低级bug和统一代码风格,通常会在开发前约定一套 编码规范。为了保证规范的执行,可以使用Lint工具和代码风格检测工具。

ESLint就是一个Lint工具,它是由JS红宝书的作者Nicholas C. Zakas创立的一个开源项目, 旨在为大家提供一个可扩展、每条规则独立、不内置编码风格的语法检查工具。ESLint有别于 JSLint的地方就是它被设计成完全可配置的,每一条规则都是一个插件,用户完全可以根据自己 的需求来选择使用哪些规则。比如报错就可以设计为"警告"和"错误"两个等级,或者禁用。

下面介绍一下ESLint的配置。

在项目中配置ESLint有两种基本方法：

0用JavaScript注解的方式将配置信息直接加到文件里。

262 Vue.js权威指南

0使用JavaScript、JSON或YAML文件为整个目录定义配置信息。文件格式可以 是．eslintrc＊或package.json。ESLint会自动查找并读取配置文件。

需要配置的有以下几块信息,所有这些配置都将细粒度地决定ESLint如何检测代码。这里 以JSON格式为例,展示一下基本的配置规则。

1. Enviroments

脚本将要运行的环境,每个环境都有自己预定义好的全局变量集合。通过env关键字配置 Environments选项,下面的配置表示脚本将运行在浏览器(browser)和node环境。还可以配置 Commonjs、jQuery等很多选项。

<!-- package.json -->

"env": {

"browser": true, "node": true

2. Globals

在脚本运行期间需要额外加入的全局变量。当变量在当前文件中未定义却被访问时,会触 发未定义规则警告。因此,如果设置了一些全局变量,则需要在ESLint的配置文件中进行配置。

<!-- package.json -->

"globals": {

"varA": true, "varB": false

上述配置表明varA、varB都是全局变拟,其中varB的值不可写(只读)。 3. Rules

ESLint提供了大量的规则,用户通过配置规则是否生效来定义自己的项目需要使用哪些规则。

<'-- package.json -->

第16章测试开发与调试 263

"rules": {

"eqeqe": "off", "curly": "error"

16.1.2 工具包

1. eslint-loader

配合Webpack使用的ESLint loader。

安装：

$ npm install eslint-loader

使用方法：

<!-- webpack.config.js--> module.exports= {

／ ／

module: { loaders: [

{test: /\.js$/, loader: "eslint-loader",exclude:/node_modules/)

I/...

当使用编译类的loader (bable-loader)时要确保处理顺序正确,从下至上为处理顺序,所 以语法检查要放在最下面。为保险起见,也可以使用preLoaders配置项,确保对源代码在没有 被编译前进行检查。

2. eslint-friendly-tormatter

这个组件可以友好地提示语法问题,并且支持点击错误提示直接打开Sublime或订erm2文 件。它可以被当作一个模块引用,还可以配合gulp或grunt使用。

3. eslint-config-standard

如果觉得自己配置很麻烦,也可以使用这个组件,它为大家提供了一些可共享的JavaScript 标准格式配置。其用法也非常简单,在自己的工程中加入如下．eslintrc文件。

264 Vue.js权威指南

<!--.eslintrc文件－－>

"extends": "standard"

4. eslint-plugin-html

一个支持从HTML等文件的<script>标签中读取配置的插件。通常其配置文件都是JS文件。

16.2 开发工具

16.2.1 Vue Syntax Highlight

开发Vue」s项目时还可能会遇到一个问题,就是vue后缀文件中的内容是不会被自动高亮 显示的,感觉像在日记本里开发一样。不过没有关系,Vue.js团队已经帮助我们开发了可以在 Sublime中使用的插件—一Vue Syntax Highlight。其安装方法如下：

sublime->preference->package-con七rol->package-install->Vue Syntax Highlight

16.2.2 Snippets

Snippets是一个帮助提高开发效率的小工具,通过它可以自动补全,我们只衙输入一些简 写的命令就可以自动生成代码。比如：

db+ Tab-> debugger

cl + Tab -> console. log

在Sublime中可以选择Tools-- New Snippet来添加。在github上有许多别人配置好的文件 可供参考。

< ! -- Snippe七文件的基本格式－－> <snippet>

<content>

<'[CDATA[Hello, ${1:this} is a ${2:snippet}.]]> </content>

<1-- <tabTrigger>hello</tabTrigger> --> <!-- <scope>source.python</scope> -->

</snippet>

<! [CDATA[Hello, $ { 1 :this} is a$ {2:snippet}]]>标签中的是缩写补全后的样子,${I :this}是第

第16章测试开发与调试 265

一个输入点,${2:snippet}是第二个输入点。补全后输入点之间可以通过Tab切换。

比如想快速生成一个包含v-if的div组件,可以进行如下配置：

< ! -- snippet文件配罚示例－－> <snippet>

<conten七>< !" ［CDATA[

<div v-if="${1}">${2}</div> ]]></content> <tabTrigger>v-if</tabTrigger> <scope>七ext.html</scope>

<descripti_on>&l t; div v-if=" "&gt; </description> </snippet>

保存后,就可以通过输入v-if + Tab来获得<div v-if=''></div>了。

16.2.3 其他编辑器／IDE

除了Sublime Text,前端开发利器WebStorm以及微软新推出的风头正劲的编辑器Visual Studio Code也添加了对Vue.js的语法支持。二者同Sublime Text一样,也是通过安装插件的方 式来识别以vue为后缀的文件的。

1. WebStorm

WebStorm中用千支持Vue.js的插件名称就叫Vue.js,安装方式是：Preferences- Plugins­Browse Repositories-Vue.js- Install,如图16-1所示。

安装完Vue.js插件后,重启WebStorm,可以发现,以．vue结尾的文件已经能够被识别,出 现语法高亮显示,如图16-2所示。

从图16-2可以看到,虽然WebStorm已经支持vue后缀文件的语法高亮显示,但是其对文 件中的ES 6语法并不识别,解决方式是在Preferences--+- Editor-- Language Injections中添加一项, 类型为XML Attribute Injection,配置如图16-3所示。

然后在<script>标签中写入type属性,如<script type="es6"></script>即可。如此便可使 WebStorm完成对vue后缀文件的全部识别,如图16-4所示。

266 Vue.js权威指南

Browse Repositories

O Cate9°" AII亨

目礼!"州-

Sort~亨FRAMEWORK INTEGRATIONVue.js

＿

***** 9338 d叩loads Updated 16/3/30,11 0

Support伈,亚即片

Choag• Notn

Fixed autocompletion ro,,eal In叩a貊d.3flIerecogni廿on. Fixed plugln loadlag Issues

Vendor

t:nnm:：：如妇呻严m

S比o 8.6 K

匠

图16-1 WebStorm安装Vue」s插件界面

亡assets		
偷亡components		
,巳libs		
·亡views		
Y about.vue		
荨Index vue		
,,,旧t.vue		7
,,log!n.vue		8
..,.message vue		9
Y new vue	10
Y topic.VU«!	11
Yuser,vue	12
Ii filters.js	13
fimaln.js	14
~ routers.js	15
心gitignore	16
f9 gulpfile.js	17
但Index html	18
8 package.json	19
!i README.md	20
Ii server.Js	21
邑webpack config.js	22
嚼丘temal Ubrariei	23
24
25	
26	
<template>

<!--全局header ->

<div>

<img class="index" src•". </div>

</template>

(scr1pt>

require(•.. /assets/scss/iconfont/iconfont. css ·), require('.. /assets/scss/CV. scss');

require('.. /assets/scss/github-markdown. css'),

export default {

ready.O.i setTimeout(() •({

this >$route参router. go({ name:'list')), }人20001;

}＿

} </script>

<style lang="sass">

index{

width: 100%, background-color: #fff, margin-top: 40%;

)

27 </style>

28

29 |

图16-2 WebStorm识别vue后缀文件

第16章测试开发与调试 267

Q

Appeuance &..havlo• k.ymap

Edlto,

Ceneml

CoIO,s & Fonts Cod, Stylo Inspections
FIi• and Cod• Templat,s FIie Encodings

Live Tomplat,s

FIIeTy"'

Emme1

lmag,s

lnt<ntlons

_,lII隅可矶罚罚开一·

SmIIIng TextMa1. BundI" TOOO

Plugln,

va,.lon Cont,ol

Pro片心Vuo-cnod•J•-m•st•• lulld, Execullon, Deployment Languagu & F,amewo八s ToUs

Edilo,, Languag, lnjmion,

心｀

0 xmI ·l@ref D xml •/@on.• 0 xmI.f@swle D xmi mlpt 0 xm1: sc『lpt6 。盯ml "VI•

XMLAUribule Loe.I nam, Namespace:

+ - ✓ DJ臼口心心巾:•d

Vaiue pattem XPath,ondltion

图16-3 WebStorm识别ES 6语法配置

s s c

n w 。 d k r a m

b

＿ tj

9

fi

sgmdeoni

masnug尸于Vuevue

了厂二三g叩Js.JS.5re."mlkb .nodaHeeom呴啦"TI`YI:Vv三}2DME．三 "isrcgg必臣吵．1gulfPaCREASewee

t 叩vua •• ►·令B@98a日"i

宅＿＿血 L,','

export default { ready (){

setTimeout (() = > {

this. $route. router. go({ name: ·list•)); ),2000);

图16-4 WebStorm识别ES 6语法

除此之外,在WebStorm中对＊js文件的ES 6语法支持设置方式是：Preferences- Languages & Frameworks--+ JavaScript--+ JavaScript language version: ECMAScript 6,如图16-5所示。

268 Vue.js权威指南

．一．

Preferences

Q

Appeuance & Behavlo, JavaScnpt language ve,slon ECMAScnpt 6(iJUses严clal 10-JavaSc,lpt complle,with this vmlon

Keymap

Edlto, P,efe, Stnct mode
Pluglns

, V盯slon Cont,ol Only ty忧－based <ompletlon

P,oject vue-dev

Build, Execution, Deployment Languages & f,amewo,ks

回玉囡蠲-

llb<arles

Code Quality Tools Templates
Bowe,

Yeoman PhoneGap/Cordova Meteor

Schemas and DTDs •
Compass "

Dart坎 Ma,kdown

Node.j, and NPM贮 Template Data Languages P TypeScdpt

XSLT

XSL T File As,ociatlons Tools

Cancel知ply IEII

图16-5 WebStonn支持ES 6语法通用设置 2. Visual Studio Code

在Visual Studio Code(以下简称VSC)中为Vue.js提供语法高亮显示的插件名称为vue, 如图16-6所示。

vue

liu归im I.A. 4019installs I *****(1)

Syntax Highlight for VueJS

Installation

I More Info

图16-6 vsc中的vue插件

vue插件在VSC中的安装方式是,按"Cmd+P"快捷键呼出VSC命令行,然后键入"ext install vue",按回车键,即可成功安装。

插件安装完成后,重启VSC,插件即可生效,如图16-7所示。

第16章测试开发与调试 269

图16-7 vsc识别vue后缀文件

16.3 调试工具

Vue.js团队还为大家提供了Chrome下的调试工具,可以在Chrome的插件商店找到并安装, 如图16-8所示。

Vue.js devtools 由wejs.org提供

Chrome devtool> extension for debu邸Ing Vue.JS applications.

．

开发者工具

＊＊食＊＊(147)

图16-8 Chrome的Vue.js调试插件一Vue.js devtools

安装成功后,在Chrome调试状态下的工具栏中就会出现Vue Devtools选项,选中后界面 如图16-9所示。

该工具可以展示出各个组件的层级结构、组件当前的状态、组件的prop值。还可以通过点 击Inspect Dom一键返回到DOM结构的查看页面。

270 Vue.js权威指南

R幻 Elements Console Sources Network Timeline _!:呾'les Resou吐C三三三} ; x

Y Instance selected: Lamp

Q、Filler components

.. <Root,

.. ~Room>

人Components'] Vuex O Refresh

Lamp>

(!) Inspect DOM ~ Send to console

<Switch>

status: "off" fl勺

图16-9 Vue Devtools界面

如果无法翻墙使用Chrome的软件商店,也可以在Vue.js的github上找到源码自己编译安 装,地址为https://gitbub.com/vuejs/vue-devtools。

第17章

Scrat+ Vue.js的化学反应

Vue.js是一个小而美的库,非常适合开发一些webapp项目。我们团队webapp的技术栈是 用Scrat进行模块化和构建的,自然会考虑到用Scrat +Vue.js做一套完整的移动端开发解决方案, 使前端工程化＋Yue.js完美结合。既然提到前端工程化,那就让我们先来认识一下它。

17.1 浅谈前端工程化

现如今,前端可谓是包罗万象,产品形态五花八门,有小而美的前端基础库、酷炫的运营 活动页、好玩的h5小游戏等。不过这些小项目并非是前端技术的主要应用场景。更具有商业价 值的是复杂的Web应用,如新闻聚合网站、在线购物平台、社交网络平台、金融信贷应用、直 播互动社区、打车出行软件等,它们功能完善、界面繁多、交互复杂,为用户提供了完整的用 户体验。

这些复杂的Web应用,一般需要几十、上百人共同开发维护,其前端界面也颇具规模,工 程最是非常庞大的,这就要求我们从软件工程的角度来思考前端开发,用工程化的手段来解决 前端开发中遇到的各种问题,提升团队的开发效率。这就是所谓的前端工程化。

17.2 前端工程化怎么做

一些人可能认为,前端工程化无非就是库／框架选型＋简单的构建化＋JavaScript/CSS模块化 开发。其实这些只是工程化的一部分,当我们开发一个完整的Web应用时,将面临更多的工程

272 Vue.js权威指南

问题,如：如何多人协作开发、组件模块如何复用、如何调试部署、版本如何管理控制、性能 如何优化等。因此,想做好前端工程化,需要做好以下几件事：

1.开发规范

制定好开发、部署的目录规范、编码规范。好的目录规范能让项目结构清晰,便千维护和 扩展;好的编码规范能让团队内同学的代码风格统一,便千代码审查。

2.模块化

针对JavaScript、CSS,以功能或业务为单元组织代码。JavaScript模块化方案很多,如 AMD/CommonJS/UMD/ES 6 Module等。CSS模块化开发基本上都是在less、sass、stylus等预 处理器的import/mix in特性支持下实现的。

3.组件化

把页面拆分成多个组件(component),每个组件依赖的CSS、JavaScript、模板、图片等资 源放在一起开发和维护。组件是资源独立的,组件在系统内部可复用,组件和组件之间可以嵌 套。现在流行的一些框架如Polymer、React、Vue.js等都提倡组件化开发方式。

4.组件库

有了组件化,我们还希望把一些非常通用的组件或者JavaScript模块放到一个公共的地方 供团队共享,方便新项目的复用,这就形成了组件库。常见的组件库有bower、component等。

5.性能优化

通过工程化手段来解决性能优化问题。比如常见的请求合并、资源压缩、CDN,甚至一些前 沿的优化手段如bigpipe和bigrender,都是通过工程化手段来保证的,而对业务开发者是透明的。

6.项目部署

项目部署一般包括静态资源缓存、CDN、增量发布等问题。合理的静态资源部署可以为前 端性能带来较大的优化空间,而增量发布又为项目的版本控制、A/B Test方案提供了保证。

7.开发流程

完整的开发流程包括本地化开发调试、视觉走查确认、前后端联调、测试、上线等环节, 通过一些工具对开发流程进行改善可以大幅度降低研发成本。

8.工程工具

工程工具包括构建与优化工具、开发—调试—部署等流程工具、组件获取和提交工具等。这

第17章 Scrat+Vue.js的化学反应 273

些工具往往都是独立的系统,如果分开来用,成本太高了。因此能否串联这些功能,使得前端开 发可以待续集成,工具的设计就变得至关重要了。接下来将要介绍一套前端集成解决方案一 Scrat。它集合了这些工程工具,同时还集合了上述提到的7项前端工程化所需的技术要素。

最后,我们通过一张图再总结一下前端工程化所需的8大要素,它们之间并非孤立,而是 存在一定的联系,如图17-1所示。

图17-1 前端工程化8大要素

17.3 Scrat简介

Scrat是UC团队在百度的FIS基础上二次开发的webapp模块化开发框架,它的功能非常 强大,如图17-2所示。

SCRAT

w•归p"'块化开皇休累

图17-2 scrat-webapp模块化开发框架

274 Vue.js权威指南

Scrat拥有前端工程化所需的所有能力,它最大的特色就是模块化开发和模块生态。Scrat 的理念是希望像搭积木一样开发和维护系统,通过组装模块得到一个完整的系统,这就是组件 化开发。同时,每次研发新产品都不是从零开始,不同团队、不同项目能有可复用的模块沉淀 下来,这就形成了组件库。

在Scrat中,静态资源分为模块化资源和非模块化资源两类,其中模块化资源还分为工程模 块和生态模块两类,如图17-3所示。

图17-3 静态资源划分 1.模块化资源

模块化资源是具有独立性的模快所对应的静态资源。每个独立的模块都将自己所依赖的 JavaScript、CSS、模板、图片等资源放在一起维护,使得模块具备独立性,引用模块的JavaScript 即可。其中,工程模块是当前工程所开发的模块,它们往往与业务耦合度较高;生态模块通常 是一些通用性比较高的模块,基千component规范开发,部署到github上,可以通过Scrat命令 安装到本地工程中。

2.非模块化资源

在项目中并不是所有资源都应该被模块化,也有一些非模块化资源,一般为入口页面、模 块化框架JavaScript、第三方JavaScript库、页面启动JavaScript等。

其目录规范为：

proJect

I- component_modules(生态模块)

\- components I

- views

(工程模块)

(非模块资源)

I-

第17章 Scrat+Vue.js的化学反应 275

17.4 Scrat+Vue.js实现组件

Scrat的模块化、组件化思想可以很好地与Vue.js配合,让我们来看看如何在Scrat项目中 定义一个Vue组件。比如定义一个header组件,目录结构如下：

components I- header

I- header.JS

I- header.styl I- header.tpl

I- logo.png

然后在header.js中定义Vue组件,代码示例如下：

module.exports= Vue.extend({

template:—inline ('header. tpl'),

data: func巨on () {

return { applink:'http://d.xiaojukeji.com/c/71444'

}) ;

这里我们借用了FIS的—inline方法把header.tpl的内容内嵌到header.js中,经过Scrat编译 后就变成了如下代码：

define('components/header/header.js', function(require, exports, module) { module.exports= Vue.extend({

template: "<div class=\"header\">\n <div class=\"logo\"></div>\n <div

class=\"download\">\n <a :href=\"app巨nk\">下载APP</a>\n </div>\n</div>",

data: function () {

return {

applink:'http://d. xiaoj ukej i. com/ c/714 4 4'

．, ,

．

}) ;

在其他组件中想用这个组件可以这样写,代码示例如下：

new Vue ({ el:'#main',

276 Vue.js权威指南

template: _in巨ne ('home. tpl'), components: {

'v-header': require ('header') //借助模块化使用组件并注册

}) ;

在Scrat中通过require('header')可以自动加载组件依赖的同名的样式文件(CSS、stylus)等。

最后,在home.tpl中就可以通过<v-header></v-header>来展现组件了。

上面简单介绍了如何在Scrat中定义一个Vue组件,接下来我们通过一个完整的案例看一 下Scrat和Vue.js是如何配合使用的。

17.5 案例分析

我们需要做一个行程分享页面,页面中有司机信息、订单信息、地图等内容。订单状态是 可变的,共有等待接驾、行程中、行程结束、行程取消、行程过期5种状态,随着订单状态的 改变,页面的展示也随之发生变化,如图17-4、图17-5、图17-6所示。

0痄吨i了

令 2FEE私司：心DDFE123

0北京南站 O北京北站

0天一门

故宫博物院

0妇？

乞2F::::DDFE123

巳

0北京南站 0北京北站

ff.a沪

该行程已取消

图17-4 等待接驾、行程中、行程结束效果图

图17-5 行程取消效果图

我们拿到这样一个需求,如果不用Vue.js,那么会在JavaScript中写大量的状态判断逻辑和 DOM操作更新视图,稍不注意就会出错,这个过程是很痛苦的。然而,我们使用Vue.js,实现 这样的需求就很轻松了。下面我们详细介绍如何用Scrat+Vue.js开发这个项目。

第17章 Scrat+Vue.js的化学反应 277

0于洌岂且

三

该行程已于24小时前结束

为了饵护用户隙私 不支持查看行程信息

图17-6 行程过期效果图

17.5.1 准备工作

1.安装Scrat

在命令行执行如下命令：

$ nprn ins七all -g scrat

安装后执行scrat -v,查看工具版本,如图17-7所示。

图17-7 查看Scrat版本

278 Vue.js权威指南

如果安装失败,可以尝试淘宝镜像安装：

$ npm install -g cnpm --registry=https://registry.npm.taobao.org $ cnpm install -g scrat

2.初始化项目

Scrat自带脚手架功能,通过执行scrat init命令生成一个Scrat脚手架项目,如图17-8所示。

图17-8 Scrat脚手架

生成的目录结构如下：

vue-scrat-demo

I-components (模块化资源)

I- server (服务端代码)

I- views (非模块化资源)

I- component.json (模块化资源描述文件)

I- fis-conf.js (构建工具配置文件)

I- package.json (项目描述文件)

I-

3.安装依赖组件库

Scrat采用component作为生态模块,因此可以通过安装component组件,方便开发和团队 共享。打开component.j son文件,修改依赖关系,如下所示：

"name": "scrat-vue", "version": "1.0.0", "dependencies" : {

"scrat-team/fas七click": "1.0.2"

生态模块名称的结构是"用户名／仓库名＠版本号",这里的fastclick是一个JavaScript库, 是由github用户scrat-team创建的,版本是1.0.2。接下来我们在项目目录下执行scrat install命 令,如图17-9所示。

第17章 Scrat+Vue.js的化学反应 279

厂_ __J

图17-9 Scrat安装依赖的生态模块 依赖的fastclick库会安装到当前项目中,目录结构如下：

vue-scrat-derno

I- cornponent_rnodules

I- scrat-tearn-fastclick 1- 1.0.2

I- corriponent.Json I- fastclick.js I-components

I-

模块安装后,我们就可以在JavaScript代码中通过require('fastclick')来引用这个模块了。

17.5.2 代码实现 1.组件拆分

在做好准备工作后,开始正式编写代码前,我们可以依据功能需求,把页面拆分成一个个 组件,如图17-10、图17-11、图17-12所示。

O啊滴出行 heade~且件

一垒

orde吃且件

汾'DDFE私家车京DDFE123

等｀"接驾 i-

景山Ill'街

晕山11111,

(~凳$品

0天一门

map组件

以福,佑寺

丛可宣仁庙

及和庙乙

故宫博物院

即7-10 组件拆分(header、order、map组件)

0北京南站 0北京北站

cancel组件

午·习

',

该行程已取消

图17-11 组件拆分(cancel组件)

280 Vue.js权威指南

巨

该行程已千24小时前结束

为了保护用户隐私．不支持查看行程信息

expired组件

图17-12 组件拆分(expired组件)

我们把页面按功能拆分成多个组件后,很自然就可以梳理出组件目录结构(页面本身也可 以看成一个组件——home组件),如下所示：

I- vue-scrat-demo

I- component_modules(模块牛态资源) I- components

I- cancel I- common I- expired

I- header I- home

I- map

I- order

I - order. j s

I- order.styl I- order.tpl

I- views 1- lib

I- index.html

I- server

I- fis.conf

I-

(行程取消组件)

(公共JS、stylus、image、font资源) (行程过期组件)

(头部组件)

(页面组件)

(地图组件)

(订单组件)

(订单组件j s)

(订单组件stylus) (订单组件模板)

Cscrat.js、vue. j s、norma巨ze.css等非模块化资源) (入口页面)

(服务端逻辑)

(构建工具配置文件)

2页面入口

页面入口为index.html,引入了lib.js(包括scrat.js和Vue.js)。其中,scrat」s是Scrat开发

第17章 Scrat+Vue.js的化学反应 281

体系的模块化框架,它与Scrat构建工具紧密结合,实现了JavaScript/CSS依赖管理、请求合并、 按需加载、本地缓存等功能。同时,引入了Vue.js,我们可以全局使用Vue对象。

页面是基千JavaScript渲染的,代码示例如下：

<script>

require.config(_FRAMEWORK_CONFIG—) ;

require. a sync (['home','fastclick'], func巨on (home, fastclick) { fas七click(document.body);

home.render(document.body);

}) ;

</script>

其中,＿FRAMEWORK_CONFIG＿这个全局宏会在项目构建时被替换成一个对象(包括 模块描述、依赖关系、其他参数等)。Scrat通过require.config接口知道了所有依赖关系,因此 在require.async加载模块时,可以找到依赖的所有JavaScript、CSS模块并加载。当全部请求加 载完成后触发callback函数。

页面渲染主要就是通过home组件的render方法实现的,接下来我们看一下home组件的实 现。

3. home组件的实现

home组件通过render方法渲染页面主框架,代码示例如下：

／ ＊ ＊

＊渲染页面骨架

* @param dom */

exports. render = function (selector) {

new Vue ({

el: selector, replace: false,

template: _inline('home.tpl'), data: {

orderinfo: {

orders七atus: 0,

fromAddress: '北京南站', toAddress: '北京北站', getOnTime: 1464624221, getOffTime: 1464684221

282 Vue.js权威指南

},

dri verinfo: {

name: 'DDFE司机', score: 5,

car: 'DDFE私家车',

plate:'京DDFE123',

avatar:'https: // avatars3. gi thubusercontent. com/u/ 5359011'

},

events: {

'order. change': function (orderinfo) { this.orderinfo = orderinfo;

this. $broadcast ('order. change', orderinfo) ;

},

components: {

'v-header': require ('header'), 'v-order': require ('order'), 'v-map': require ('map'), 'v-cancel': require ('cancel'), 'v-expired': require ('expired')

)) ;

我们通过new Vue创建了一个Vue实例,并把它挂载在selector对象上。由千传入的selector 是document. body,因此replace属性值要设置为false。这里的template通过FTS特有的＿inline 方法把home.tpl的内容内嵌到home.js中,从而实现了模板与JavaScript文件分离。在data属性 中我们mock了一些数据,作为模板的数据源。在events属性中我们监听了order.change事件, 该事件是由order组件派发的,home组件接收后,广播给其他子组件。Components中描述了 home组件包含的所有子组件,可以看到,所有子组件都可以通过'v-xxx': require('xxx')方式加载 并局部注册,这样我们就可以在模板中通过<v-xxx></v-xxx>来使用了。

接下来我们看一下home.tpl的实现,代码示例如下：

<v

<div class="container">

<v-order v-show="orderinfo. orderStatus 1 ==4" : dri ver-info="driverinfo" : order- info= "orderinfo"></v-order>

<v-map v-show="orderinfo.orderStatus<3"></v-map>

第17章 Scrat+Vue.js的化学反应 283

<v-cancel v-show="orderinfo.orderStatus===3"></v-cancel> <v-expired v-show="orderinfo.orderStatus===4"></v-expired> </div>

在模板中,我们通过v-show指令结合订单状态字段orderinfo.orderStatus来判断隐藏或者显 示不同的组件。这就是Vue.js带给我们的福利,不需要在JavaScript中写烦琐的判断逻辑和DOM 操作,只需要在模板中通过一些指令和判断条件,就能实现根据不同的状态渲染不同的视图。 这样不容易出错,极大地提升了研发效率。

可以看到,我们通过v-bind指令的简写方式driver-info和order-info把data中定义的 driverlnfo和orderlnfo数据传递给order组件的props。接下来我们看一下order组件的实现。

4. order组件的实现

order组件作为home组件的子组件,代码示例如下：

var api = require('common/js/api'); module.exports= Vue.extend({

template: _in巨ne ('order. tpl'I, props: ['driver-info','order-info'], created: function () {

this.fetchOrderData(); },

methods: {

fetchOrderData: function () { var me= this;

api.ge七Orderinfo (function (orderinfo) {

if (me.orderinfo.orderSta七us ! == orderinfo. orderStatus) { me.orderinfo = orderinfo;

me.$dispatch ('order.change', orderinfo);

set Timeout (function () ( me.fe七chOrderData(); }, 5000);

}) ;

)) ;

我们通过Vue.extend方法创建一个组件的构造器,并作为模块导出。这样在home组件中 就可以通过require('order')加载这个构造器,并把它当作Vue实例的components属性完成局部

284 Vue.js权威指南

注册。template依旧通过FIS的—inline方法加载order.tpl的内容。props可以接收父组件传递的 数据。created为Vue实例生命周期中的一部分,在Vue实例化时调用。我们通过在methods中 定义的fetchOrderData方法加载订单数据,这里的数据都是mock的,每5s请求一次。下面简 单看一下服务端mock部分,代码示例如下：

var st.atus = 0;

app. get ('/ orderinfo', functio:i (req, res, next) {

res. send ({

orders七atus: status,

fromAddress: '北京南站', 七oAddress: '北京北站', getOnTime: 1464624221, getOffTime: 1464684221

)) ;

江(status < 4) { status++;

} else {

status= 0;

服务端采用的是node的Express框架。当然,采用其他后端语言也是可以的,这本身就是 一个前后端分离的项目,在这里只是mock数据。可以看到,服务端返回的数据每次orderStatus 都会不一样,当order组件接收到不一样的orderStatus时,会通过$dispatch方法派发这个 order.change事件给它的父组件。home组件会接收到这个事件,更新自己的orderStatus,同时 自身的视图也会根据orderStatus的改变自动刷新。home组件还会广播这个事件,所有监听这个 事件的子组件都可以收到并做相应的处理。

接下来还有map、cancel、expired组件等,它们的代码和order组件大同小异,限于篇幅这 里就不一一介绍了。

17.5.3 编译和发布

项目代码开发完成后,需要编译和发布。在Scrat中,在项目目录下执行scrat release命令, 即可对项目进行构建,并将构建结果发布到本地调试目录下,如图17-13所示。

第17章 Scrat+Vue.js的化学反应 285

I I

图17-13 Scrat构建项目

构建工具常见的功能就是区分构建目的,比如开发构建、测试构建、上线构建等。Scrat并 不像grunt或者gulp那样定义不同的task来区分构建目的,而是通过release命令的多种参数组 合来确定构建目的。

scrat release命令的所有参数都可以通过scrat release -h命令来查看,其中常见的包括： 0 --dest <paths>—指定构建结果的发布路径。

0 --md5一是否给非模块化资源添加MD5戳。

0 --domains—是否给静态资源添加域名。

0 --lint—是否开启代码校验。

0 --opti血ze－一是否开启代码压缩。

0 --watch 是否开启文件监听。

0 --live 是否开启浏览器自动刷新。

scrat release命令的所有参数均可自由组合,通过不同参数的不同组合即可得到不同的开发 状态,参数顺序没有影响。

本项目执行scrat release命令后,执行scrat server open命令,可以打开本地调试目录,如 图17-14所示。

图17-14 Scrat打开本地调试目录

编译后生成的调试目录结构如下,我们重点看一下public目录。

286 Vue.js权威指南

I- WWW

I-server (后端代码逻辑)

I-public (生成的静态资源目录)

I- C

I- scrat-team-fastclick 1-1.0.2

1-fastclick.js

I- SC工at-vue

1-1.0.0

I- cancel I- common I- expired I- header

I- home I- map

I- order

I- order.css

I- order.css.js I- order.js

I- scrat-vue

I- 1.0.0 1- lib

I- index.html

I-views (模板目录)

I-

我们可以看到,编译后的静态资源分为c目录(模块化资源目录)和scrat-vue项目目录。c 目录又按项目名称和版本号划分为不同的子目录,这种部署规则可以保证不同的项目、不同的 版本都可以增量发布而不会有任何冲突。在生产环境中,我们也可以把public目录的所有资源 上传到CDN的回源机器,同时修改fis-conf.j s中的静态资源域名,在编译过程中利用scrat release 的domains参数在静态资源URL前添加域名。我们还可以通过修改fis-conf」s的配置来实现更 多的功能。这块内容可以参阅FIS官网(http://fis.baidu.com/),这里就不再赘述了。

项目编译后,可以执行scrat server start命令开启本地node服务器,如图17-15所示。

第17章 Scrat+Vue.js的化学反应 287

图17-15 Scrat开启本地node服务器

最后,在浏览器中输入localhost:5000,可以预览效果,至此,整个项目的开发和部署完成。

17.6 总结

Yue.js的设计思想是专注而灵活,它只聚焦视图层,响应的数据绑定和组件系统是其特色。当 我们采用Vue.js构建一些大型应用时,就不得不考虑Web前端工程化的一些事情了,而Scrat在 工程化方面做得特别棒。Scrat和Vue.js在组件化开发思想上不谋而合,相得益彰,Scrat+Yue.js 产生的化学反应是美妙的,它们必将成为开发大型项目的利器。

第18章

Vue.js 2.0

Vue.js 2.0 preview版本千2016年4月底发布,相对千1.x版本,Vue.js 2.0做了不少的改进 和优化。除了部分API变更、模板更加灵活之外,最吸引人的恐怕就是高性能的Virtual DOM 和流式服务端渲染功能了。接下来就让我们一起走进Vue.js 2.0的世界,看一看Vue.js 2.0给我 们带来了哪些惊喜。

18.1 API变更

对千所有框架／库做大版本的更新,开发者最关心的就是API与之前版本的兼容程度。虽然 Vue.js 2.0用ES 6+flow对整个项目进行了重写,但作者表示除了一些有意废弃掉的功能,API 和1.x是大部分兼容的。部分功能的废弃,本质上是为了提供更简洁的API而减少开发者对框 架的理解和学习成本,从而提高开发者的效率。下面让我们一起来看看哪些API发生了变化。

18.1.1 全局配置

0新增Vue.config.errorHandler

Vue.js 2.0新增了config.errorHandler,它是一个全局钩子函数。当组件渲染时遇到未处理的 异常,会调用这个函数,默认会输出错误堆栈信息。

0新增Vue.config.keyCodes

Vue.js 2.0新增了config.keyCodes,它提供了对v-on指令按键修饰符自定义key别名的配置。 0废弃Vue.config.debug

在Vue.js l.x版本中,如果config.debug设置成true,则在开发版本中为所有的警告打印栈

第18章Vue.js 2.0 289

追踪信息。Vue.js 2.0新增了errorHandler全局钩子函数,可以通过它输出错误堆栈信息,所以 config.debug被废弃。

0废弃Vue.config.async

在Vue.js 1.x版本中,con:fig.async表示异步模式,默认值为true,如果关闭异步模式,Vue 检测到数据变化时会同步更新DOM。这样虽然方便了调试,但会导致性能下降,并影响Watcher 的回调顺序,在生产环境下是不建议使用的。Vue.js 2.0采用了Virtual DOM的方式,它的渲染 方式必须是异步的,因此废弃了config.async这个配置。

0废弃Vue.config.delimeters

在Vue.js l.x版本中,config.delimeters代表文本插值的界定符,是一个全局配置。而在Vue.js 2.0中,该配置从全局配置中移除,变成一个组件级别的配置。

0废弃Vue.config.unsafeDelimeters

在Vue.js l.x版本中,config.unsafeDelimeters代表原生HTML插值的界定符。Vue.js 2.0废 弃了该配置,用v-html指令替代该功能。

18.1.2 全局API

0新增Vue.compile

Yue.js 2.0新增了Vue.compile全局API,它的功能是把一个Vue实例的模板字符串编译成 render function。

0废弃Vue.transition的stagger

在Vue.js 1.x版本中,当transition和v-for一起使用时可以通过stagger创建渐进过渡效果。

Vue.js 2.0废弃了该接口,可以在遍历时给每个元素设置data-index属性,然后通过在JavaScript 中访问该属性实现类似的效果。

0废弃Vue.elementDirective

在Vue.js 1.x版本中,Vue.elementDirective的功能是定义全局元素指令,元素指令的本意是 像Angular JS的E指令那样定义一个自定义元素,它可以被看成是一个轻量组件。但是,这是 一个鸡肋功能,Vue.js本身就有一套很好的组件化开发机制(这点和AngularJS不同),所以Vue.js

290 Vue.js权威指南

2.0废弃了该API,可以通过component来实现。

0废弃Vue.partial

在Vue.js 1.x版本中,Vue.partial的功能是注册或获取全局的partial。partial是一种特殊元 素,它可动态地插入一小段模板,在插入时被Vue编译。但由千它的功能完全可以通过functional 的component实现,因此在Vue.js 2.0中被废弃。

18.1.3 VM选项 1.数据部分

0废弃props. coorce

在Vue.js 1.x版本中,props.coorce是属性转换函数,它的功能是把传入的属性值通过一个 函数进行转换。不过它的功能也可以通过设置计算属性来实现,因此在Vue.js 2.0中被废弃。

0废弃prop binding modes

在Vue.js 1.x版本中,我们可以使用sync、once绑定修饰符设置属性的绑定模式为双向或 者单次绑定。Vue.js 2.0废弃了这些模式,属性只能够单向传递,如果子组件想影响父组件,则 必须通过事件派发的方法,这样做的好处是降低了子组件和父组件的耦合。在Vue.js 2.0中,我 们应该把prop看作是immutable的,不建议直接修改prop,所有需要修改prop的场景都可以用 基千该prop值的data属性或者computed属性替代。

2. DOM部分 0新增render

Vue.js 2.0新增了render字段,render字段是一个function,运行时会把模板中的内容经过 Vue的编译,转换成渲染方法存入render字段,然后再执行。如果发现render字段已经存在, 则跳过模板解析过程直接渲染。因此,在Vue.js 2.0中写一个模板和写一个render function是等 价的。

0废弃replace

在Vue.js 1.x版本中,我们可以通过replace属性来决定是否用模板替换挂载元素,默认值 是true,模板将覆盖挂载元素;Vue.js 2.0废弃了该属性并且规定组件必须有确切的根元素,模板 将挂载到这个根元素上并覆盖。因此,在Vue.js 2.0中不能把Vue实例挂载在document.body上。

第18章Vue.js 2.0 291

3.资源部分

0废弃partials

在Vue.js l.x版本中,partials是一个包含模板字符串的对象。它的功能可以通过components 对象实现,因此在Vue.js 2.0中被废弃。

0废弃elementDirective

在Vue.js l.x版本中,elementDirective是一个包含元素指令的对象。它的功能可以通过

functional的components实现,因此在Vue」s 2.0中被废弃。

4.杂项部分

0新增delimiters

在Vue.js l.x版本中,delimiters是文本插值的界定符,它是一个全局的配置选项。在Vue.js 2.0中,delimiters作为Vue实例的一个属性,只独立作用于当前Vue实例的编译过程。

0新增functional

在Vue.js l.x版本中,我们可以通过partial这种特殊元素创建一个模板,它通常是无状态的。

Vue.js 2.0废弃了partial,我们可以创建一个functional的component来替代它,仅仅通过一个 render function来创建Virtual DOM。

0废弃events

在Vue.js l.x版本中,组件的自定义事件监听都是通过这个属性设置的。在Vue.js 2.0中, 组件的事件派发和广播被废弃,因为考虑到组件树可能层级很深、兄弟组件的通信问题。我们 可以通过全局事件管理中心来解决这些问题。

5.生命期钩子函数部分

在Vue.js 2.0中,Vue实例的生命周期发生了一些变化,如图18-1所示。

0新增beforeMount

Vue.js 2.0新增了beforeMount钩子函数,它的调用时机是在模板编译成render方法之后、 创建Watcher之前。

0新增mounted

Vue.js 2.0新增了mounted钩子函数,它的调用时机是在DOM树生成之后。

292 Vue.js权威指南

三三］----

图18-1 Vue.js 2.0生命周期图示

第18章Vue.js 2.0 293

0新增before Update

Vue.js 2.0新增了before Update钩子函数,它的调用时机是在Virtual DOM生成之后、DOM 树生成之前,调用条件是这个vm实例已经mounted过。

0新增update

Vue.js 2.0新增了update钩子函数,它的调用时机是在DOM树生成之后,调用条件是这个 vm实例巳经mounted过。

0新增activated

Vue.js 2.0新增了activated钩子函数,它的调用时机是在DOM树生成之后,调用条件是 keep-alive组件。

0新增deactivated

Vue.js 2.0新增了deactivated钩子函数,它的调用时机是在Vue实例销毁时,调用条件是 keep-alive组件。

0废弃ready

在Vue.js l.x版本中,ready钩子函数的调用时机是第一次插入DOM后。Vue.js 2.0并不一 定执行在浏览器环境中,也可能是在服务端渲染,因此废弃了该钩子函数并用mounted钩子函 数替代。

0废弃beforeCompile

在Vue.js 1.x版本中,beforeCompile钩子函数的调用时机是在模板编译前。Vue」s 2.0废弃 了该钩子函数并用created钩子函数替代。

0废弃compiled

在Vue.js l.x版本中compiled钩子函数的调用时机是在编译模板之后、DOM创建之前。

Yue.js 2.0废弃了该钩子函数并用mounted钩子函数替代。

0废弃attached

在Vue.js l.x版本中attached钩子函数的调用时机是插入DOM时。Vue.js 2.0不一定会创建 真实的DOM,因此废弃了该钩子。

294 Vue.js权威指南

0废弃detached

在Vue.js l.x版本中,attached钩子函数的调用时机是移除DOM时,废弃理由同上。

18.1.4 实例属性

0废弃vm.$els

在Vue.js l.x版本中,vm.$els表示一个注册有v-el DOM元素的对象,可以通过它访问到组 件中的DOM对象。Vue.js 2.0废弃了该属性,把该功能合并到vm.$refs中。

18.1.5 实例方法 1.数据相关

O废弃vm.$get

在Yue.js l.x版本中,vm.$get的功能是从Vue实例获取指定的表达式的值。Yue.js 2.0废弃 了此方法,建议直接从Javascript对象中取值。

0变更vm.$set为Vue.set

在Vue.js 1.x版本中,vm.$set的功能是设置Yue实例的属性值。Vue.js 2.0废弃了此方法, 可以用全局API Vue.set替代。

0变更vm.$delete为Yue.delete

在Yue.js l.x版本中,vm.$delete的功能是删除Vue实例(以及$data)上的顶级属性。Yue.js 2.0废弃了此方法,可以用全局API Yue.delete替代。

0废弃vm.$eval

在Vue.js 1.x版本中,vm.$eval的功能是计算当前实例上的合法绑定表达式,可包含过滤器, 该功能也可以通过computed属性实现,实际上很少使用。在Yue.js 2.0中被废弃。

0废弃vm.$interpolate

在Yue.js l.x版本中,vm.$interpolate的功能是计算模板,该功能也可以使用computed属性 实现,实际上很少使用。在Vue.js 2.0中被废弃。

第18章Vue.js 2.0 295

0废弃vrn.$log

在Vue.js l.x版本中,vrn.$log的功能是打印当前实例数据。Vue.js 2.0废弃了该方法,因为

它完全可以被Vue提供的开发者工具替代。

2.事件相关

0废弃vrn.$dispatch

在Vue.js 1.x版本中,vm.$dispatch是组件派发事件的方法,它会沿着父链向上冒泡在触发 第—个监听器后停止,除非返回true。Vue.js 2.0废弃了该方法,用全局的事件或者Vuex替代。

0废弃vrn.$broadcast

在Vue.js 1.x版本中,vm.$broadcast是组件广播事件的方法,它会向所有子组件广播,每 条路径上的通知在触发一个监听器后停止,除非返回true。Vue.js 2.0废弃了该方法,用全局的 事件或者Vuex替代。

3. DOM相关

0废弃vrn.$appendTo

在Vue.jsl.x版本中,vrn.$appendTo的功能是将实例的DOM片段插入目标元素内。Vue.js 2.0 废弃了该方法,可以通过原生DOM API: appendChild方法配合vm.$el实现。

0废弃vrn.$before

在Vue.jsl.x版本中,vrn.$before的功能是将实例的DOM片段插入目标元素的前面。Vue.js 2.0废弃了该方法,可以通过原生DOM API: insertBefore方法配合vrn.$el实现。

0废弃vrn.$after

在Vue.jsl.x版本中,vrn.$after的功能是将实例的DOM片段插入目标元素后面。Vue.js 2.0 废弃了该方法,可以通过原生DOM API: afterChild方法和appendChild方法配合vm.$el实现。

O废弃vrn.$remove

在Vue.jsl.x版本中,vm.$remove的功能从DOM中删除实例的DOM元素或者片段。Vue.js 2.0废弃了该方法,可以通过原生DOM API: remove方法配合vm.$el实现。

296 Vue.js权威指南

18.1.6 指令

0新增v-once指令

在Vue.js 2.0中,可以给DOM元素设置v-once指令,来表明该元素是一个静态根节点,这 些节点生成后内容就不会被改变,因此在Virtual DOM的d市和patch的过程中,可以忽略这些 节点来提升性能。

0废弃v-mode中的debounce参数

在Vue.js 1.x版本中,v-model指令主要用来在表单控件元素上创建双向数据绑定,它支持 debounce参数,作用是针对input事件设置一个最小延时,在每次敲击之后延迟同步输入框的 值与数据。注意,debounce参数并不会延迟input事件,它是延迟写入底层数据,因此在使用 debounce时应当用vm.$watch()响应数据变化。由于延迟写入底层数据,它的状态更新也会被延 迟,这样就会带来一些限制,比如不能实时检测到数据的输入。Vue.js 2.0废弃了该参数,把延 迟操作和Vue本身解耦,可以通过v-on:input绑定input事件,并配合第三方的debounce方法, 这样既可以实时更新状态,也可以达到延迟input事件的目的。

0废弃v-ref指令

在Vue.js l.x版本中,v-ref指令是在父组件上注册一个子组件的索引,便千直接访问。Vue.js 2.0废弃了这个指令,它的功能用特殊的屈性ref替代。

0废弃v-el指令

在Vue.js 1.x版本中,v-el指令是为DOM元素注册一个索引,方便通过所属实例的$els访 问这个元素。Vue.js 2.0废弃了这个指令,它的功能合并到ref属性中。

0 v-for指令修改

在Vue.js l.x版本中,可以使用v-for指令基千数组渲染一个列表。这个指令使用特殊的语 法,形式为item in items, items是数据数组,item是当前数组元素的值。在Vue.js 2.0中,不仅 可以遍历数组,也可以遍历对象。数组的遍历语法形式为value in arr或者(value, index)m arr,

value为当前数组元素的值,index为当前数组元素的索引。对象的遍历语法形式为value in obj、 (value, key)in obj或者(value, key, index)in obj。其中value为当前对象元素的值,key为对象的属 性名称,index为当前遍历的索引。因此,Vue.js 2.0废弃了v-for指令的$index和$key语法。在 Vue.js I.x版本中,可以通过track-by属性优化v-for,让Vue」s尽可能复用已有的实例。在Vue.js

第18章Vue.js 2.0 297

2.0中,track-by属性用key属性代替,它的值可以是一个普通字符串,也可以通过v-bind动态 绑定。

18.1.7 特殊元素

0废弃partial元素

在Vue.js l.x版本中,pa巾al元素的作用是动态插入一个模板。Vue.js 2.0废弃了该元素,它 的功能可以通过functional的component实现。

18.1.8 服务端渲染

服务端渲染是Vue.js 2.0的新特性,它提供的接口如下： 0新增renderToString(component,done)方法

它的功能是在服务端把Vue组件component渲染成DOM字符串,我们可以在done的回调 函数中拿到渲染好的DOM字符串。

0新增renderToStream(component)方法

它的功能是返回一个渲染流,是一个可读的stream,可以直接pipe到HTTP Response中。

该方法相比千renderToString,当App非常复杂时也不会阻塞服务器的event loop,能够确保服 务端的响应度,也能让用户更快地获得渲染内容。

18.2 Virtual DOM

18.2.1 认识Virtual DOM

现在简单回顾一下网页开发的历程。传统的Web页面都是简单的静态页面加上一些基本的 DOM操作,我们可以使用一些Javas Script库如凡uery来方便开发。随着Web应用程序越来越 复杂,程序状态越来越多,DOM操作的复杂度也在提升,jQue1-y已经不能满足我们的开发需 求了,千是一些MVC、MVVM框架被引入。在M汃IM框架中,我们可以通过数据绑定实现 视图和模型(数据)的互动效果,通过双向绑定自动实现模型与视图的同步更新。但这些仅仅 是从代码组织方式来降低维护这种复杂应用的难度,并没有从本质上减少所维护的状态,也没 有减少页面的DOM操作(框架替我们做了而已)。

298 Vue.js权威指南

MVVM框架可以很好地降低我们维护状态一视图的复杂程度。但是当页面变得非常复杂 时,视图的更新也可能会引发大量的DOM操作,产生一定的性能问题。DOM是很"昂贵"的, 我们可以把一个简单的div元素的属性都打印出来,如图18-2所示。

> var div= document,createElement('div') varstr=''

for Ivar key in div){ st r += key +''

"align title lang translate dir dataset hidden tablndex accessKey draggable spellcheck contentEditab\e isContentEditable offsetParent offsetTop offsetleft offsetWidth offsetHeight style innerText outerText webkitdropzone onabort onblur oncancel oncanplay oncanplaythrough onchange onclick enclose oncontextmenu oncuechange ondblclick ondrag ondragend ondragenter ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended onerror onfocus oninput oninvalid onkeydown onk•ypress onkeyup onload onloadeddata onloadedmetadata onloadstart onmousedown onmouseenter onmouseleave onmousemove onmouseout onmouseover onmouseup onmousewheel onpause onplay onplaying onprogress onratechange onreset onresize onscroll onseeked onseeking onselect onshow onstalled onsubmit onsuspend ant皿eupdate ontoggle onvolumechange onwaiting click focus blur onautocomplete onautocompleteerror namespaceURI prefix localName tagName _ id

className classli.st attributes innerH飞L outerHTML shadowRoot scrollTop scrollLeft scrollWidth scrollHeight clientTop clientleft clientWidth clientHeight onbeforecopy onbeforecut onbeforepaste oncopy oncut onpaste onsearch onselectstart onwheel onwebkitfullscreenchange onwebkitfullscreenerror prev iousElementSibling nextElementSibling children firstElementChild lastElementChild childElementCount hasAttributes getAttribute getAttributeNS setAttribute setAttributeNS removeAttribute removeAtt ributeNS hasAtt ribute hasAtt ributeNS getAttributeNode getAttributeNodeNS

setAttributeNode setAttributeNodeNS re•oveAttributeNode closest matches心bkitMatchesSe lee tor getElementsByTagName

get Element sByTagNameNS getElementsByC\as sName insertAdj acentElement insertAdj acentText insertAdj acentHTML createShadowRooi: getDeshnationinsertionPoints requestPointerLock getClientRects getBoundingClientRect scrol llntoView scrol lintoViewlfNeeded animate remove webkitRequestFullScreen webkitRequestFullscreen querySelector querySelectorA ll ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTIDN_NODE C叩ENT)lODE [)QC UM ENT _NODE DOCUMENT - TYPE_NODE DOCUMENT _FRAGIIENT=NODE NOTATION_NODE DOCUIIENT_POSITION_DISCONNECTEO

OOCIJMEN于－POSITIDN_PRECEDING DOCUMENT_pOSITION_FOLLOWING OOCUMENT_POSITION_CONTAINS DOCUMENT_POSITION_CONTAINED_BY DOCUMENT=P□SITION_)MPLEMENTATION_SPECIFIC nodeType nodeName baseURI isConnected ownerDocument parentNode parentElement childNodes firstChild lastChild previousSibling nextSibling nodeValue textContent hasChildNodes normalize cloneNode isEqualNode isSameNode compareDocumentPosition contains lookupPrefix lookupNamespaceURI isDefaultNamespace insertBefore appendChild replaceChild removeChild addEventlistener removeEventlistener dispatchEvent "

图18-2 div元素包含的属性

可以看到,真正的DOM元素是非常庞大的,因为浏览器的标准就把DOM设计得非常复 杂。更糟的是,很多时候我们在调用DOM API时做得不够好,导致更慢。比如有一个列表, 代码示例如下：

<ul>

<巨>DDFE小Z</li> <让>DDFE小H></li> <巨>DDFE小S></li>

</ul>

我们想把它变成这样：

<ul>

<巨>DDFE小W</li> <巨>DDFE小J></li> <巨>DDFE小S></li> <li>DDFE小G></li> </ul>

通常的操作是把前3个h删除,再添加4个h,这里面就有3次Element的删除,4次Element

第18章Vue.js 2.0 299

的添加操作,这当然也是有优化空间的。

了解到DOM的一些弊端,人们就会思考有没有什么方式可以对DOM做优化。聪明的人 提出了Virtual DOM的概念,它是一种虚拟DOM技术,本质上是基于JavaScript实现的。相对 千DOM对象,JavaScript对象更简单,处理速度更快,DOM树的结构、属性信息都可以很容 易地用JavaScript对象来表示。代码示例如下：

var element= {

tagName: 'ul', //节点标签名

props: { // DOM的屈性,用一个对象存储键值对 id:'巨st'

},

children: [ //该节点的子节点

{ tagName:'li', props: {class:'i tern'}, children: [ "DDFE小Z" l}, { tagName:'li', props: {class:'i tern'}, children: [ "DDFE小H"]}' { tagName:'li', props: {class:'i tern'}, children: [ "DDFE小S"]}

］ }

对应的HTML写法是：

<ul id;"list">

<liclass;"item">DDFE小Z</li>

<li class;"item">DDFE小H></li> <liclass;"item">DDFE小S></li>

</ul>

我们通过JavaScript对象表示的树结构来构建一棵真正的DOM树,当数据状态发生变化时 可以直接修改这个JavaScript对象,接着对比修改后的JavaScript对象,记录下需要对页面做的 DOM操作,然后将其应用到真正的DOM树,实现视图的更新。这个过程就是Virtual DOM的 核心思想。

18.2.2 Virtual DOM在Vue.js 2.0中的实现 1.创建VNode对象模拟DOM树

在Vue.js 2.0中,Virtual DOM是通过VNode类来表达的,每一个原生DOM元素或者Vue 组件都对应一个VNode对象。我们先来看一下VNode的数据结构,如图18-3所示。

300 Vue.js权威指南

VNode

VNodeData

key: string I number slot: string

ref: string

tag: string staticClass: string class: any

style: Array<Object> I Object show: boolen

props: Object

attrs: Object staticAttrs:Object

hook: Object

on: Object

transl廿on: Object inlineTemplate: Object

directivos: Array<VNodeDirective> keepAlive: boolen

tag: string

data: VNodeData children: Array<VNode> te,t: string

elm: Node

ns: string

cont心t: Component key: string

componentOptions: VNodeComponentOptions c问d: Component

parent: VN ode

constructor: Function setChildren: Function

VNodeDir.ctiv. name:string

value: any

oldValue: any

arg:string

modifiers: Object

VNo心ComponentOption,

Ctor: Clm<Cornponent> propsData: Object listeners: Object

parent: Component

chndren: Array<ony> 10= >Array< any> I string tag:,tring

图18-3 VNode的数据结构图

图中不仅包含了VNode的数据结构,还包含了VNodeData、VNodeDirective、 VNodeComponentOptions等数据结构。

Cl) VNode

VNode用来描述DOM节点的主要信息,包括tag、text、elm、data、parent、children等属 性。它主要有两种生成方式,其中一种是由普通DOM元素生成;另一种是由Vue组件生成。 这两种方式生成的VNode对象的区别主要是在componentOptions的值上,如果是普通DOM元 素生成的VNode对象,该值为空。

(2) VNodeComponentOptions

VNode中componentOptions属性的数据类型用来描述通过Vue组件生成VNode对象的一 些组件相关参数,包括Ctor、propData、listeners、parent、children、tag等属性。

(3) VNodeData

VNode中data属性的数据类型用来描述VNode包含的一些节点数据,包括slot、ref、 staticClass、style、class、props、attrs、transition、directives等。

(4) VN odeDirective

VNodeData中directives属性的数据类型用来描述VNode存储的指令数据,包括name、

第18章Vue.js 2.0 301

value、oldValue、arg、modifiers等。

在了解了VNode及相关数据结构后,我们心中不免产生疑问,VNode是如何在Vue中生 成的呢？可以先通过图18-4看一下VNode的生成过程。

图18-4 VNode的生成过程

从图中我们可以看到,VNode生成最关键的点是通过call render function, render方法在

302 Vue.js权威指南

Yue.js 2.0中有两种生成方式：第一种是直接在Vue对象的option中添加render字段;第二种是 像Vue.js l.x版本那样写一个模板或者指定一个el根元素,它会首先转换成模板,经过HTML 语法解析器生成一个ast抽象语法树,对语法树做优化,然后把语法树转换成代码片段,最后 通过代码片段生成function添加到option的render字段中。

在整个过程中,特别值得一提的是ast语法树优化的过程,它主要做了两件事情：

0会检测出静态的class名和attributes,这样它们在初始化渲染之后就永远都不会再被比 对了。

0会检测出最大的静态子树(就是不需要动态性的子树)并且从渲染函数中萃取出来。这 样在每次重渲染时,它就会直接重用完全相同的Ynode,同时跳过比对。

接下来我们可以通过一段简单的代码看一下编译后的渲染函数。代码示例如下：

<div id="app">

<hl>Hello { {who} }</hl> </div>

<script>

new Vue ({

el:'#app',

data: (

who:'DDFE'

)) ; </script>

我们在Vue对象中指定了el根元素,经过一系列的编译操作后,最终生成render方法。代 码示例如下：

(funct工on () { with (this) {

return h(e('div', {staticAttrs: {"id": "app"}}), [ h (e ('hl'),

[("Hello"+ _s(who)))

) ］

))

第18章Vue.js 2.0 303

可以看到,render方法使用了with方法来包裹代码快,with(this)中的属性和方法相当千通 过this来调用,这样写是为了减少代码械。这里的this指向的是Vue对象实例,＿h、＿e方法都 是和VNode相关创建的方法。源码定义如下：

<'－－源码目录：src/core/instance/render.js-->

Vue.prototype._h = renderElement阳thChildren Vue.prototype._e = renderElement

_h和＿e方法分别是renderElementWithChildren、renderElement,源码定义如下：

< !" －－源码目录：src/core/vdom/create-element.js--> export function renderElementWithChildren ( vnode: VNode I void,

children: VNodeChildren I void ) : VNode I Array<VNode> I void { if (vnode) {

const componentOptions = vnode.componentOptions if (componentOptions) {

辽(process.env.NODE_ENV !=='production'&& children && typeof children ! =='function') { warn (

'A componen七＼'s children should be a function that returns七he'+

'children array. This allows the component to七rack the children'+ 'dependencies and optimizes re-rendering.'

const CtorOptions = cornponentOptions.Ctor.options // functional component

if (CtorOptions. functional) { return CtorOptions.render.call( null,

cornponent0ptions.parent.$createElernent, // h

componentOptions. props Data I I {}, normalizeChildren(children)

II props II children

} else {

// normal component componentOptions.children = children

) else {

// normal element

304 Vue.js权威指南

vnode.setChildren(normalizeChildren(children))

return vnode

export function renderElement (

tag?: string I Class<Component> I Function I Object, data?: VNodeData,

namespace?: string

) : VNode I vo过{

II make sure to expose real self instead of proxy const context: Component= this._self

const parent: ?Component= renderState.activeinstance const host= context !==parent? parent : undefined if (!parent) {

process.env.NODE_ENV !=='production'&& warn( 'createElement cannot be called outside of component'+ 'render functions.'

return

if (!tag) {

// in case of component :is set to falsy value return emptyVNode()

if (typeof tag==='string') { let Ctor

if (con fig. isReservedTag (tag)) {

return new VNode( 七ag, data,

undefined, undefined, undefined, narnespace, context, host

} else if {{Ctor = resolveAsset(context.$options,'components',七ag))) { return createCornponent(Ctor, data, parent, context, host, tag)

} else {

江(process. env. NODE_ ENV ! =='production') { if (

!narnespace &&

'(con fig. ignoredElernents && conf ig. ignoredElernents. indexOf (tag) > -1} & &

第18章Vue.js 2.0 305

config.isUnknownElement(tag)

) {

warn (

'Unknown custom element: <'+tag+'> - did you'+

'register the component correctly? For recursive components,'+ 'make sure to provide the "name" option.'

return new VNode( tag, data,

undefined, undefined, undefined, namespace, context, host

} else {

return createComponent(tag, data, parent, context, host)

renderElementWithChildren方法的功能是给一个VNode对象添加若干子VNode,囚为整个 Virtual DOM是一种树状结构,每个节点都可能会有若干子节点。

renderElement方法的功能是创建一个VNode对象,如果是一个reserved tag(比如html、

head等一些合法的HTML标签),则会创建普通的DOMVNode对象;如果是一个component tag (通过Vue注册的自定义component),则会创建Component VNode对象,它的 VNodeComponentOptions不为null。

创建好VNode,下一步就是要把Virtual DOM渲染成真正的DOM,我们看一下Vue.js 2.0 是怎么做的。

2. VNode patch生成DOM

在Vue.js 2.0中,VNode转换成真正的DOM是通过patch(oldVnode, vnode, hydrating)方法 实现的,来看一下patch方法。源码定义如下：

<!"－－源码目录：src/core/vdom/patch.js-->

return function patch (oldVnode, vnode, hydrating) { let elm, parent

const insertedVnodeQueue = [] if (! oldVnode) {

306 Vue.js权威指南

// empty mount, create new root element createElm(vnode, insertedVnodeQueue)

} else {

const isRealElement = isDef(oldVnode.nodeType)

if (! isRealElement && sameVnode (oldVnode, vnode)) { patchVnode(oldVnode, vnode, insertedVnodeQueue)

} else {

if (isRealElement) {

// mounting to a real element

II check if this is server-rendered content and if we can perform II a successful hydration.

if (oldVnode. hasAttribute ('server-rendered')) { oldVnode. removeAttribute ('server-rendered')

hydra七ing = true

if (hydrating) {

if (hydrate (oldVnode, vnode, insertedVnodeQueue)) { invokeinsertHook(insertedVnodeQueue)

return oldVnode

} else辽(process. env. NODE_ ENV ! =='production') (

warn(

'The client-side rendered virtual DOM tree is not matching'+ 'server-rendered content. Bailing hydration and performing'+ 'full client-side render.'

// either not server-rendered, or hydration failed. // create an empty node and replace it

oldVnode = ernptyNodeA七(oldVnode)

elm= oldVnode.elm

parent= nodeOps.parentNode(elm) createElm(vnode, insertedVnodeQueue) 江(parent ! == null) {

nodeOps.inser七Before(parent, vnode.elm, nodeOps.nextSibling(elm)) removeVnodes (parent, [ oldVnode], 0, 0)

} else if (isDef(oldVnode.tag)) {

invokeDestroyHook(oldVnode)

第18章Vue.js 2.0 307

invokeinsertHook(insertedVnodeQueue) return vnode.elm

patch方法支待3个参数,其中oldVnode是一个真实的DOM或者一个VNode对象,它表 示当前的VNode; vnode是VNode对象类型,它表示待替换的VNode; hydrating是bool类型, 它表示是否直接使用服务端渲染的DOM元素,因为Vue.js 2.0也支持服务端渲染。我们可以通 过流程图看一下patch方法的运行逻辑,如图18-5所示。

图18-5 patch方法运行逻辑图

patch方法的运行逻辑看上去比较复杂,其中有两个方法create Elm和patchVnode是生成

308 Vue.js权威指南

DOM的关键。源码定义如下：

< !" －－源码目录：src/core/vdom/patch.js-->

function createElm (vnode, insertedVnodeQueue) { let i, elm

const data= vnode.data if (isDef(da七a)) {

if (isDef(i = data.hook) && isDef(i = i.init)) i(vnode)

// after calling the init hook, if the vnode is a child component // it should've created a child instance and mounted it. the child // component also has set the placeholder vnode's elm.

// in that case we can just return the elemen七and be done. if (isDef(i = vnode.child)) {

invokeCreateHooks(vnode, insertedVnodeQueue) setScope(vnode)

return vnode.elm

const children= vnode.children cons七七ag = vnode.tag

江(is Def (tag)) (

elm= vnode.elm = vnode.ns

? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(七ag) setScope(vnode)

if (Array.isArray(children)) {

for (i = 0; i < children.length; ++i) {

nodeOps.appendChild(elm, createElm(children[i], insertedVnodeQueue))

} else if (isPrimitive(vnode.text)) {

nodeOps.appendChild(elm, nodeOps.createTextNode(vnode.text))

if (isDef(data)) {

invokeCreateHooks(vnode, insertedVnodeQueue)

} else {

elm= vnode.elm = nodeOps.createTextNode(vnode.七ext)

return vnode.elm

第18章Vue.js 2.0 309

function pa七chVnode (oldVnode, vnode, insertedVnodeQueue) { 辽(oldVnode === vnode) return

let i, hook

江(isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {

i(oldVnode, vnode)

const elm= vnode.elm = oldVnode.elm cons七oldCh = oldVnode.children

cons七ch= vnode.children

辽(is Def (vnode. data)) {

for (i· = O; i < cbs.update.length; ++i) cbs.upda七e [i] (oldVnode, vnode) 江(isDef(hook) && isDef(i = hook.update)) i(oldVnode, vnode)

if (islJndef (vnode. text)) {

if (isDef (oldCh) && is Def (ch)) {

if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue) } else if (isDef (ch)) {

if (is Def (oldVnode. text)) nodeOps. setTextContent (elm,'') addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) } else if (isDef (oldCh)) {

removeVnodes(elm, oldCh, 0, oldCh.length - 1) } else if (isDef(oldVnode.text)) {

nodeOps. setTextContent (elm,'')

) else if (oldVnode. text 1 == vnode. text) { nodeOps.setTextContent(elm, vnode.text)

if (isDef(vnode.data)) {

for (i = 0; i < cbs.postpatch.length; ++i) cbs.pos七patch [i] (oldVnode, vnode) 辽(isDef(hook) && isDef(i = hook.postpatch)) i(oldVnode, vnode)

(1) createElm(vnode, insertedVnodeQueue)

该方法会根据vnode的数据结构创建真实的DOM节点,如果vnode有children,则会遍历 这些子节点,递归调用createElm方法。lnsertedV nodeQueue是记录子节点创建顺序的队列,每 创建一个DOM元素就会往这个队列中插入当前的VNode。当整个VNode对象全部转换成为真 实的DOM树时,会依次调用这个队列中VNode hook的insert方法。

310 Vue.js权威指南

(2) patchVnode(oldVnode, vnode, insertedVnodeQueue)

该方法会通过比较新旧VNode节点,根据不同的状态对DOM做合理的更新操作(添加、 移动、删除等),整个过程还会依次调用prepatch、update、postpatch等钩子函数。在编译阶段 生成的一些静态子树,在这个过程中由千不会改变而直接跳过比对。动态子树在比较过程中比 较核心的部分就是当新旧VNode同时存在children,通过updateChildren方法对子节点做更新。 Vue.js 2.0在这块的实现很精彩,接下来我们重点看一下这个方法的实现。源码定义如下：

<'-－源码目录：src/core/vdom/patch.js-->

function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue) { let oldStartidx = 0

let newStartidx = 0

let oldEndidx = oldCh.length - 1 let oldStartVnode = oldCh[O]

let oldEndVnode = oldCh[oldEndidx] let newEndidx = newCh.length - 1 let newStartVnode = newCh[O]

let newEndVnode = newCh[newEnd工dx]

let oldKeyToidx, idxinOld, elmToMove, before

while (oldStartidx <= oldEndidx && newStartidx <= newEndidx) { if (isUndef (oldStartVnode)) {

oldStartVnode = oldCh[++oldStartidx] // Vnode has been moved left ) else if (isUndef (oldEndVnode)) {

oldEndVnode = oldCh[--oldEndidx]

) else if (sameVnode (oldStartVnode, newStartVnode)) {

patchVnode(oldStartVnode, newStartVnode, inser二edVnodeQueue) oldStartVnode = oldCh[++oldStartidx]

newStartVnode = newCh[++newStartidx]

) else if (sameVnode(oldEndVnode, newEndVnode)) { patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue) oldEndVnode = oldCh[--oldEndidx]

newEndVnode = newCh[--newEndidx]

) else江(sameVnode (oldStartVnode, newEndVnode)) { // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)

nodeOps. insertBefore (parentElm, oldStartVnode. elm, nodeOps. nextSibling (oldEndVnode. elm)) oldStartVnode = oldCh[++oldStartidx]

newEndVnode = newCh[--newEndidx]

) else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)

第18章Vue.js 2.0 311

nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndidx]

newStartVnode = newCh[++newStartidx]

} else {

if (isUndef (oldKeyToidx)) oldKeyToidx = createKeyToOldidx (oldCh, oldStartidx, oldEndidx)

idxinOld = oldKeyToidx[newStartVnode.key] if (isUndef (idxinOld)) { // New element

nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm)

newStartVnode = newCh[++newStartidx]

} else {

elm.ToMove = oldCh [ idxinOld] /* istanbul ignore if*/

江(process. env. NODE_ ENV ! =='production'&& ! elmToMove) { warn (

'It seems there are duplicate keys tha七is causing an update error.'+ 'Make sure each v-for i七em has a unique key.'

if (elmToMove. tag ! == newStartVnode. tag) {

II same key but different element. treat as new element

nodeOps.insertBefore(paren七Elm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm)

newStartVnode = newCh[++newStartidx]

) else {

patchVnode(elmToMove, newStartVnode, insertedVnodeQueue) oldCh [ idxinOld] = undefined

nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm) newStartVnode = newCh[++newStartldx]

if (oldStartidx > oldEndidx) [

before= isUndef(newCh[newEndidx + 1]) ? null : newCh[newEndidx + l].elm

addVnodes(parentElm, before, newCh, newStar七Idx, newEndidx, inse工tedVnodeQueue) ) else if (newStartidx > newEndidx) {

removeVnodes(parentElm, oldCh, oldStartidx, oldEndidx)

312 Vue.js权威指南

updateChildren这个方法看上去比较复杂,它主要通过while循环一遍遍对比两棵树的子节 点来更新DOM。为了更加直观地理解整个比较更新过程,我们可以通过一个例子来模拟一下。

假设有新旧两棵树,树中的了节点分别用a、b、c、d等代号表示,不同的代号代表不同的 VNode。初始状态如图18-6所示。

t

oldStartldx:0

oldStartVnode:a

t

oldEndldx:3

oldEndVnode:d

t

newStartldx:0

newStartVnode:a

b 3e d 。 x

Idn dv nd

n E

wE ew

e n \0,

n ＼

图18-6 新旧VNode子节点更新一一初始状态

在设置好初始状态后,我们开始第一遍比较。此时oldStartYnode为a, newStartYnode也为 a,命中了sameVnode(oldStartVnode, newStartVnode)逻辑,则直接调用patchVnode (oldStartVnode, newStartVnode, insertedVnodeQueue)方法更新节点a。接着把oldStartldx和newStartldx索引分别 +I,形成状态如图18-7所示。

t

t

oldStartldx:1 oldEndldx:3

oldStartVnode:b oldEndVnode:d

．

t t

newStartldx:1 newEndldx:3

newStartVnode:d newEndVnode:b

图18-7 新旧VNode子节点更新 step I

更新完节点a后,我们开始第二遍比较。此时oldStartYnode为b, newEndYnode也为b, 命中了same Vnode(oldStartV node, newEndVnode)逻辑,则调用patch V node(oldStartVnode,

第18章Vue.js 2.0 313

newEndVnode, insertedVnodeQueue)方法更新节点b。接着调用nodeOps. insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))方法把节点b移到树的最右边。最后 把oldStartldx索引＋1, newEndldx索引－l,形成状态如18-8所示。

t t

oldStartldx:2 oldEndldx:3

oldStartVnode:c oldEndVnode:d

newStartldx:1 newEndldx:2 newStartVnode:d newEndVnode:e

图18-8 新旧VNode子节点更新 step2

更新完节点b后,我们开始第三遍比较。此时oldEndVnode为d, newStartVnode也为d, 命中了same V node(oldEndV node, newStartV node)逻辑,则调用patch V node(oldEndV node, newStartYnode, insertedVnodeQueue)方法更新节点d。接着调用nodeOps. insertBefore(parentElm, oldEndYnode.elm, oldStartVnode.elm)方法把节点d移到节点c的左边。最后把oldEndldx索引－I, newStartldx索引＋I,形成状态如18-9所示。

tt

oldStartldx:2 oldStartVnode:c oldEndldx:2 oldEndVnode:c

newEndldx:2 newEndVnode:e newStartldx:2 newStartVnode:e

图18-9 新旧VNode子节点更新 step3

更新完节点d后,我们开始第四遍比较。此时newStartVnode为e,节点e在旧树里是没有 的,因此应该被作为一个新元素插入,调用nodeOps.insertBefore(parentElm, createElm

314 Vue.js权威指南

(newStartYnode, insertedVnodeQueue), oldStartVnode.elm)方法把节点e插入到节点c之前。接着 把newStartldx索引＋1,形成状态如18-10所示。

tt

oldStartldx:2 oldStartVnode:c oldEndldx:2 oldEndVnode:c

t

t

newEndldx:2 newStartldx:3 newEndVnode:e newStartVnode:b

图18-10 新旧VNode子节点更新一step4

插入节点e后,我们可以看到newStartldex已经大于newEndldx了,while循环已经完毕。

接着调用removeVnodes(parentElm, oldCh, oldStartldx, oldEndidx)删除旧树中剩余的节点C,最终 形成状态如18-11所示。

／

t t

oldStartldx:2 oldStartVnode:c oldEndldx:2 oldEndVnode:c

newEndldx:2 newStartldx:3 newEndVnode:e newStartVnode:b

图18-11 新旧VNode子节点更新 更新完成

updateChildren通过以上几步操作完成了旧树子节点的更新,可以看到实际上只用了一些比 较小的DOM操作,比起用innerHTML直接替换所有子节点这种方法,在性能上有所提升,并 且当子节点越复杂时,这种提升效果就越明显。

VNode通过patch方法生成DOM后,会调用mounted hook。至此,整个Vue实例就创建 完成了。当这个Vue实例的Watcher观察到数据变化时,会再次调用render方法生成新的VNode, 接着调用patch方法对比新旧VNode来更新DOM。

第18章Vue.js 2.0 315

Vue.js 2.0使用了Virtual DOM技术,除了在数据变化一更新DOM这块有性能方面的提 升外,还可以很好地支持服务端渲染技术。接下来就让我们看一下Vue.js 2.0的另一大亮点一 服务端渲染技术。这里我们只分析实现原理,具体使用需要等到Vue.js 2.0正式发布后。

18.3 服务端渲染技术

Vue.js l.x版本提倡组件化开发模式,把页面拆分成一个个Vue组件,页面渲染工作交给前 端JS完成。Vue.js 2.0提供了服务端渲染技术,服务端渲染比起客户端渲染页面,有以下几点 优势：

1.首屏渲染速度更快

客户端渲染的一个缺点是,用户第一次访问页面,此时浏览器没有缓存,需要先从服务端 下载JS。然后再通过JS操作动态添加DOM并渲染页面,时间较长;而服务端渲染则是,用户 第一次访问浏览器可以直接解析HTML文档并渲染页面,首屏渲染速度要比客户端渲染快。

2. SEO

服务端渲染可以让搜索引擎更容易读取页面的meta信息,以及其他SEO相关信息,大大 增加了网站在搜索引擎中的可见度。

3.减少HTTP请求

服务端渲染可以把一些动态数据在首次渲染时同步输出到页面;而客户端渲染需要通过 AJAX等手段异步获取这些数据,这样就相当千多了一次HTTP请求。

Vue.js 2.0提供了两种服务端渲染方式,即普通服务端渲染和流式服务端渲染。接下来让我 们看一下这两种服务端渲染的原理。

18.3.1 普通服务端渲染

Vue.js 2.0提供了renderToString接口,可以在服务端把Vue组件渲染成模板字符串。我们 先看一下renderString的用法,源码定义如下：

< !" －－源码目录：benchmarks/ssr/renderToString.js--> const Vue= require('.. /.. /dist/vue.common.js')

const createRenderer =require('.. /.. /packages/vue-server-renderer') const renderToString = createRenderer().renderToString

con st gridComponent = require ('. /common. j s')

316 Vue.js权威指南

console.log('--- renderToString ---') cons七self = (global I I root)

self.s = self.performance.now()

renderToString (new Vue (gridComponent), () => {

console.log('Complete time:'+ (self.performance.now() - self.s).toFixed(2) +'ms') console. log ()

这段代码是运行在Node.js环境中的,主要依赖vue.common.js、vue-server-render。其中 vue.common.js是Vue运行时代码,不包括编译部分;vue-server-render对外提供createRenderer 方法,renderToString是create Renderer方法返回值的一个属性,它支持传入Vue实例和渲染完 成后的回调函数。这里要注意,由千引用的是只包含运行时的Vue代码,不包括编译部分,所 以Vue实例必须包含明确的render方法。渲染完成后的回调函数支持两个参数,即err和result, 其中err表示是否出错;result表示DOM字符串。在实际应用中,我们可以将从回调函数拿到 的result拼接到模板中。接下来我们看一下renderToString的实现,源码定义如下：

<'－－源码目录：src/server/create-render.js-->

const render= createRenderFunc巨on(modules, directives, isUnaryTag) return {

renderToString ( component: Component,

done: (err: ?Error, res: ?string) => any

) : void {

let result=''

let stackDepth = 0

const write= (str: s七ring, next: Function) => { result+= str

辽(stackDepth >= MAX STACK DEPTH) { process. next Tick (() => {

try {next()} catch (e) { done(e)

})

} else { stackDepth++ next() stackDepth--

try {

第18章Vue.js 2.0 317

render (component, write, () => ( done(null, result)

})

} catch (e) ( done(e)

},

renderToString方法支待传入Vue实例component和渲染完成后的回调函数done。它定义了 result变揽,同时定义了write方法,最后执行render方法。render方法的功能是把component 转换成模板字符串str,写入write方法中。write方法不断拼接模板字符串,用result变瞿做存 储,然后调用next方法。当component通过render渲染模板字符串完毕后,执行done,传入result。 整个过程比较核心的步骤就是render方法,我们看一下它的实现,源码定义如下：

<!-－源码目录：src/server/render.js--> return function render (

component: Component,

write: (text: s七ring, nex七：Function) => void, done: Function

) (

renderNode(component. render(), write, done, true)

render方法实际上是执行了render Node方法,并把component—render()方法生成的YNode 对象作为参数传入。renderNode方法定义如下：

< !" －－源码目录：src/server/render.js--> func七ion renderNode (

node: VNode,

write: Function,

next: Function,

isRoot: boolean

) {

辽(node. componentOptions) ( canst child= getCachedComponent (node) I I

createComponen七InstanceForVnode(node). render() child.parent= node

renderNode(child, write, next, isRoot) ) else (

318 Vue.js权威指南

江(node. tag) {

renderElement(node, write, next, isRoot) } else {

write(node.raw? node.text : encodeHTMLCached(node.text), next)

renderNode方法首先判断node类型。如果是一个component VNode,则根据这个node创 建一个组件的实例并调用＿render方法作为当前node的child VNode,然后递归调用renderNode 方法;如果是一个普通的DOMVNode对象,则调用render Element渲染元素;否则就是一个文 本节点,直接调用write方法。这里使用了getCachedComponent方法尝试从缓存中拿VNode实 例,对千具有相同cid的component VNode,我们只创建一次。真正把VNode对象渲染成DOM 对象的方法是renderElement,源码定义如下：

< !" －－源码目录：src/server/render.js--> function renderElement (

el: VNode,

write: Function, next: Function,

lSROO七：boolean

) {

if (isRoot) {

if ('el.data) el.data={)

if (!el.data.attrs) el.data.attrs = {) el.data.attrs['server-rendered'] ='true'

const startTag = renderStartingTag(el) const endTag =、</${el.七ag}>、

if (isUnaryTag (el. tag)) {

write(startTag, next)

} else if (1 el. children I I ! el. children. length) { write(startTag + endTag, next)

} else {

const children: Array<VNode> = el. children I I [) write (startTag, () => {

const total= children.length let rendered= 0

func七ion renderChild (child: VNode) { renderNode (child, write, () => (

第18章Vue.js 2.0 319

rendered++

if (rendered < total) ( renderChild(children[rendered]) } else (

write(endTag, next)

}, false)

renderChild(children[OJ)

})

render Element方法的主要功能是把VNode对象渲染成DOM元素,我们先看一下它的流程 图,如图18-12所示。

no

图18-12 renderElement渲染DOM元素流程图

renderElement首先判断元素是否是根元素,如果是则给元素添加server-rendered属性。接

320 Vue.js权威指南

下来渲染开始标签,并对开始标签类型进行判断,如果是自闭合标签如<img>、<input>这样的, 则直接通过write方法写入开始标签,再执行next方法,DOM渲染完毕。如果元素没有子元素 且又不是自闭合标签,则直接通过write方法写入开始标签和闭合标签,再执行next方法,DOM 渲染完毕;否则就通过write方法写入开始标签,接着调用renderNode方法渲染所有子节点, 再通过write方法写入闭合标签,最后执行next方法,DOM渲染完毕。

18.3.2 流式服务端渲染

流式服务端渲染算是Vue.js 2.0在服务端渲染上的一大亮点。普通服务端渲染有一个痛点一 由于渲染是同步过程,所以如果这个App很复杂的话,它可能会阻塞服务器的event loop,同 步服务器渲染在优化不当时甚至会给客户端获得内容的速度带来负面影响。Vue.js 2.0提供了 renderToStream接口,在渲染组件时返回一个可读的stream,可以直接pipe到HTTP Response 中。流式渲染能够确保服务端响应度,也能让用户更快地获得渲染内容。我们先看一下 renderToStream的用法,源码定义如下：

< !" －－源码目录：benchmarks/ssr/renderToStream.js--> const Vue= require('.. /.. /dist/vue.common.js')

const createRenderer =require('.. /.. /packages/vue-server-renderer') const renderToStream = createRenderer().renderToStream

const gridComponent = require('./common.js')

console.log('--- renderToS七ream ---')

const self = (global I I root)

self.s = self.performance.now()

const stream= renderToS七ream(new Vue(gridComponent)) let str ='『

const sta七s = []

stream. on ('data', chunk => {

str += chunk stats.push(self.performance.now()) ))

stream.on('end', () => { stats.push(self.performance.now()) stats. forEach ((val, index) => {

const type= index !== stats.length - 1 ?'Chunk':'Complete'

console.log(type +'巨me:'+ (val - self.s).toFixed(2) +'ms')

))

console. log ()

))

第18章Vue.js 2.0 321

这段代码也是同样运行在Node.js环境中的,与renderToString不同,renderToStream会把 Vue实例渲染成一个可读的stream。源码演示的是监听数据的读取,并记录读取数据的时间。 而在实际应用中,我们可以这样写,代码示例如下：

canst Vue = require ('.. /.. /dist/vue. common. j s')

canst createRenderer =require('.. /.. /packages/vue-server-renderer') canst renderToStream = createRenderer().renderToStream

canst gridComponent = require('./common.js')

cons七stream= renderToStream(new Vue(gridComponent)) app.use(function(req, res) {

stream.pipe(res)

如果代码运行在Express框架中,则可以通过app.use方法创建middleware,然后直接把 stream pipe到res中,这样客户端就能很快地获得渲染内容了。接下来我们看一下renderToStream 的实现,源码定义如下：

<'－－源码目录：src/server/create-render.js-->

canst render; createRenderFunction(modules, directives, isUnaryTag) return {

renderToStream (component: Component): RenderStream { return new RenderStream ((wri七e, done) => { render(component, write, done)

})

renderToStream传入一个Vue对象实例,返回的是一个RenderStream对象的实例。我们来 看一下RenderStream对象的实现,源码定义如下：

<'－－源码目录：src/server/render-stream.js--> import stream from'stream'

import { MAX_STACK_DEPTH) from'./create-renderer' ／ ＊ ＊

Original RenderStream implmentation by Sasha Aic虹n (@aic虹n)
Licensed under七he Apache License, Version 2.0
Modified by Evan You (@yyx990803) ＊／
export default class RenderStream extends stream.Readable {

322 Vue.js权威指南

buffer: string; render: Function; expectedSize: number; stackDepth: number; write: Function; next: Function;

end: Function;

done: boolean;

constructor (render: Function) { super()

this. buffer ='' this.render= render this.expectedSize = 0 this.stackDepth = 0

this.write= (text: string, next: Function) => { cons七n = this.expectedSize

this.buffer+= text

if (this.buffer.leng七h >= n) { this.next= next this.pushBySize(n)

} else {

// continue rendering until we have enough text to call this.push().

// sometimes do this as process.nextTick to get out of stack overflows. 江(this.stackDepth >= MAX_STACK_DEPTH) {

process.nextTick(() => {

try { next() } catch (e) { this.emit('error', e)

})

} else { this.stackDepth++ next()

七his.stackDepth--

this. end = () => {

//七he rendering is finished; we should push out the last of the buffer.

第18章Vue.js 2.0 323

this.done= true this.push(this.buffer)

pushBySize (n: number) {

const bufferToPush = this.buffer.substring(O, n) this.buffer=七his.buffer.substring(n) this.push(bufferToPush)

tryRender () { try {

this.render(this.write, this.end) } catch (e) {

this.emit('error', e)

tryNext () { try { this.next() } catch (e) {

this.emit ('error', e)

read (n: number) { this.expectedSize = n

// it's possible that the last chunk added bumped the buffer up to> 2 * n, // which means we will need to go through multiple read calls to drain it // down to< n.

1f (七his.done) {

this.push (null) return

if (this. buffer. length >= n) ( this.pushBySize(n)

return

if ('this.next) {

// start the rendering chain.

324 Vue.js权威指南

this.tryRender{) } else {

// continue with the rendering. this.tryNex七()

RenderStream继承了node中的可读流stream.Readable,它是一个自定义的可读流。所有可 读流的实现都必须提供一个＿read方法从底层资源抓取数据。注意,这个方法是以下画线开头的, 表明它是一个内部方法,并且不应该被用户程序直接调用。可读流通过push方法向队列中插入 一些数据,而且至少需要调用一次push(chunk)方法,—read方法才会再次被调用。当push方法 传入null参数时,它会触发数据结束信号CEOF)。接下来我们详细介绍一下RenderStream类 的实现。

1. Constructor(render)

构造函数方法首先通过super方法调用了父类的构造函数,以便缓冲设定能被正确地初始 化,然后初始化buffer、expectedSize、stackDepth、render等字段。其中buffer表示缓冲区字符 串;expected Size为每次期望往读取队列中插入内容的大小;stackDepth记录write方法递归调 用的深度;render保存传入的render方法。最后分别定义了write和end方法。

2. Write(text, next)

write方法首先把text拼接到buffer缓冲区,然后判断buffer. length。如果buffer.length大 于expectedS ize,则用this.next保存next方法,同时调用this.pushBySize(n)把缓冲区内容推入 读取队列中;如果buffer. length小千expectedSize,则调用next方法继续渲染组件,在调用next 之前会判断stackDepth的大小;如果stackDepth大于或等千M心(—STACK—DEPTH,则说明 write方法递归调用的深度已经超过设定值,通过process.nextTick的方式调用next方法,避免 堆栈溢出。

3. end

end方法设置this.done标志位为true,标识组件的渲染已经完毕。接着调用this.push(buffer) 方法把缓冲区剩余内容推入读取队列中。

4. _read(n)

我们先来看一下它的实现逻辑,如图18-13所示。

第18章Vue.js 2.0 325

this.expectedSize=n

yes

n气0-

yes

图18-13

read方法实现逻辑图

_read(n)方法首先通过this.expectedSize=n记录了本次读取的字节数,然后判断this.done。

如果为true则表示组件已渲染完毕,这时候调用this.push(null)触发数据结束信号(EOF)。如果 渲染未完成,接下来判断this.buffer.length。如果大千n则说明缓冲区的字符串长度足够,可以 调用this.pushBySize(n)方法把缓冲区内容推入读取队列中;如果this. buffer. length小于n,接下 来判断this.next。如果为false则表示开始渲染组件,调用this.tryRender()开始渲染组件;否则 调用this.tryNext()继续渲染组件。

5. PushBySize(n)

pushBySize方法截取buffer缓冲区前n个长度的数据,推入到读取队列中,同时更新buffer 缓冲区,删除前n条数据。

6. tryRender

tryRender方法调用this.render(this. write, this.end)方法开始渲染组件,这个render方法是在 初始化Read Stream方法时传入的,源码定义如下：

renderToStream (component: Component): RenderStream { return new RenderStream((write, done) => { render(component, write, done)

})

这个方法中调用的render(cornponent,write,done)和renderToString使用的render方法是同一

326 Vue.js权威指南

个,只不过这里的write和done对应的是RenderToStream类里定义的this.write和this.end方法。 7. tryNext

tryNext方法调用this.next()方法继续渲染组件。

最后简单做一下回顾。首先先调用renderToStream(new Vue(option))创建好stream对象后, 通过stream.pipe()方法把数据发送到一个WritableStream中,会触发RenderToStream内部＿read 方法的调用,不断把渲染的组件数据推入读取队列中,这个WritableStream就可以不断地读取 到组件的数据,然后输出。这样就实现了流式服务端渲染技术。

18.4 总结

本章首先介绍了Vue.js 2.0相对千l.x版本的API变更,让我们了解到Vue.js 2.0在API设 计上更加简洁,新手上手成本更低,更易千掌握框架。接着介绍了Vue.js 2.0的两大新特性一— Virtual DOM和服务端渲染。了解这些技术的实现原理和细节,会对我们今后使用Vue.js 2.0进 行开发,遇到一些性能优化的场景时有一定的帮助。

第19章

源码篇——util

Vue.js内部封装了util,提供了一些常用的工具方法。了解本章内容,可以避免开发者再额 外引用第三方框架增加代码量。util一共分成6部分：env、dom、components、lang、debug和 options,整体结构如图19-1所示。

图19-1 util整体结构

19.1 env

env如图19-2所示。

ne让Tick

．．

t,an,itionEndEvent'-- •••

anim·廿onP,op

on,motionEndEvent

图19-2 env

328 Vue.js权威指南

19.1.1 系统判断

1. inBrowser

判断是否为浏览器环境,源码定义如下：

< !" －－源码目录：src/ut辽／env. j s 7行－－> export const inBrowser =

typeof window !=='undefined'&&

Object. prototype. toString. call (window) ! =='[object Object)'

2. islE9

判断是否为IE 9,源码定义如下：

<!" －－源码目录：src/ut旦／env.js 16行－－>

const UA = inBrowser && window.navigator.userAgent.toLowerCase() export const isIE9 = UA && UA.indexOf('msie 9.0') > 0

3. isAndroid

判断是否为安卓,源码定义如下：

< !" －－源码目录：src/util/env.js 17行－－>

expor七const isAndroid = UA && UA.indexOf('android') > O

4. islos

判断是否为iOS,源码定义如下：

< !" －－源码目录：src/ut旦／env.js 18行－－>

export const isios = UA && /(iphonelipadlipodlios)/i.test(UA)

5. isWechat

判断是否为微信,源码定义如下：

<'-－源码目录：src/util/env.js 19行－－>

export const isWechat = UA && UA.indexOf('micromessenger') > 0

19.1.2 属性支持

hasProto 是否支持__proto—属性,源码定义如下：

< !" －－源码目录：src/ut旦／env.js 7行－－>

expor二const hasProto ='—proto_'in {}

第19章源码篇一util 329

19.1.3 过渡属性

1. transitionProp

<!"－－源码目录：src/util/env.js 34行－－> canst isWebkitTrans =

window.ontransi巨onend === undefined && window.onwebkittransitionend 1== undefined canst isWebkitAnim =

window.onanimationend === undefined &&

window.onwebkitanima巨onend 1== undefined transi巨onProp = isWebk江Trans

?'Webki tTransi tion':'transition'

2. transitionEndEvent

transitionend事件在CSS过渡完成后触发。

注：如果过渡在完成前被移除,例如CSS transition-property属性被移除,过渡事件将不被 触发。

<'－－源码目录：src/util/env.js 37行－－>

transitionEndEvent ; isWebkitTrans?'webkitTransitionEnd':'transi巨onend'

3. animationProp

CSS动画效果将会影响元素相对应的css值,在整个动画过程中,元素的变化属性值完全 是由animation控制的,动画后面的属性值会覆盖前面的属性值。animation类似千transition属 性,它们都是随着时间改变元素的属性值。其主要区别是transition需要触发一个事件(hover 或click事件等)才会随时间改变其css属性值;而animation在不需要触发任何事件的情况下 也可以显式地随着时间变化来改变元素的css属性值,从而达到一种动画效果。

<!" －－源码目录：src/util/env.js 40行－－>

animationProp = isWebkitAnim?'WebkitAnimation':'animation'

4. animationEndEvent

animationend事件在CSS动画完成后触发。

<'－－源码目录：src/u巨1/env.js 43行－－>

animationEndEvent = isWebk江Anim?'webkitAnimationEnd':'animationend'

330 Vue.js权威指南

1 9. 1.4 nextTick

异步执行,在Vue.js内部,Vue.js会使用Mutation Observer来实现队列的异步处理,如果 不支持则会回退到setTimeout(fn, 0)。当Vue.nextTick的回调函数执行时,DOM已经是更新后 的状态了。

0 cb {Function}

0 ctx {Object}

< I -－源码目录：src/util/env.js 65行－－> (function () (

var callbacks = [] var pending= false var timerFunc

function nextTickHandler () { pending= false

var copies= callbacks.slice(O) callbacks = [ l

for (var i = 0; i < copies.length; i++) { copies [i] ()

if (typeof Mu七ationObserver'=='undefined'&& ! (isWechat && isios)) { var counter= 1

var observer= new MutationObserver(nextTickHandler) var tex七Node= document.createTextNode(counter)

observer.observe(七extNode, {

charac七erData: true

))

timerFunc = func芦on () ( counter = (counter + 1) % 2 textNode.data = counter

} else {

// webpack attempts to inject a shim for setimmediate

// if it is used as a global, so we have to work around that to

第19章源码篇一—util 331

// avoid bundling unnecessary code. const context= inBrowser

? window

: typeof global !=='undefined'? global : {} t耳nerFunc = context. set Immediate I I set Timeout

return function (cb, ctx) { var func = ctx

? function () { cb. call (c七x) } : cb

callbacks.push(func)

if (pending) return

pending= true tirnerFunc(nextTickHandler, 0)

}) ()

Vue实例的$nextTick方法其实调用的就是此方法,源码定义如下：

<'－－源码目录：src/instance/api/dom.js 25行－－> Vue. prototype. $next Tick = function (fn) ( nextTick(fn, this)

Vue.js的过渡动画队列同样使用此方法,源码定义如下：

<'－－源码目录：src/transi巨on/queue.js 12行－－> function pushJob (job) {

queue.push(job)

辽(!queued) {

queued= true

next Tick (flush) // flush方法为执行队列所有方法,在过渡之前

Vue.js的v-text指令中也使用了此方法,源码定义如下：

< !" －－源码目录：src/derictives/public/model/text.js 111行－－> if (!lazy && isIE9) {

this. on ('cut', function () { nextTick(self.listener)

332 Vue.js权威指南

})

this.on('keyup', function (e) {

if (e. keyCode === 4 6 I I e. keyCode === 8) { self. listener()

})

19.1.5 set

创建set简单对象,挂载属性set、add、clear、has方法。目前暂时在watcher.js中使用,源 码定义如下：

<'-－源码目录：src/util/env.js 131行－－>

if (typeof Set 1=='undefined'&& Set.toString().match(/native code/)) { // use native Set when available.

Set= Set } else {

II a non-standard Set polyfill that only works with primitive keys.

Set = function () {

this.se七＝Object.create(null)

Set. prototype. has = function (key) { return this. set [ key] ! == undefined

Set. prototype. add = function (key) { this.set[key] = 1

Set. prototype. clear = function () { this.set= Object.create(null)

19.2 dom

在本节中,我们将分5部分进行详细的讲解,如图19-3所示。

第19章源码篇——util 333

＿

findRef

mapNode心nge

一．fter

,emoveNode肛nge

- prepend

户一 replace

一．xt,actContent

~~ trimNode

一－,,Templ•te

isfragment

gotOute出TML

图19-3 dom

19.2.1 dom操作 1. query

查找dom元素,使用document.querySelector方法返回文档中匹配指定CSS选择器的元素 集合中的第一个元素(兼容IE 8及以上版本)。

0 el {StringlElement}

<!"－－源码目录：src/util/dorn.js 14行－－> function query (el) {

辽(typeof el==='string') { var selector= el

el= docurnent.querySelector(el) if (!el) {

process.env.NODE_ENV !=='produc巨on'&& warn( 'Cannot find elernen七：'＋selector

334 Vue.js权威指南

,I.

．

return el

2. inDoc

是否在文档中,运用了ownerDocument.documentElement属性,其中ownerDocument是文 档,documentElement是根节点,ownerDocument下包含两个节点,即doctype和documentElement。

0 node {node}

< !" －－源码目录：src/util/dom.js 39行－－> func巨on in Doc (node) {

if (!node) return false

var doc= node.ownerDocurnent.documentElement var parent= node.parentNode

return doc === node I I

doc === parent I I

! 1 (parent && parent. nodeType === 1 && (doc. contains (parent)))

3. before

在target节点前插入el元素。

0 el {Element}

0 target {Element}

<!" －－源码目录：src/u巨1 / dom. j s 1 0 0行－－>

func巨on before (el, target) { target.parentNode.insertBefore(el, target)

4. after

在target节点后插入el元素。

0 el {Element}

0 target {Element}

<!" －－源码目录：src/ut旦／dom. j s 111行－－> function after (el, target) {

if (target.nextSibling) {

第19章源码篇一util 335

before(el, target.nex七Sibling)

} else { target.parentNode.appendChild(el)

5. prepend

在target节点最前面插入el元素。

0 el {Element}

0 target {Element}

<!" －－源码目录：src/ut辽／dam. j s 136行－－> function prepend (el, target) {

if (target. firstChild) {

before(el, target.firstChild)

) else {

target.appendChild(el)

6. extractContent

将元素内容提取到一个div元素或文本碎片中(取决千asFragment参数)。

0 el {Element}

0 asFragment {Boolean}

<!" －－源码目录：src/util/dom.js 268行－－> function extractContent (el, asFragment) { var child

var rawContent

if (isTemplate (el) && isFragment (el. content)) { el= el.content

if (el. hasChildNodes ()) { trirnNode(el)

rawContent = asFragrnent

? docurnent.createDocurnentFragrnent() : document. createElernent ('div') while (child = el. firstChild) { rawContent.appendChild(child)

336 Vue.js权威指南

return rawContent

Vue.js在组件中内联模板参数使用的该方法,将组件中包含的元素作为内联模板,源码定 义如下：

<'－－源码目录：src/directive/internal/component.js 41行－－> 区nd () {

if ('this.el.—vue_) { // keep-alive cache

this.keepAlive = this.params.keepAlive 江(七his.keepAlive) {

this.cache={}

II check inline-template

if (this.params.inlineTemplate) {

II extract inline template as a DocumentFragment this.inlineTemplate = extractContent(this.el, true)

},

用inlineTemplate赋值给组件的模板template属性,源码定义如下：

< !" －－源码目录：src/directive/internal/component.js 201 --> build (extraOptions) {

var cached = this. getCached () if (cached) {

return cached

江(this. Component) ( // default options var options= {

name: this.ComponentName,

el: cloneNode(七his.el), template: this.inlineTemplate

if (extraOptions) { extend(options, extraOptions)

第19章源码篇一util 337

return child

},

7. remove

删除el元素。

0 el {Element}

< !" －－源码目录：src/ut过／dom.js 125行－－> function remove (el) { el.parentNode.removeChild(el)

8. replace

el元素替换target。

0 target {Element} 0 el {Element}

< !" －－源码目录：src/ut辽／dom.js 151行－－> function replace (target, el) {

var parent= target.parentNode

if (parent) { parent.replaceChild(el, target)

9. trimNode

清除node节点内首尾空文本或注释节点,使用isTrimmable判断是否为空文本或注释节点, 该方法在模板解析中使用最多。

0 node {Node}

<!"－－源码目录：src/ut辽／dom. js 296行－－> function trimNode (node) {

var child;

while (child = node. firstChild, isTrimmable (child)) { node.removeChild(child)

338 Vue.js权威指南

while (child= node.lastChild, isTrirnrnable(child)) { node.rernoveChild(child)

function isTrimmable (node) ( return node && (

(node.nodeType === 3 &&'node.data.trim()) 11 node.nodeType === 8

10. isTemplate

是否为template模板元素。

0 el {Element}

<!" －－源码目录：src/util/dom.js 323行－－>

func巨on isTemplate (el) {

return el.七agName && el.tagName.toLowerCase() ==='template'

11. isFragment

是否为轻量级的Document对象,能够容纳文档的某个部分。

0 node {Node}

<'－－源码目录：src/ut旦／dam. j s 431行－－> func巨on isFragment (node) {

return node && node.nodeType === 11

12. getOuterHTML

获取元素outerHTML,如果不支持则获取innerHTML,用div元素包裹。

0 el {Element}

<!" －－源码目录：src/util/dom.js 443行－－> function getOuterHTML (el) {

if (el. outerHTML) {

return el.outerHTML

} else {

第19章源码篇一util 339

var container = document. createElement ('div') container.appendChild(el.cloneNode(true)) return container.innerHTML

Vue.js只用在FragmentFactory中：

<'－－源码目录：src/fragrnent/factory.js 17行－－> function FragrnentFactory (vrn, el) (

this.vrn = vrn

var template

var isString = typeof el==='string'

if (isString I I is Template (el) && ! el. hasAttribute ('v-if')) ( template= parseTernplate(el, true)

) else (

template= docurnen七．createDocurnentFragrnent() ternplate.appendChild(el)

this.template= template

// linker can be cached, but only for components var linker

var cid = vm.constructor.cid if (cid > 0) {

var cacheid = cid + (isString? el : getOuterHTML(el)) linker= linkerCache.get(cacheid)

辽(I巨nker) {

让．nker = compile(七emplate, vm.$options, true) 巨nkerCache.put(cacheid, linker)

} else {

让nker = comp过e(template, vm.$options, true)

七his.linker= linker

19.2.2 属性操作

1. getAttr

在node元素上获取并移除＿attr属性。

340 Vue.js权威指南

0 node {Node} 。—arrt {String}

< !" －－源码目录：src/util/dom.js 55行－－> function getAttr (node, _attr) {

var val= node.getAttribute(attr) 辽(val ! == null) {

node.removeAttribute(_at七r)

return val

2. getBindAttr

获取：name或v-bind:name的属性值。

0 node {Node}

0 name {String}

<'-－源码目录：src/util/dorn. js 71行－－> function getBindA t tr (node, name) ( var val = getAttr (node,':'+ name) if (val === null) (

val = getAttr (node,'v-bind:'+ name)

return val

此方法在以下情况中使用： CD编译props属性; ＠指令中—setupParams方法;＠获取动态组 件is属性值。我们看一下在指令中的使用方法,源码定义如下：

< !" －－源码目录：src/direc巨ve. j s 193行－－>

Directive.prototype._setupParams = func七ion () { if (!this.params) {

re七urn

var params = this.params this.params = Object.create(null) var i = params.length

var key, val, mappedKey

while (i一一) {

第19章源码篇——util 341

key= hyphenate(params[i]) mappedKey = camelize (key)

val= getBindAttr(this.el, key) if (val != null) {

//为动态参数绑定$watch方法

this._setupParamWatcher(mappedKey, val)

} else {

//静态

val= getAttr(this.el, key) if (val != null) {

this.params(mappedKey) =val===''? true : val

3. hasBindAttr

node元素上是否有绑定的name属性。

0 node {Node}

0 name {String}

<'-－源码目录：src/ut辽／dom. j s 87行－－>

func巨on hasBindAttr (node, name) { return node.hasAttribute(name) II node. hasAttribute (':'+ name) I I node.hasAttribute('v-bind:'+ name)

19.2.3 class捂t1乍

1. setClass

设置class名称(在IE 9中,如果el元素有．class属性,将忽略该class属性;然而在PhantomJS, 设置className无效)。

0 el {Element}

0 els {String}

342 Vue.js权威指南

<'－－源码目录：src/ut辽／dom. js 209行－－> function setClass (el, els) {

if (isIE9 && !/svg$/.test(el.namespaceURI)) { el.className = els

} else {

el. setAttribute ('class', els)

2. addClass

添加className,其中classList属性返回元素的类名,作为DOMTokenList对象,该属性用 于在元素中添加、移除及切换CSS类。classList属性是只读的,但我们可以使用add()和remove() 方法修改它(IE 10及以上版本)。

0 el {Element}

0 els {String}

< !"－－源码目录：src/ut旦／dom. j s 225行－－> function addClass (el, els) {

if (el.classList) { el.classList.add(cls)

} else {

var cur =''+ getClass (el) +''

if (cur.indexOf(''+els+'') < 0) { setClass(el, (cur+ els).trim())

3. removeClass

删除el元素的className,如果没有className,则移除元素的class属性。

0 el {Element}

0 els {String}

<!" －－源码目录：src/ut辽／dom.js 243行－－> function removeClass (el, els) {

辽(el.classLis七) {

el.classList.remove(cls)

第19章源码篇一一util 343

} else {

var cur =''+ getClass (el) +'' var tar =''+ els +''

while (cur.indexOf(tar) >= 0) { cur = cur. replace (tar,'')

setClass (el, cur. trim())

if ('el.className) {

el. removeAttribute ('class')

19.2.4 事件操作

1. on

el绑定event事件监听(useCapture指定事件是否在捕获或冒泡阶段执行,true表示事件句 柄在捕获阶段执行,默认值为false) (IE 9及以上版本)

0 el {Element} 0 event {String} 0 cb {Function}

0 useCapture {Boolean}

<'－－源码目录：src/ut辽／dom. j s 167行－－> function on (el, event, cb, useCapture) { el. addEventListener (event, cb, useCapture)

在指令中使用on绑定事件的代码示例如下：

<!" －－源码目录：src/directive. js 296行－－>

Directive. prototype. on = function (event, handler, useCapture) { on(this.el, event, handler, useCapture)

; (th

is. listeners II (this. listeners=

［ ］))

.push ([event, handler])

344 Vue.js权威指南

2. off

移除事件监听。

0 el {Element} 0 event {String} 0 cb {

Function}

<'-－源码目录：src/ut辽／dom.js 179行－－> function off (el, event, cb) { el.removeEventListener(event, cb)

19.2.5 其他

1. createAnchor

创建一个"执行插入／删除描点",使用场景： O片段实例; ＠v-html: @v-if: @v-for; ＠组件。

0 content { String } 0 persist {Boolean}

<'－－源码目录：src/u口1/dom.js 346行－－>

function createAnchor (content, persist) { var anchor= config.debug

? document.createComment(content)

: document.createTextNode(persis七？''：'') anchor. v anchor= true

return anchor

v-partial的使用如图19-4所示,其他的使用类似。

第19章源码篇-util 345

图19-4 createAnchor

2. findRef

在node元素中找到v-ref绑定的值。

0 node {Element}

< !" －－源码目录：src/util/dom.js 361行－－> var refRE = /Av-ref:/

export function findRef (node) ( if (node.hasAttributes()) (

var attrs = node.attribu七es

for (var i = 0, 1 = attrs. length; i < l; i++) ( var name= attrs[i].name

if (refRE.test(name)) (

re七urn camelize (name. replace (refRE,''))

3. mapNodeRange

在范围兄弟节点内调用op函数。

0 node {Node} 0 end {Node}

。

op {Function}

< !" －－源码目录：src/u巨1/dom.js 382行－－> function mapNodeRange (node, end, op) { var next

while (node ! == end) {

346 Vue.js权威指南

next= node.nextSibling op(node)

node= next

op (end)

4. removeNodeRange

依次移除范围内兄弟元素并移入frag元素中,其中用到了过渡中的remove With Trans山o方 法,整体移除完毕后调用回调函数。

0 start {Node} 0 end {Node} 0 vm {Vue}

0 frag {DocumentFragment} 0 cb {Function}

<!" －－源码目录：src/ut旦／dom.js 404行－－>

function removeNodeRange (start, end, vm, frag, cb) { var done= false

var removed= 0

var nodes = []

//获取start至end的所有兄弟元素

mapNodeRange (start, end, function (node) { if (node=== end) done= true nodes.push(node) removeWithTransition(node, vm, onRemoved)

})

function onRemoved () { removed++

if (done && removed >= nodes. length) {

for (var i = O; i < nodes.length; i++) { frag.appendChild(nodes[i])

cb && cb ()

第19章源码篇——util 347

19.3 lang

lang如图19-5所示。

—hosOwn

extend

n

a ley

ber

mooa NUBArr tololo

---

尸setdel

hyphenate

stripQuotes

comelize

oncelloble

looseEquol

- lsObject

isliterol

一lsPlolnObject

~Rese,vled

def

图19-5 tang

19.3.1 对象操作

1. set

设置对象属性,添加新属性触发更新。

0 obj {Object} 0 key {String} 0 val { *}

<!"－－源码目录：src/util/lang. j s 12行一> function set (obj, key, val) (

if (hasOwn (obj, key)) { //如果是自有属性,为属性赋值,返回

obj[key) = val

348 Vue.js权威指南

return

if (obj. isVue) {//是vue实例,递归调用该函数 set(obj._data, key, val)

return

var ob= obj. ob

辽(!ob) {//不是被监测对象,将val赋值到obj[key] obj[key] = val

return

}

//是被监测对象

ob.convert(key, val)// defineProperty ob.dep.notify()

if (ob.vms) {

var i = ob.vms.length while (i--) {

var vm = ob.vms[i] vm._proxy(key) vm._digest ()

return val

2. del

删除对象属性,触发更新。

0 obj {Object} 0 key {String}

<'－－源码目录：src/u巨1/lang.js 46行－－> function del (obj, key) {

if ('hasOwn(obj, key)) {

return

delete obj [key] var ob = obj. ob

第19章源码篇一util 349

if (!ob) {

if (obj. isVue

) {

delete obj._data[key] obj._digest()

return

ob. dep. notify () if (ob. vms) {

var i = ob.vms.length while (i--) {

var vm = ob.vms[i] vm._unproxy(key) vm._digest()

3. hasOwn

判断是否为自有属性。

0 obj {Object} 0 key {String}

< !" －－源码目录：src/ut过／lang.js 78行－－> function hasOwn (obj, key) {

return Object.prototype.hasOwnProper七y. call (obj, key)

4. extend

扩展对象属性。 0 to {Object}

0 from {Object}

< !" －－源码目录：src/ut旦／lang.js 260行－－> function extend(七o, from) {

var keys= Object.keys(from)

350 Vue.js权威指南

var i = keys.length while (i--) {

to [keys [i]] = from[keys [i]]

return to

5. isObject 是否为对象。

0 obj { *}

<'－－源码目录：src/util/lang.js 278行－－> function isObject (obj) (

return obj !== null && typeof obj==='object'

6. isPlainObject 是否为对象字面量。

0 obj { *}

<'－－源码目录：src/util/lang. j s 2 92行－－> var toString = Object.prototype.toString var OBJECT_STRING ='[object Object]'

func七ion isPlainObject (obj) {

re七urn toString.call(obj) === OBJECT STRING

7. def

将属性添加到对象,或修改现有属性的特性。关千Object.defineProperty详见30.3节。

0 obj {Object}

0 key {String}

0 val { *}

0 enumerable {Boolean}

< !"－－源码目录：src/util/lang.js 314行－－> function def (obj, key, val, enumerable) {

第19章源码篇一util 351

Object.defineProperty(obj, key, { value: val,

enumerable: 1 ! enumerable, writable: true, configurable: true

)) } }

19.3.2 名称转换

1. classify

将、＿、I的命名转换成驼峰命名方式。

0 str {String}

<!" －－源码目录：src/util/lang.js 212行－－> var classifyRE =/(?:Al[-_\/]) (\w)/g function classify (str) {

return str.replace(classifyRE, toUpper)

2. hyphenate

将驼峰命名方式转换为－。

0 str {String}

< !" －－源码目录：src/ut过／lang.js 193行－－> var hyphenateRE = / ([a-z\d]) ([A-Z]) /g export function hyphenate (str) {

return str

. replace (hyphenateRE,'$1-$2') .toLowerCase()

3. camelize

将－命名方式转换驼峰式。

0 str {String}

<!" －－源码目录：src/util/lang.js 176行－－> var camelizeRE = /-(\w)/g

352 Vue.js权威指南

export func巨on camelize (str) {

return str.replace(camelizeRE, toUpper)

19.3.3 数组操作

indexOf—返回obj在Array中的索引位置,没有则返回－l。 0 arr {Array}

0 obj { *}

<'－－源码目录：src/u巨1/lang.js 363行－－> function indexOf (arr, obj) {

var i = arr.length

while伈－－) {

if (arr[i] === obj) return 1

return -1

19.3.4 类型转换

1.—toString

字符串转换。

0 Value { *}

<!-－源码目录：src/util/lang. j s 114行－－> func巨on _toString (value) {

return value== null

？',

: value.toString()

2. toNumber

数字转换。

0 Value { *}

<'－－源码目录：src/ut旦／lang.js 128行－－>

第19章源码篇一util 353

function七oNumber (value) {

辽(typeof value !=='string') { return value

} else {

var parsed= Number(value) return isNaN(parsed)

? value

: parsed

3. toBoolean

布尔转换。

0 Value { *}

<'－－源码目录：src/util/lang.js 146行－－> function七oBoolean (value) {

return value==='true'

? true

: value==='false' ? false

: value

4. toArray 数组转换。

0 Value { *}

< !" －－源码目录：src/ut旦／lang.js 243行一> function toArray (list, start) {

start = start I I 0

var i = list.length - star七 var ret = new Array(i)

while (i一一) {

ret [i] = lis七［i + start]

return ret

354 Vue.js权威指南

19.3.5 方法绑定

bind一方法绑定。 O f

h { Function }

0 ctx {Object}

< I -－源码目录：src/util/lang.js 224行－－> function bind (fn, ctx) {

return function (a) {

var 1 = arguments.length return 1

? 1 > 1

? fn.apply(ctx, arguments) : fn.call(ctx, a)

: fn.call(ctx)

19.3.6 其他

1. debounce

此方法只用千input输入后,wait毫秒后调用func方法。

0 func {Function} 0 wait {Number}

<!" －－源码目录：src/util/lang.js 332行－－>

func巨on debounce (func, wai七) {

var timeout, args, context, timestamp, result var later = function () {

var last= Date.now() - timestamp if (last < wait && last >= 0) {

timeout= setTimeout(later, wait - last)

} else { timeout= null

result= func.apply(context, args) if (!timeout) context= args = null

第19章源码篇一util 355

return function () { context= this

args = arguments

巨me stamp = Date. now () if (!timeout) {

七imeout = setTimeout(later, wait)

return result

2. stripQuotes

去除str中的前后引号。 0 str {String}

<'－－源码目录：src/ut过／lang.js 161行－－> func七ion stripQuotes (str) (

var a= str.charCodeAt(O)

var b = str.charCodeAt(str.length - 1) return a=== b && (a=== Ox22 I I a=== Ox27)

? str.slice(l, -1) : str

参考表19-1。

表19-1 字符表

ASCII	全角字符	Unicode	半角字符	Unicode
Ox20	""空格	U+3000	""空格	U+0020
Ox21	!"	U+ffOI	!"	U+0021
Ox22	',	U+ff02	"	U+0022
Ox23	＃	U+ff1J3	＃	U+0023
Ox24	$	U+ff04	$	U+0024
Ox25	％	U+ff05	％	U+0025
Ox26	＆	U+ff06	＆	U+0026
Ox27	,	U+ff07		U+0027
356 Vue.js权威指南

续表

ASCII	全角字符	Unicode	半角字符	Unicode
Ox28	(	U+ff08	(	U+0028
Ox29	)	U+ff09	)	U+0029
Ox2a	．	U+ff()a	．	U+002a
Ox2b	＋	U+ffOb	＋	U+002b
也可以通过String. fromCharCode()方法来完成。 3. cancellable

可以撤销的异步回调函数。

0 fn {Function}

<'－－源码目录：src/ut辽／lang.js 378行－－> function cancellable (fn) {

var cb = function () {

if (! cb. cancelled) {

return fn.apply(this, arguments)

cb. cancel = function () ( cb.cancelled = true

return cb

4. looseEqual

判断a和b是否相等(非严格意义上的＝＝)。 0 a { *}

0 b { *}

<'－－源码目录：src/ut辽／lang.js 399行－－> func七ion looseEqual (a, b) {

/* eslint-disable eqeqeq */

return a == b I I (

isObject (a) && isObject (b)

? JSON.stringify(a) === JSON.stringify(b) : false

第19章源码篇一一util 357

/* eslint-enable eqeqeq */

5. isliteral

检查表达式是否为字面量。

0 exp {String}

<'－－源码目录：src/u巨1/lang.js 90行－－>

var literalValueRE = /A\s?(truelfalsel-?[\d\.]+I'[A']*'l"[A"]*")\s?$/

function isLiteral (exp) {

return literalValueRE.test(exp)

6. isReserved

检查str是否以$或 开头。

0 str { String }

<!"－－源码目录：src/util/lang.js 101行－－> function isReserved (str) {

var c = (str +'').charCodeAt(O) return c === Ox24 I I c === OxSF

19.4 components

components如图19-6所示。

图19-6 components 1. commonTagRE

是否为普通元素。

<'－－源码目录：src/ut辽／components.js 5行－－>

commonTagRE = /A(divlplspanlimglalblilbrlu1Jolllilh1Jh2Jh3lh41h5lh61codelpreltablelthl tdJtrlformllabellinputJselectloptionJnavJarticlelsec巨onlheaderlfooter)$/i

358 Vue.js权威指南

2. reservedTagRE 是否为自定义元素。

<'－－源码目录：src/ut辽／components. j s 6行－－> reservedTagRE = jA(slottpartiallcomponent)$/i

3. checkComponentAttr

检查el是否为组件,如果是则返回组件凶。

0 el {Element}

0 options {Object}

<!" －－源码目录：src/ut辽／components.js 37行－－> function checkComponen七Attr (el, options) { var tag= el.tagName.toLowerCase()

var hasAttrs = el.hasAttributes()

//如果不是普通元素,不是内置自定义元素

if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) { //如果options['components'] [tag](内部会对tag做名称转换)存在

if (resolveAsset (options,'components', tag)) { return { id: tag }

} else {

// getisBinding获取el元素上is绑定的组件名称

var is= hasAttrs && getisBinding(el, options) if (is) {

return is

} else if (process.env.NODE_ENV !=='production') { var expectedTag =

op巨ons._componentNameMap && options._componentNameMap[tag] if (expectedTag) {

warn(

『Unknown custom element: <'+tag+'> -'+ 'did you mean<'+ expec七edTag +'>?'+ 'HTML j

is case-insensi巨ve, remember to use kebab-case in templates.'

} else if (isUnknownElement (el, tag)) { warn(

'Unknown custom element:<'+tag+'> - did you'+

'register the component correctly? For recursive components,'+

第19章源码篇一util 359

'make sure to provide the "name" option.'

} else if (hasAttrs) {

I I getisBinding获取el元素上is绑定的组件名称 return getisBinding(el, options)

19.5 options

顾名思义,本节介绍参数相关操作,如图19-7所示。

图19- 7 options

1. mergeOptions

此方法的核心是strats对象,因此我们先来看一下strats对象里面有什么,如图19-8所示。

attached

detached

befo,eComp!e

compiled

belmeDestory

octi,ote

destroyed

图19-8 strats

360 Vue.js权威指南

接下来我们看看方法都是怎么实现的。 (l) data(见图19-9)

图19-9 data

(2) el(见图19-10)

图19-10 el

第19章源码篇一—util 361

(3)钩子函数(见图19-11)

开始 N

retum m cv

图19-11 钩子函数 (4) props & methods & computed(见图19-12)

var rel = Object.create(null) extend{ret, parentVal)

exte芯(ret, chilcNal)

图19-12 prop

362 Vue.js权威指南

(5) watch & events(见图19-13)

rent)) {

图19-13 watch

看完上面的starts对象,我们再看源代码会更清晰一些。

0 parent {Object} 0 child {Object} 0 vm {Vue}

<'－－源码目录：src/u巨1/components.js 325行－－> func巨on mergeOptions (parent, child, vm) (

guardComponents(child)//确保child.components有正确的数据格式 guardProps(child)//确保child.props被规范化为基千对象的格式

if (process. env. NODE_ ENV ! =='production') {

if (child.propsData && !vm) {

warn ('props Data can only be used as an instantiation op巨on.')

第19章源码篇－-util 363

var op巨ons = {} var key

//递归

if (child.extends) {

parent= typeof child.extends==='function'

? mergeOptions(parent, child.extends.options, vm} : mergeOptions(parent, child.extends, vm)

}

//递归

if (child.mixins) {

for (var i = 0, l = child.mixins.length; i < l; i++) { parent= mergeOptions(parent, child.mixins[i], vm)

for (key].n parent) { rnergeField(key)

for (key in child) {

if (! has Own (paren七,key)) { rnergeField(key)

function mergeField (key) (

var strat = strats [key] I I defaultStrat

options[key] = strat(parent[key], child[key], vm, key)

return options

2. resolveAsset

如果options[type][id](内部会对tag做名称转换)存在,则返回;否则返回false。

<'－－源码目录：src/util/components.js 372行－－>

function resolveAsset (options, type, id, warnMissing) { if (typeof id ! =='string') {

return

var assets= options[type] var camelizedid

364 Vue.js权威指南

var res = assets [ id] I I II camelCase ID

assets [camelizedid = camelize (id)] 11 II Pascal Case ID

assets [ camelizedid. char At (0). toUpperCase () + camelizedid. slice (1) ] 辽(process. env. NODE_ ENV 1 =='production'&& warnMissing && 1 res) ( warn (

'Failed to resolve'十七ype.slice(O, -1) +':'+ id, options

return res

19.6 debug

warn 使用console.error输出警告信息。

<'-－源码目录：src/util/warn.js 7行－－> le七warn

let formatComponentName

if (process.env.NODE_ENV !;;'production') {

const hasConsole; typeof console I;;'undefined' warn; (msg, vm) ;> {

if (hasConsole && ('config.silent)) {

console. error ('[Vue warn] :'+ msg + (vm ? formatComponentNarne (vm) :''))

forma七ComponentName = vm => {

var name= vm._isVue? vm.$op巨ens.name : vm.name return name

?'(found in component: <'+ hyphenate(name) +'>)'

第20章

源码篇——深入晌应式原理

Vue.js最显著的功能就是响应式系统,它是一个典型的MVVM框架,模型(Model)只是 普通的JavaScript对象,修改它则视图(View)会自动更新。这种设计让状态管理变得非常简 单而直观,不过理解它的原理也很重要,可以避免一些常见问题。下面让我们深挖Vue.js响应 式系统的细节,来看一看Vue.js是如何把模型和视图建立起关联关系的。

20.1 如伺追踪变化

我们先来看一个简单的例子。代码示例如下：

<div id="rnain">

<hl>count: {{巨mes}}</hl> </div>

<script src="vue.js"></script> <script>

var vm = new Vue({ el:'

#main',

data: function () { return {

times: 1

};

},

created: function () { var me= this;

setinterval (function () { me.times++;

}, 1000);

366 Vue.js权威指南

)) ; </script>

运行后,我们可以从页面中看到,count后面的times每隔ls递增1,视图一直在更新。在 代码中仅仅是通过setlnterval方法每隔ls来修改vm.times的值,并没有任何DOM操作。那么 Vue.js是如何实现这个过程的呢？我们可以通过一张图来看一下,如图20-1所示。

．．一

addDep

depend

update

-········· ｀．

图20-1 模型和视图关联关系图

图中的模型(Model)就是data方法返回的{times: 1},视图(View)是最终在浏览器中显 示的DOM。模型通过Observer、Dep、Watcher、Directive等一系列对象的关联,最终和视图建 立起关系。归纳起来,Vue.js在这里主要做了三件事：

0通过Observer对data做监听,并且提供了订阅某个数据项变化的能力。

0把template编译成一段document fragment,然后解析其中的Directive,得到每一个 Directive所依赖的数据项和update方法。

0通过Watcher把上述两部分结合起来,即把Directive中的数据依赖通过Watcher订阅在 对应数据的Observer的Dep上。当数据变化时,就会触发Observer的Dep上的notify 方法通知对应的Watcher的update,进而触发Directive的update方法来更新DOM视图, 最后达到模型和视图关联起来。

接下来我们就结合Vue.js的源码来详细介绍这三个过程。

第20章 源码篇——深入响应式原理 367

20.1.1 Observer

首先来看一下Vue.js是如何给data对象添加Observer的。我们知道,Vue实例创建的过程 会有一个生命周期,其中有一个过程就是调用vm._initData方法处理data选项。＿initData方法 的源码定义如下：

< !" －－源码目录：src/instance/internal/sta七e.js--> Vue. prototype._ ini tData = function () {

var dataFn = this.$options.data

var data= this._data = dataFn? dataFn() : {) if (!isPlainObject(data)) {

data = {)

process.env.NODE_ENV !=='production'&& warn( 'data functions should return an object.', this

var props= this._props

// proxy data on ins七ance

var keys= Objec七．keys(data) var i, key

i = keys.length

while (i一一) {

key = keys [i]

// there are two scenarios where we can proxy a data key:

II l. it's not already defined as a prop

II 2. it's provided via a instantiation option AND there are no II template prop present

if (1 props I I ! has Own (props, key)) { this._proxy(key)

} else if (process.env.NODE_ENV 1=='production') {

warn (

'Data field"'+key+'" is already defined'+

'as a prop. To provide default value for a prop, use the "default"'+ 'prop option; if you want to pass prop values to an instantiation'+ 'call, use the "propsData" option.',

this

368 Vue.js权威指南

II observe data observe(data, this)

在—initData中我们要特别注意卫roxy方法,它的功能就是遍历data的key,把data上的属 性代理到vm实例上。卫roxy方法的源码定义如下：

<'-－源码目录：src/instance/internal/state.js--> Vue.prototype._proxy = func巨on (key) {

辽(1 isReserved (key)) {

// need to store ref to self here

// because these getter/setters might II be called by child scopes via

II prototype inheritance.

var self= this Object.defineProperty(self, key, {

configurable:七rue, enumerable: true,

get: function proxyGet仁er () { return self._data[key]

},

set: function proxySet七er (val) { self._data[key] = val

))

_proxy方法主要通过Object.defineProperty的getter和setter方法实现了代理。在前面的例 子中,我们调用vm.times就相当千访问了vm.—data.times。

在＿initData方法的最后,我们调用了observe(data, this)方法来对data做监听。observe方法 的源码定义如下：

< !" －－源码目录：src/observer/index.js--> export func巨on observe (value, vm) {

if (!value 11七ypeof value !=='object') { return

var ob

第20章源码篇一深入响应式原理 369

辽(

hasOwn(value,'ob') &&

value. ob instanceof Observer

) {

ob= value. ob

} else if ( shouldConvert &&

(isArray (value) I I isPlainObject (value)) && Object.isExtensible(value) &&

!value. isVue

) {

ob= new.Observer(value)

if (ob && vm) ( ob.addVm(vm)

return ob

observe方法首先判断value是否已经添加了—ob＿属性,它是一个Observer对象的实例。

如果是就直接用,否则在value满足一些条件(数组或对象、可扩展、非vue组件等)的清况下 创建一个Observer对象。接下来我们看一下Observer这个类,它的源码定义如下：

< !" －－源码目录：src/observer/index.js--> export function Observer (value) { this.value= value

this. dep = new Dep ()

def (value,'ob', this) 辽伈sArray (value)) {

var augment= hasProto ? protoAugment

: copyAugment

augment(value, arrayMethods, arrayKeys) this.observeArray(value)

} else {

this.walk(value)

Observer类的构造函数主要做了这么几件事：首先创建了一个Dep对象实例(关千Dep对 象我们稍后作介绍);然后把自身this添加到value的—ob＿属性上;最后对value的类型进行

370 Vue.js权威指南

判断,如果是数组则观察数组,否则观察单个元素。其实observeArray方法就是对数组进行遍 历,递归调用observe方法,最终都会调用walk方法观察单个元素。接下来我们看一下walk 方法,它的源码定义如下：

<!" －－源码目录：src/observer/index.js--> Observer.prototype. walk = function (obj) { va：：keys= Objec七．keys (obj I

for (var i = 0, 1 = keys.length; i < l; i++) { this.convert(keys[i], obj[keys[i]])

walk方法是对obj的key进行遍历,依次调用convert方法,对obj的每一个属性进行转换, 让它们拥有getter、setter方法。只有当obj是一个对象时,这个方法才能被调用。接下来我们 看一下convert方法,它的源码定义如下：

<'－－源码目录：src/observer/index.js-->

Observer. prototype. convert = function (key, val) { defineReactive(this.value, key, val)

convert方法很简单,它调用了defineReactive方法。这里this.value就是要观察的data对象, key是data对象的某个属性,val则是这个属性的值。defineReactive的功能是把要观察的data 对象的每个属性都赋予getter和setter方法。这样一旦属性被访问或者更新,我们就可以追踪到 这些变化。接下来我们看一下defineReactive方法,它的源码定义如下：

< !" －－源码目录：src/observer红ndex. j s-->

export function defineReactive (obj, key, val) { var dep = new Dep ()

var property= Object.getOwnPropertyDescriptor(obj, key) if (property && property. configurable === false) {

return

// cater for pre-defined getter/setters var getter= property && property.get var setter= property && property.set var childOb = observe(val) Object.defineProperty(obj, key, {

enumerable: true, configurable: true,

get: function reactiveGetter () {

第20章源码篇一深入响应式原理 371

var value = getter ? getter. call (obj) : val if (Dep.target) {

dep. depend ()

if (childOb) {

childOb.dep.depend()

if (isArray(value)) (

for (var e, i = 0, l = value.length; i < l; i++) ( e = value[i]

e & & e. ob & & e. ob. dep. depend ()

return value },

set: function reacti veSetter (newVal) {

var value= getter? getter.call(obj) : val 辽(newVal === value) {

re七urn

if (setter) { setter.call(obj, newVal) } else {

val= newVal

childOb = observe(newVal) dep. notify()

))

defineReactive方法最核心的部分就是通过调用Object.defineProperty给data的每个属性添 加getter和setter方法。当data的某个属性被访问时,则会调用getter方法,判断当Dep.target 不为空时调用dep.depend和childObj.dep.depend方法做依赖收集。如果访问的属性是一个数组, 则会遍历这个数组收集数组元素的依赖。当改变data的属性时,则会调用setter方法,这时调 用dep.notify方法进行通知。这里我们提到了dep,它是Dep对象的实例。接下来我们看一下 Dep这个类,它的源码定义如下：

<!" －－源码目录：src/observer/dep.js--> export default function Dep () {

372 Vue.js权威指南

this.id= uid++ this.subs= []

// the current target watcher being evaluated.

// this is globally unique because there could be only one // watcher being evalua七ed at any time.

Dep.target = null

Dep类是一个简单的观察者模式的实现。它的构造函数非常简单,初始化了id和subs。其 中subs用来存储所有订阅它的Watcher, Watcher的实现稍后我们会介绍。Dep.target表示当前 正在计算的Watcher,它是全局唯一的,因为在同一时间只能有一个Watcher被计算。

前面提到了在getter和setter方法调用时会分别调用dep.depend方法和dep.notify方法,接 下来依次介绍这两个方法。depend方法的源码定义如下：

< !" －－源码目录：src/observer/dep.js--> Dep.prototype.depend = function () { Dep.target.addDep(this)

depend方法很简单,它通过Dep. target. addDep(this)方法把当前Dep的实例添加到当前正在 计算的Watcher的依赖中。接下来我们看一下notify方法,它的源码定义如下：

< !" －－源码目录：src/observer/dep.js-->

Dep.proto七ype. notify = function () {

// stablize the subscriber list first var subs= toArray(this.subs)

for (var i = 0, 1 = subs. length; i < l; i++) { subs[i].update()

notify方法也很简单,它遍历了所有的订阅Watcher,调用它们的update方法。

至此,vm实例中给data对象添加Observer的过程就结束了。接下来我们看一下Vue.js是 如何进行指令解析的。

20.1.2 Directive

Vue指令类型很多,限千篇幅,我们不会把所有指令的解析过程都介绍一遍,这里结合前 面的例子只介绍v-text指令的解析过程,其他指令的解析过程也大同小异。

第20章源码篇一深入响应式原理 373

前面我们提到了Vue实例创建的生命周期,在给data添加Observer之后,有一个过程是调 用vm._ compile方法对模板进行编译。＿compile方法的源码定义如下：

< !" －－源码目录：src/].nstance/].nternal/1].fecycle.js--> Vue.prototype._comp].le = function (el) {

var options= this.$opt].ons

// transclude and].nit element

// transclude can potentially replace original

// so we need to keep reference; this step also].njects // the template and caches the or].g].nal attributes

// on the container node and replacer node.

var original= el

el=七ransclude(el, op巨ons) this._].nitElement(el)

// handle v-pre on root node (#2026)

辽(el.nodeType === 1 && getAttr(el,'v-pre') !== null) { return

// root is always compiled per飞nstance, because

// container attrs and props can be different every time.

var contextOptions =七his._context && this._context.$options var rootLinker = compileRoot(el, options, contextOptions)

// resolve slot distribution

resolveSlots(this, options._content)

// compile and巨nk the rest

var contentLinkFn

var ctor = this.constructor

// component compilation can be cached

// as long as江'snot using inline-template if (options._linkerCachable) {

con七entLinkFn = ctor.linker if (! contentLinkFn) {

contentLinkFn = c七or.linker= compile(el, options)

// link phase

II make sure to link root with prop scope'

var rootUn让nkFn = rootLinker(this, el, this._scope) var contentUnlinkFn = contentLinkFn

374 Vue.js权威指南

? contentLinkFn(this, el)

: comp乓e(el, op巨ons) (this, el)

// regis七er composite unlink function

// to be called during instance destruction this._ unlinkFn = function () (

rootUnlinkFn ()

// passing destroying: true to avoid searching and // splicing七he directives

contentUnlinkFn(true)

// finally replace original 辽(options.replace) { replace(original, el)

this._isCompiled = true this._callHook ('compiled')

我们可以通过图20-2来看一下这个方法编译的主要流程。

图20-2 vm._compile编译主要流程图

这个过程通过el= transclude(el, option)方法把template编译成一段document fragment,拿到 el对象。而指令解析部分就是通过compile(el, options)方法实现的。接下来我们看一下compile 方法的实现,它的源码定义如下：

<'－－源码目录：src/comp过er/compile.js-->

export function compile (el, op巨ons, partial) { // link function for the node i七self.

var nodeLinkFn = partial I I I options. _asComponent

第20章 源码篇一一深入响应式原理 375

? compileNode(el, options) : null

// link function for the childNodes var childLinkFn =

! (nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) &&

el.hasChildNodes()

? compileNodeList(el.childNodes, options) : null

/**

A composite linker function亡o be called on a already
compiled piece of DOM, which instantiates all directive
＊

instances.

@pararn {Vue} vrn
@pararn {ElernentlDocurnentFragrnent} el
@pa ram {Vue} [host] - host vm of七ranscluded content
@pararn {Object} [scope] - v-for scope
@param {Fragment) [ frag] - link context fragment
@return {Func巨onlunde丘ned) */
return func巨on compositeLinkFn (vm, el, host, scope, frag) {

II cache childNodes before linking parent, fix #657

var childNodes = toArray(el.childNodes)

//让nk

var dirs = linkAndCapture(func巨on composi teLinkCapturer () { if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag)

if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag) ), vm)

re七urn makeUnlinkFn(vm, dirs)

compile方法主要通过compileNode(el, options)方法完成节点的解析,如果节点拥有子节点, 则调用compileNodeList(el.childNodes, options)方法完成子节点的解析。compileNodeList方法其 实就是遍历子节点,递归调用compileNode方法。因为DOM元素本身就是树结构,这种递归 方法也就是常见的树的深度遍历方法,这样就可以完成整个DOM树节点的解析。接下来我们 看一下compileNode方法的实现,它的源码定义如下：

< !" －－源码目录：src/cornpiler/cornpile.js--> function comp辽eNode (node, options) {

376 Vue.js权威指南

var type= node.nodeType

if (type=== 1 && !isScript(node)) { return compileElement(node, options)

} else if (type=== 3 && node.data.trim()) { return compileTextNode(node, options)

} else {

return null

compileNode方法对节点的nodeType做判断,如果是一个非script普通的元素(div、p等); 则调用compileElement(node, options)方法解析;如果是一个非空的文本节点,则调用 compileTextNode(node, options)方法解析。我们在前面的例子中解析的是非空文本节点count {{times}},这实际上是v-text指令,它的解析是通过compileTextNode方法实现的。接下来我们 看一下compileTextNode方法,它的源码定义如下：

<'－－源码目录：src/compiler/compile.js--> function compileTextNode (node, options) { // skip marked text nodes

辽(node._skip) {

return removeText

var tokens= parseText(node.wholeText) if (!tokens) (

return null

II mark adjacent text nodes as skipped,

II because we are using node.wholeText to compile II all adjacent text nodes together. This丘xes

II issues in IE where some已mes it splits up a single II text node into multiple ones.

var next= node.nextSibling

while (nex七＆＆next. node Type === 3) { next._skip = true

next= next.nextSibling

var frag = document.createDocumentFragment() var el, token

for (var i = 0, l =七okens. length; i < l; i ++) {

第20章 源码篇－~深入响应式原理 377

token= tokens[i] el= token.tag

? processTextToken(七oken, options)

: document.createTextNode(token.value) frag.appendChild(el)

return makeTextNodeLinkFn(tokens, frag, op巨ons)

compileTextNode方法首先调用了parse Text方法对node. whole Text做解析。主要通过正则 表达式解析count: { {times}}部分,我们看一下解析结果,如图20-3所示。

Line 7124, Column 5

) ： I,,tokens: Array (21

,. 0: Object value:

_proto_:
Y l: Object html: false oneTime: tag: true value:

图20-3 parseText解析文本节点结果

解析后的tokens是一个数组,数组的每个元素则是一个Object。如果是count这样的普通 文本,则返回的对象只有value字段;如果是{ {times}}这样的插值,则返回的对象包含html、 onTime、tag、value等字段。

接下来创建document fragment,遍历tokens创建DOM节点插入到这个fragment中。在遍 历过程中,如果token无tag字段,则调用document.createTextNode(token. value)方法创建DOM 节点;否则调用processTextToken(token, options)方法创建DOM节点和扩展token对象。我们看 一下调用后的结果,如图20-4所示。

e n L

．

1a} 777777A{

图20-4 processTextToken解析文本节点结果

可以看到,token字段多了一个descriptor属性。这个属性包含了几个字段,其中def表示 指令相关操作的对象,expression为解析后的表达式,filters为过滤器,name为指令的名称。

378 Vue.js权威指南

在compileTextN ode方法的最后,调用makeTextNodeLinkFn(tokens, frag, options)并返回该 方法执行的结果。接下来我们看一下makeTextNodeLinkFn方法,它的源码定义如下：

<'－－源码目录：src/compiler/compile.js-->

func七ion makeTextNodeLinkFn (tokens, frag) {

return function textNodeLinkFn (vm, el, host, scope) { var fragClone = frag.cloneNode(true)

var childNodes = toArray(fragClone.childNodes) var token, value, node

for (var i = 0, l =七okens.length; i < l; i++) { token= tokens[i)

value= token.value

if (token.tag) {

node= childNodes［习 if (token.oneTime) {

value = (scope 11 vm).$eval (value) 辽(token.html) {

replace(node, parseTemplate(value, true)) } else {

node.data= _toString(value)

) else {

vm._bindDir(token.descriptor, node, host, scope)

replace(el, fragClone)

makeTextNodeLinkFn这个方法什么也没做,它仅仅是返回了一个新的方法textNodeLinkFn。

往前回溯,这个方法最终作为compileNode的返回值,被添加到compile方法生成的childLinkFn 中。

我们回到compile方法,在compile方法的最后有这样一段代码：

<'－－源码目录：src/compiler/compile.js-->

return function compositeLinkFn (vm, el, host, scope, frag) { II cache childNodes before linking parent, fix #657

var childNodes = toArray(el.childNodes)

第20章源码篇一深入响应式原理 379

// link

var dirs = linkAndCapture (function composi teLinkCapturer () { if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag)

if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag) }, vm)

return makeUnlinkFn(vm, dirs)

compile方法返回了compositeLinkFn,它在Vue. prototype—compile方法执行时,是通过 compile(el, options)(this, el)调用的。compositeLinkFn方法执行了I ink.And Capture方法,它的功 能是通过调用compile过程中生成的link方法创建指令对象,再对指令对象做一些绑定操作。

linkAndCapture方法的源码定义如下：

< !" －－源码目录：src/compiler/compile.js--> function linkAndCapture (linker, vm) { /* istanbul ignore if*/

辽(process. env. NODE _ENV ==='production') {

// reset directives before every capture in production II mode, so that when unlinking we don't need to splice II them out (which turns out to be a perf hit).

II they are kept in development mode because they are II useful for Vue's own tests.

vm. directives=

［ ］

var originalDirCount = vrn._directives.length linker ()

var d].rs= vrn._d].rect].ves.sl].ce(orig].nalD].rCount) d].rs.sort(d].rect].veCornparator)

for (var]. =0, l = d].rs.length; i < l;].++) { d].rs[].)._b].nd ()

return dirs

linkAndCapture方法首先调用了linker方法,它会遍历compile过程中生成的所有linkFn并 调用,本例中会调用到之前定义的textN odeLinkFn。这个方法会遍历tokens,判断如果token的

tag属性值为true且oneTime属性值为false,则调用vm._bindDir(token.descriptor, node, host, scope) 方法创建指令对象。vm._bindDir方法的源码定义如下：

<'－－源码目录：src/instance/internal/lifecycle.js-->

380 Vue.js权威指南

Vue.prototype._bindD立＝func豆on (descriptor, node, host, scope, frag) ( this._direc巨ves.push(

new Directive(descriptor, this, node, hos七,scope, frag)

Vue.prototype.—bindDir方法就是根据descriptor实例化不同的Directive对象,并添加到vm 实例的directives数组中的。到这一步,Vue.js从解析模板到生成Directive对象的步骤就完成了。 接下来回到linkAndCapture方法,它对创建好的directives进行排序,然后遍历directives调用 dirs[i]—bind方法对单个小rective做一些绑定操作。dirs[i]—bind方法的源码定义如下：

<'-－源码目录：src/directive.js-->

Di rec ti ve. prototype. bind = function () { var name=七his.name

var descriptor= this.descriptor II remove attribute

if (

(name 1=='cloak'11 this.vm._isCompiled) && this.el && this.el.removeAttribute

) {

var attr = descriptor.attr 11 ('v-'+ name)

this.el.removeAttribute(a七tr)

II copy def properties var def= descriptor.def

辽(typeof def==='func巨on') { 七his.update= def

} else (

extend(this, def)

// setup directive pararns this._setupPararns()

// initial bind

江(七his.bind) {

this.bind()

this._bound = true if (this.literal) {

this.update && this.update(descriptor.raw) } else if (

第20章源码篇一深入晌应式原理 381

(this.expression 11 this.modi丘ers) & & (this.update 11 this.twoWay) && !this._checkStatement()

) {

// wrapped updater for context var dir = this

if (this.update) (

this._ update = function (val, oldVal) ( 辽('中r._locked) (

dir.update(val, oldVal)

} else {

this._update = noop

var preProcess = this._preProcess ? bind(this._preProcess, this)

: null

var postProcess = this._postProcess ? bind(this._postProcess, this)

: null

var.watcher= this._watcher = new Watcher( this.vrn,

this.expression,

this._update, II callback

filters:七his.filters, twoWay: this.twoWay,

deep: this.deep, preProcess: preProcess, postProcess: postProcess, scope: this._scope

// v-model with inital inline value need to sync back to // model instead of upda七e to DOM on init. They would

II set the afterBind hook to indicate that.

if (this.afterBind) {

this. afterBind ()

} else if (this.update) {

382 Vue.js权威指南

this.update(watcher.value)

Directive.prototype—bind方法的主要功能就是做一些指令的初始化操作,如混合def属性。

def是通过this.descriptor.def获得的,this.descriptor是对指令进行相关描述的对象,而 this.descriptor.def则是包含指令相关操作的对象。比如对千v-text指令,我们可以看一下它的相 关操作,源码定义如下：

<'－－源码目录：src/directives/public/text.js--> export default (

bind () (

this.attr = this.el.nodeType === 3 ?'data'

:'textContent'

},

update (value) (

this.el[this.attr] = _toS七ring(value)

v-text的def包含了bind和update方法,Directive在初始化时通过extend(this, def)方法可以 对实例扩展这两个方法。Directive在初始化时还定义了this._ update方法,并创建了Watcher, 把this._ update方法作为Watcher的回调函数。这里把Directive和Watcher做了关联,当Watcher 观察到指令表达式值变化时,会调用Directive实例的＿update方法,最终调用v-text的update 方法更新DOM节点。

至此,vm实例中编译模板、解析指令、绑定Watcher的过程就结束了。接下来我们看一下 Watcher的实现,了解Directive和Observer之间是如何通过Watcher关联的。

20.1.3 Watcher

我们先来看一下Watcher类的实现,它的源码定义如下：

< !" －－源码目录：src/watcher.js-->

export defaul七function Wa七cher (vm, expOrFn, cb, op巨ons) { // mix in options

if (options) (

extend(this, options)

第20章源码篇一深入响应式原理 383

var isFn = typeof expOrFn ==='function' this.vm = vm

vm._watchers.push(this)

七his.expression= expOrFn 七his.cb = cb

this.id= ++uid II uid for batching this.active= true

this.dirty= this.lazy II for lazy watchers this.deps = []

this.newDeps = []

七his.depids = new Set() this.newDepids = new Set()

this.prevError = null II for async error stacks II parse expression for getterlsetter

江(isFn) (

this.getter= expOrFn this.setter= undefined

} else (

var res= parseExpression(expOrFn,七his.twoWay) this.getter= res.ge七

this.setter= res.set

this.value=七his.lazy ? undefined

：七his.get()

II state for avoiding false triggers for deep and Array I I watchers during vrn._digest ()

this.queued= this.shallow= false

Directive实例在初始化Watcher时,会传入指令的expression。Watcher构造函数会通过 parseExpression(expOrFn, this.two Way)方法对expression做进一步的解析。在前面的例子中,

expression是times, passExpression方法的功能是把expression转换成一个对象,如图20-5所示。

this. getter = ex~O~Fn;. expOrFn = "time1,. Watch

- "nno千inon•

exp: "times"

►get: function anonymous (scope ►_proto_: Object

图20-5 passExpression执行结果

384 Vue.js权威指南

可以看到res有两个属性,其中exp为表达式字符串;get是通过new Function生成的匿名 方法,可以把它打印出来,如图20-6所示。

> res. get. to St ring ()

< "function anonymous (scope f**f) {

return scope.times;

图20-6 res.get方法打印结果

可以看到res.get方法很简单,它接受传入一个scope变量,返回scope.times。对千传入的 scope值,稍后我们会进行介绍。在Watcher构造函数的最后调用了this.get方法,它的源码定 义如下：

< I -－源码目录：src/watcher.js-->

Watcher.prototype.get= func巨on () { this.beforeGet()

var scope = this. scope I I this. vm var value

try {

value= this.getter.call(scope, scope) } catch (e) {

if (

process.env.NODE_ENV !=='production'&& con丘g.warnExpressionErrors

) {

warn(

'Error when evaluating expression'+ '"'+this.expression+'":'+ e.toString(), this.vm

II "touch" every property so they are all七racked as II dependencies for deep watching

if (this.deep) {

traverse(value)

辽(this. preProcess) {

value= this.preProcess(value)

第20章源码篇一深入响应式原理 385

if (this.filters) (

value= scope._applyFilters(value, null, this.filters, false)

if (this.postProcess) {

value= this.postProcess(value)

this. afterGet () return value

Watcher.prototype.get方法的功能就是对当前Watcher进行求值,收集依赖关系。它首先执 行this.beforeGet方法,源码定义如下：

<!" －－源码目录：src/watcher.js-->

Wa七cher. prototype. beforeGet = function () { Dep.target = this

Watcher. prototype. beforeGet很简单,设置Dep.target为当前Watcher实例,为接下来的依赖 收集做准备。我们回到get方法,接下来执行this.getter.call(scope, scope)方法,这里的scope是 this.vm,也就是当前Vue实例。这个方法实际上相当千获取vm.times,这样就触发了对象的getter。 在20.1.1节我们给data添加Observer时,通过Object.defineProperty给data对象的每一个属性 添加getter和setter。回顾一下代码：

<!" －－源码目录：src/observer/index.js--> Object.defineProperty(obj, key, { enumerable: true,

configurable: true,

get: function reactiveGe七七er () {

var value = getter ? getter. call (obj) : val if (Dep.target) {

dep. depend ()

if (childOb) {

childOb.dep.depend()

if (isArray(value)) {

for (var e, i = 0, 1 = value.length; i < l; i++) { e = value[i]

e && e. ob && e. ob.dep.depend()

386 Vue.js权威指南

return value

},

当获取vm.times时,会执行到get方法体内。由千我们在之前已经设置了Dep.target为当前 Watcher实例,所以接下来就调用dep.depend()方法完成依赖收集。它实际上是执行了 Dep. target. addDep(this),相当千执行了Watcher实例的addDep方法,把Dep实例添加到Watcher 实例的依赖中。addDep方法的源码定义如下：

<'－－源码目录：src/watcher.js--> Watcher.prototype.addDep = function (dep) { var id= dep.id

if (!this. newDepids. has (id)) { this.newDepids.add(id) this.newDeps.push(dep)

if (!this.depids.has(id)) { dep.addSub(this)

Watcher.prototype.addDep方法就是把dep添加到Watcher实例的依赖中,同时又通过 dep.addSub(this)把Watcher实例添加到dep的订阅者中。addSub方法的源码定义如下：

<'－－源码目录：src/observer/dep.js-->

Dep. prototype. addSub = function (sub) { this.subs.push(sub)

至此,指令完成了依赖收集,并且通过Watcher完成了对数据变化的订阅。

接下来我们看一下,当data发生变化时,视图是如何自动更新的。在前面的例子中,我们 通过setlnterval每隔ls执行一次vm.times++,数据改变会触发对象的setter,执行set方法体的 代码。回顾一下代码：

<'-－源码目录：src/observer/index.js--> Object.defineProperty(obj, key, {

set: function reacti veSetter (newVal) {

var value= getter? getter.call(obj) : val

第20章 源码篇一一深入响应式原理 387

if (newVal === value) { return

].f (setter) { setter.call(obj, newVal) } else {

val= newVal

childOb = observe(newVal) dep.notify()

))

这里会调用dep.notify()方法,它会遍历所有的订阅者,也就是Watcher实例。然后调用 Watcher实例的update方法,源码定义如下：

<'－－源码目录：src/watcher.js-->

Watcher. prototype. update ; function (shallow) { if (this. lazy) {

this.dirty; true

} else if (this. sync I I ! con fig. async) { this.run()

} else {

// if queued, only overwrite shallow with non-shallow, // but not the other way around.

this.shallow; this.queued

? shallow

? this.shallow : false

: ! !shallow this.queued; true

// record before-push error stack in debug mode /* istanbul ignore if*/

辽(process. env. NODE _ENV ! ;;'production'& & con fig. debug) { this.prevError; new Error('[vue] async stack trace')

pushWatcher (this)

Watcher. prototype. update方法在满足某些条件下会直接调用this.run方法。在多数情况下会

388 Vue.js权威指南

调用push Watcher(this)方法把Watcher实例推入队列中,延迟this.run调用的时机。push Watcher 方法的源码定义如下：

<'－－源码目录：src/batcher.js-->

export function pushWatcher (watcher) { const id= watcher.id

江(has [id] == null) {

II push watcher into appropriate queue const q = watcher.user

? userQueue

: queue

has[id] = q.length q.push(watcher)

I I queue the flush 辽(1wai巨ng) {

waiting= true nextTick(flushBatcherQueue)

push Watcher方法把Watcher推入队列中,通过nextTick方法在下一个事件循环周期处理 Watcher队列,这是Vue.js的一种性能优化手段。因为如果同时观察的数据多次变化,比如同步 执行3次vm.time＋＋,同步调用watcher.run就会触发3次DOM操作。而推入队列中等待下一 个事件循环周期再操作队列里的Watcher,因为是同一个Watcher,它只会调用一次watcher.run, 从而只触发一次DOM操作。接下来我们看一下flushBatcherQueue方法,它的源码定义如下：

< !" －－源码目录：src/batcher.js--> function flushBatcherQueue () ( runBatcherQueue(queue) runBatcherQueue(userQueue)

II user watchers triggered more watchers, II keep flushing until it depletes

辽(queue. length) {

return flushBa七cherQueue ()

II dev tool hook

I* istanbul ignore辽＊／

if (devtools && config.devtools) ( devtools. emit ('flush')

第20章 源码篇一一深入响应式原理 389

rese七BatcherState ()

fl ushBatcherQueue方法通过调用runBatcherQueue来run Watcher。这里我们看到Watcher 队列分为内部queue和userQueue,其中userQueue是通过$watch()方法注册的Watcher。我们优 先run内部queue来保证指令和DOM节点优先更新,这样当用户自定义的Watcher的回调函数 触发时DOM己更新完毕。接下来我们看一下runBatcherQueue方法,它的源码定义如下：

<'－－源码目录：src/ba七cher. j s--> function runBatcherQueue (queue) {

// do not_ cache length because more watchers might be pushed II as we run existing watchers

for (let i = 0; i < queue.length; i++) ( var watcher= queue[i]

var id= watcher.id

has [ id] = null

watcher. run ()

II in dev build, check and stop circular updates.

if (process.env.NODE_ENV 1=='production'&& has[id] != null) ( circular [ id] = (circular [ id] I I O) + 1

if (circular[id] > config._maxUpdateCount) {

warn (

'You may have an infinite update loop for watcher'+ 'with expression"'+watcher.expression+

watcher.vm

break

queue.length= 0

runBatcherQueued的功能就是遍历queue中Watcher的run方法。接下来我们看一下Watcher 的run方法,它的源码定义如下：

< !" －－源码目录：src/watcher.js-->

Watcher.prototype.run= func巨on () { 辽(this.active) {

var value= this.get()

390 Vue.js权威指南

辽(

value!== this.value II

II Deep watchers and wa七chers on Object/Arrays should fire even // when the value is the same, because the value may

// have muta七ed; but only do so if this is a

// non-shallow update (caused by a vm digest).

((isObject(value) II this.deep) && !this.shallow)

) {

// set new value

var oldValue = this.value this.value= value

// in debug+ async mode, when a watcher callbacks // throws, we also throw the saved before-push error // so the full cross-tick stack trace is available.

var prevError =七his.prevError

/* istanbul ignore if*/

迂(process.env.NODE_ENV !=='production'&& config.debug && prevError) { this.prevError = null

try {

this.cb.call(this.vm, value, oldValue) ) catch (e) {

nextTick(function () {

throw prevError

}'0)

throw e

) else {

this.cb.call(this.vm, value, oldValue)

this.queued= this.shallow= false

Watcher.prototype.run方法再次对Watcher求值,重新收集依赖。接下来判断求值结果和之 助value的关系。如果不变则什么也不做,如果变了则调用this.cb.call(this.vm, value, oldValue) 方法。这个方法是Directive实例创建Watcher时传入的,它对应相关指令的update方法来真实 更新DOM。这样就完成了数据更新到对应视图的变化过程。

第20章 源码篇一—深入响应式原理 391

Watcher巧妙地把Observer和Directive关联起来,实现了数据一旦更新,视图就会自动变 化的效果。尽管Vue.js利用Object.defineProperty这个核心技术实现了数据和视图的绑定,但仍 然会存在一些数据变化检测不到的问题,接下来我们看一下这部分内容。

20.2 变化检测问题

受ES 5的限制,Vue.js不能检测到对象属性的添加和删除。因为Vue.js在初始化实例时将 属性转换为getter/setter,所以属性必须在data对象上已存在才能让Vue.js转换它,才能让它是 响应式的。代码示例如下：

<div id="main">

<hl>{ {a}} { {b} }</hl> </div>

<script src="vue.js"></script> <script>

var vm = new Vue ({ el:'#main',

da七a: {a: 1}

}) ;

II vm.a现在是响应式的

vm.b = 2;

II vm.b不是响应式的 <I script>

我们发现,通过vm.b=2给data对象添加属性并不会触发视图的变化。不过,有办法在Vue 实例创建完成之后添加属性并且让它是响应式的。对千Vue实例,可以使用$set(key, value)实例 方法。代码示例如下：

vrn.$set('b', 2); // vrn.b是响应式的

为何通过Vue实例的$set方法就能让vm.b变成响应式的？我们来一探究竞。$set方法的源 码定义如下：

< !" －－源码目录：src/instance/ap)./data.js--> Vue.prototype.$set = funct).on (exp, val) { var res= parseExpression(exp, true)

if (res && res.set) {

392 Vue.js权威指南

res.set.call(this, this, val)

Vue.prototype.$set方法首先通过parseExpression方法对exp表达式做解析,解析的结果包 含set属性。set属性是一个方法,它是通过调用compileSetter(exp)方法生成的。compileSetter 的源码定义如下：

< !" －－源码目录：src/parsers/expression.js--> function compileSetter (exp) {

var path= parsePath(exp)

if (path) {

return function (scope, val) { setPath (scope, path, val)

} else {

process.env.NODE_ENV 1=='production'&& warn( 'Invalid setter expression:'+ exp

compileSetter方法返回了一个function,前面执行res.set.call(this, this, val)就相当于执行这 里的setPath(scope, path, val)方法。其中scope为vm实例;path为exp解析后的路径数组,本例 中为['b']; val为设置的值,本例中为2。接下来我们看一下setPath方法,它的源码定义如下：

<'－－源码目录：src/parsers/path.js-->

export function setPath (obj, path, val) { var original= obj

if (typeof path ==='string') { path= parse(path)

if ('path 11 !isObject(obj)) { return false

var last, key

for (var i = 0, l = path.leng七h; i < l; i ++) { last= obj

key= path[i]

if (key.charAt(O) ==='*') {

key= parseExpression(key.slice(l)).get.call(original, original)

第20章 源码篇一一深入响应式原理 393

if (i < 1 - 1) { 0切＝obj [key]

if (! isObject (obj)) { obj= {}

江(process.env.NODE_ENV !=='produc巨on'&& last._isVue) { warnNonExistent(path, last)

set(last, key, obj)

) else {

江(isArray (obj)) { obj.$set(key, val)

} else江(key in obj) { obj [key] = val

) else {

江(process.env.NODE_ENV !=='production'&& obj._isVue} { warnNonExistent(path, obj)

set(obj, key, val)

return true

setPath方法就是遍历path上的路径,对path路径上的对象求值,并调用set(obj, key, val) 方法让obj.key也是响应式的。接下来我们看一下set方法,它的源码定义如下：

<!"－－源码目录：src/ut过／lang. j s--> export function set (obj, key, val) { 江(hasOwn (obj, key)) {

obj [key] = val

return

辽(obj._isVue) {

set(obj._da七a, key, val) return

var ob= obj. ob if (!ob) {

394 Vue.js权威指南

obj [key] = val return

ob.convert(key, val) ob. dep. notify ()

if (ob. vms) {

var i = ob.vms.length

while (i一一) {

var vm = ob.vms[i] vm._proxy(key) vm._digest()

return val

本例中,我们调用set方法传入的obj是Vue实例,key是b, val是2,因此obj._isVue为 true,调用set(obj._ data, key, val)。在Vue实例化时,我们创建了Observer实例,并通过＿ob_ 属性绑定在data上,因此可以拿到这个ob对象,并调用ob.convert(key, val)方法把key绑定在 data上,同时赋予getter/ setter方法。然后调用ob.dep.notify()通知订阅Watcher的更新,并最终 更新视图。接下来判断ob上是否有vue实例,如果有则遍历ob上的所有Vue实例,调用 vm_proxy(key)方法把key代理到vm上,在本例中就是可以通过vm.b访问到vm._data.b。最后 调用vm._digest()方法,强制vm上所有的Watcher重新计算。

经过这一系列的操作,就相当千给Vue实例的data对象新增了属性并让它也是响应式的。

但在实际运用中,我们并不总是需要通过$set方法新增属性,特别是在初始化数据时,接下来 让我们看一下这部分内容。

20.3 初始化数据

尽管Vue.js提供了API动态地添加响应属性,但还是推荐Vue实例初始化时在data对象上 声明所有的响应属性。

我们不建议这么做：

var vrn = new Vue({ template:'<div>{ {rnsg))</div>' )) ;

第20章 源码篇一一深入响应式原理 395

//然后添加'msg、

vm.$se七('msg', DDFE'');

而是建议这么做：

var vm = new Vue ({ data: {

II以一个空值声明、msg、

msg:

『'

},

template:'<div> { {msg)) </div>'

))

//然后设置'msg、

vm.msg ='DDEF1'

之所以这么建议有两个原因：

0 data对象就像组件状态的模式(schema),在它上面声明所有的属性让开发者了解组件 所期待的数据源的样子,这样的代码更易千理解。

0添加一个顶级响应属性会调用vm._digest()方法强制所有的Watcher重新计算,因为它 之前不存在,没有Watcher追踪它。这么做性能通常是司以接受的(特别是对比AngularJS

的脏检查),但是可以在初始化时避免。

20.4 异步更新队列

Vue.js默认异步更新DOM。正如我们前面介绍Watcher的实现那样,每当观察到数据变化 时,Vue就开始一个队列,将同一事件循环内所有的数据变化缓存起来。这样做的好处是,如 果一个Watcher被多次触发,不会多次更新DOM,只会推入一次到队列中,这样等到下一次事 件循环时,Vue只进行一次DOM更新,并清空队列。

内部异步队列的实现使用了nextTick方法,我们来了解一下它的实现原理。NextTick方法 的源码定义如下：

<!"－－源码目录：src/util/env.js-->

export const nextTick = (function () { var callbacks= [)

var pending= false

var timerFunc

function nextTickHandler () {

396 Vue.js权威指南

pending= false

var copies= callbacks.slice(O) callbacks = []

for (var i = 0; i < copies.length; i++) { copies[i]()

/* istanbul ignore江＊／

if (typeof Mu七ationObserver !=='undefined'&& !h

! hasMutationObserverBug) {

var counter= 1

var observer= new MutationObserver(nextTickHandler) var textNode = document.createTextNode(counter) observer.observe(textNode, {

characterData: true

))

tirnerFunc = func巨on () { counter= (counter+ 1) % 2 textNode.data = counter

) else {

II webpack attempts七o inject a shim for setirnrnedia七e

II if it is used as a global, so we have to work around that to II avoid bundling unnecessary code.

const context= inBrowser

? window

: typeof global !=='undefined'? global : {) tirnerfunc = context. set Immediate I I set Timeout

return func巨on (cb, ctx) { var func = ctx

? function () { cb. call (ctx) } : cb

callbacks. push (func)

if (pending) return

pending=七rue timerFunc(nextTickHandler, 0)

}) ()

第20章源码篇一深入响应式原理 397

nextTick方法通过立即执行的匿名函数定义,在闭包环境下定义了nextTickHandler方法, 作为最终执行回调函数的方法。nextTick方法支持传入cb和ctx两个参数,其中cb代表异步执 行的回调函数;ctx代表回调函数执行的上下文环境。函数调用时,先用callbacks保存传入的 回调函数,接着调用timeFunc异步执行nextTickHandler方法。

在这里tirneFunc是根据当前浏览器的环境定义的,如果当前浏览器的环境支持 MutationObserver,则新建一个MutationObserver实例,传入nextTickHandler的回调函数,同时 创建一个TextNode DOM对象,对它进行观察。MutationObserver是监听DOM变动的接口,当 DOM对象树发生任何变动时,MutationObserver就会得到通知。当我们观察TextNode变化时, 就会触发MutationObserver在实例化时传入的回调函数。因此,我们定义的tirnerFunc功能就是 改变这个TextNode的DOM,当timeFunc调用时就改变TextNode的值,从而触发了 nextTickHandler的调用。如果当前浏览器不支待Mutation Observer, tirnerFunc的定义就变成了 setlmrned iate或者setTimeout,通过这种方式达到异步执行nextTickHandler的目的。

在实际应用中,当我们通过数据驱动方式更新了某个DOM,又想在DOM状态更新后做一 些事情时,由于DOM异步更新的特性,不能在当前事件循环中直接操作这个DOM,但可以通 过Vue实例上的$nextTick方法来实现。代码示例如下：

Vue. component ('example', { template:'<span>{ {msg} }</span>', data: function () {

return {

msg:'DDFE'

},

methods: {

updateMessage: function () {

this.msg ='Hello DDFE' console.log(this.$el.textContent) // =>'DDFE' this. $nextTick (function () {

console.log(七his.$el.textContent) // =>'Hello DDFE' ))

))

Vue实例上的$nextTick方法实际上就是调用了我们前面定义的nextTick方法,在这个方法 的回调函数中,我们可以放心地操作更新后的DOM对象。

398 Vue.js权威指南

20.5 i;十鲜属性的奥秘

在Vue.js中,计算属性并不是简单的getter,它会持续追踪它的响应依赖。在计算一个计算 属性时,Vue.js更新它的依赖列表并缓存结果,只有当其中一个依赖发生了变化时,缓存的结 果才无效。因此,只要依赖不发生变化,访问计算属性就会直接返回缓存的结果,而不是调用

getter。

为什么要缓存？考虑这种场景：我们有一个高耗计算属性A,它要遍历一个巨型数组并做 大量的计算。然后,可能有其他的计算属性依赖A。如果没有缓存,我们将调用A的getter许 多次,超过必要的次数。

由千计算属性被缓存了,在访问它的时候getter不总是被调用。代码示例如下：

var vm = new Vue({ el:'#main',

da七a: { msg:'hello'

},

computed: {

example: function () {

return Date.now() + this.msg

},

created: function () { var me= this;

set Interval (function () { console.log(me.example); }, 1000);

)) ;

计算属性example只有一个依赖：vm.msg。Date.now()不是响应依赖,因为它和Vue的数 据观察系统无关。因此我们通过setlnterval每隔ls访问一次vm.example,得到的结果如图20-7 所示。

1466751984868hello

图20- 7 vm.example计算结果(I)

第20章源码篇-深入响应式原理 399

我们发现,每次访问vm.example的结果都不会改变,除非vm.msg改变。我们对代码稍微 做一下改动：

ere a ted: function () { var me= this;

setinterval (function () {

me.msg ='hello'+ Math.random();

console.log(me.example);

}, 1000);

我们在计时器中修改了vm.msg,这样每次访问vm.example的值都会改变,如图20-8所示。

1466754079162hello0.9337198741002137 1466754080160hello0.843598131798853 1466754081162hello0.9033000266602766 1466754082161hello0.0988812446371039 1466754083161hello0.018732661367093284

图20-8 vm.example计算结果(2)

有时候我们希望每次访问vm.example时都调用getter,且不用修改它的响应依赖,这时可 以为指定的计算属性关闭缓存。代码示例如下：

computed: { example: { cache: false,

get: function () {

return Date.now() + this.msg

},

ere a ted: function () ( var me= this;

set Interval (function () ( console.log(me.example); }, 1000)

我们对指定的计算属性的cahce设置为false,这样就不会缓存之前的计算结果了,每次都 可以调用vm.example的getter方法,如图20-9所示。

400 Vue.js权威指南

1466767506989hello 1466767507989hello 1466767508990hello 1466767509989hello 1466767510987hello 1466767511988hello

图20-9 vm.example计算结果(3)

现在访问vm.example,每次返回的时间戳都是新的。但是需要注意一点,只是在JavaScript 中访问是这样的,数据仍然是依赖驱动的。如果在模板中绑定了{ {example}},只有响应依赖 vm.msg变化才会更新DOM。

接下来让我们一起从源码层面来探秘计算属性的实现。Vue实例在创建过程中会有生命周 期,其中有一个过程就是调用vm._initComputed处理computed属性。＿initComputed方法的源 码定义如下：

< !" －－源码目录：src/instance/internal/state.js--> Vue.prototype._initComputed = func巨on () { var computed= this.$options.computed

if (computed) {

for (var key in computed) { var userDef = computed[key] var def= {

enumerable: true, configurable: true

江(type of userDef ==='function') ( def.get= makeComputedGetter(userDef, this) def.set= noop

} else (

def.get= userDef.get

? userDef.cache !== false

? makeComputedGetter(userDef.get, this) : bind(userDef.get, this)

: noop

def.set= userDef.se七

? bind(userDef.set, this) : noop

第20章源码篇一深入响应式原理 401

Object.defineProperty(七his, key, def)

Vue.prototype._initComputed方法对computed属性进行遍历,拿到每一个计算属性的定义。

计算属性的定义可以是一个function,也可以是一个object。默认计算属性是一个function,只 有get方法,如果想设置计算属性的set方法或者设置cache为false,则应把计算属性定义成一 个object,计算属性的get方法默认是通过makeComputedGetter方法实现的,除非设置cache 为false。最后通过Object.defineProperty(this, key, def)方法把每个计算属性绑定到vm实例上, 访问vm上的计算属性就会调用def.get方法。接下来我们看一下makeComputedGetter方法的实 现,源码定义如下：

< !" －－源码目录：src/instance/internal/state.js--> function makeComputedGet ter (getter, owner) {

var watcher = new Watcher (owner, getter, null, { lazy: true

})

return function computedGetter () { if (watcher.dirty) { watcher.evaluate()

if (Dep.targe七) {

watcher. depend ()

return watcher.value

makeComputedGetter方法支持getter和owner两个参数。其中getter为用户定义的计算属 性的get方法;owner为当前Vue实例。首先创建一个Watcher实例,传入的option设置lazy 属性值为true,这个设置表明Watcher的求值被延迟了,并不会在创建时进行求值。接着返回 computedGetter方法,访问vm上的计算属性就会调用该方法。当watcher.dirty为true时,会调 用watcher.evaluate方法对Watcher进行计算。接下来我们看一下watcher.evaluate方法的实现, 源码定义如下：

<!" －－源码目录：src/watcher.js-->

Watcher. prototype. evaluate = function () {

// avoid overwriting another watcher that is being

402 Vue.js权威指南

// collected.

var current= Dep.target this.value= this.get() this.dirty= false Dep.target = current

Watcher.prototype.evaluate方法通过this.get方法对Watcher进行求值,同时收集依赖。接着 把this.dirty设置为false,这样当再次访问vm上的计算属性时,watcher.dirty为false,就不会 再次对Watcher求值了,因此也不会再次访问计算属性的getter方法了。

那么为何当我们修改计算属性的响应依赖时,getter方法会再次被调用呢？因为在我们第一 次调用计算属性的getter方法时,会访问响应依赖,也就触发了响应依赖的getter方法,把响应 依赖添加到当前Watcher中,也把当前Watcher订阅到依赖的变化中。所以当响应依赖被修改 时,就触发了响应依赖的setter方法,会调用Watcher的update方法。由千我们创建的是一个 lazy Watcher,所以会把Watcher的dirty属性值设置成true。这样当我们再次访问计算属性时, 会重新调用watcher.evaluate方法对Watcher求值,因此计算属性的getter方法被再次调用了。

20.6,符,结

本章主要通过源码分析的方式带大家认识了Vue」s的响应式原理,了解到模型和视图是如 何建立关联关系的、对一些ES 5检测不到的数据变化如何处理、如何初始化数据、Watcher队 列如何异步更新、计算属性如何实现等知识。

通过对Vue.js的一些内部实现细节的学习,有助千我们加深对Vue.js的理解,也会对我们 使用Vue开发组件和项目有一定的指导意义,可以避免出现一些常见问题。

第21章

源码篇一—父子类合并策略

相信在前面的组件篇中已经有同学看到了组件的mixin特性,里面也提到了两种合并 策略。

当混合对象中出现下面两种情况时：

O混合对象和组件存在同名的生命周期方法时,它们都会合并到一个数组中,混合对象的 生命周期方法优先执行,组件的同名生命周期方法后执行。

O混合对象的其他选项如methods中定义了和组件同名的方法时,组件会覆盖混合对象的 同名方法。

21.1 策略是什么

策略其实是一个对象,在全局配置config中也暴露了一个对象,开发者可以自定义：

<'－－源码目录：src/u口1/op巨ons.js -->

var strats = config.op巨onMergeStrategies = Object.create(null)

21.1.1 生命周期合并策略

当父子类同时存在同名的生命周期方法时,Vue.js内部是如何处理的呢？生命周期合并策 略如图21-1所示。

404 Vue.js权威指南

图21-1 生命周期合并策略

源码定义如下：

< !" －－源码目录：src/ut过／options. j s --> strats.init =

strats.created =

strats.ready =

strats.attached =

strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy =

strats.destroyed = function (parentVal, childVal) { return childVal

? parentVal

? parentVal.concat(childVal) : isArray(childVal)

? childVal

第21章 源码篇一一父子类合并策略 405

: [ chi ldVal] : parentVal

21.1.2 属性方法计算

相比前面的生命周期方法,我们来看看props、methods以及computed的合并策略,如 图21-2所示。

var咄"'Object.crea岭(nuH)

extend(ret, parenNal)

三

图21-2 属性方法计算的合并策略

406 Vue.js权威指南

源码定义如下：

<!" －－源码目录：src/util/op巨ons.js --> strats.props =

strats.methods =

strats. computed = function (parentVal, childVal) { 辽(!childVal) return parentVal

if (!parentVal) return childVal

var ret = Object.create(null)

ex七end(ret, parentVal)

extend(ret, childVal)

return ret

21.1.3 数据合并策略

相比前面两种模式,这种模式将MVC的Controller和MVP的Presenter改成了View Model。

View的变化会自动更新到View Model,同时View Model的变化也会自动同步到View上显示。

这种自动同步是因为View Model中的属性实现了Observer,当属性变更时都能触发对应的 操作,如图21-3所示。

源码定义如下：

<'－－源码目录：src/ut旦／options.js -->

strats. data = function (parentVal, childVal, vm) { 辽(!vm) {

// in a Vue.extend merge, both should be functions 辽(1 childVal) {

return parentVal

if (typeof childVal 1 =='function') {

process.env.NODE_ENV !=='production'&& warn( 'The "data" option should be a function'+

'that returns a per-instance value in component'+ 'definitions.'

第21章源码篇——父子类合并策略 407

return parentVal

if (!parentVal) { return childVal

// when parentVal & childVal are both present,

// we need to return a function that returns the II merged result of both func七ions... no need to II check if parentVal is a function here because

II it has to be a function to pass previous merges. return function mergedDataFn () {

return mergeData( childVal.call(this), parent Val. call (this)

) else if (parent Val I I childVal) {

return function mergedinstanceDataFn () { // instance merge

var instanceData = typeof childVal ==='function' ? childVal.call (vm)

: childVal

var defaultData = typeof parentVal ==='function' ? parentVal.call(vm)

: undefined

if (instanceData) {

return mergeData(instanceData, defaultData) ) else {

return defaultData

408 Vue.js权威指南

var defaultData = parentVal. call(vm)

var mstanceData = chilrNal

var defaultData = undefined

return defaultData

佟121-3 数据的合并策略

第22草

源码篇一—缓存

其实很多同学都看过Vue.js的源码,或者已经在前面的一些源码示例章节中看到了Cache, 本节我们就来讲述它。

比如在模板解析的源码中：

<'－－源码目录：src/parsers/template.js --> canst templateCache = new Cache(lOOO)

// stringToFragment方法中的应用

var hit= templateCache.get(cacheKey) // stringToFragment方法中的应用 templateCache.put(cacheKey, frag)

22.1 Cache有什么用

顾名思义,缓存一般可以用来放置一些数据,同时提供一些 API来操作数据,如图22-]所示。

Vue作者在Yue源码中提到Cache参考了rsms的js-lru,原文如下：

tail _keymap

图22-1 Cache对象

A doubly linked list-based Least Recently Used (LRU) cache.

Will keep most recently used items while discarding least recently used items when its limit is reached.

This is a bare-bone version of Rasmus Andersson's js-lru

一个基于LRU算法的Cache, Rasmus Andersson写的」s-lru的精简版本实现。js-lru本身提 供了更多的APL比如find、set、remove、removeAI]等。

410 Vue.js权威指南

22.2 LRU

LRU (Least Recently Used,最近最少使用),有计算机学习背景的同学可能相对比较熟悉, 类似操作系统里面的内存管理,如图22-2所示。

Illustration of the

entry

entry

entry

entry

I head I, newer => I I, newer => I I, newer => I ta让II A I I B I I C I I D I

I <= older. 1-1 <= older. 1-1 <= older. 1-1

removed <一一 <一 <一 <一 <一 <一一 <一 <一 <一 <一 <-- added

图22-2 js-lru的设计图

22.3 Cache类

Cache类包含一些基本属性和儿个原型链方法,接受一个参数limit。

< !" －－源码目录：src/cache.js#l4 -->

expor七default function Cache (limit) { this.size= 0

this.lim工t = limit

this.head=七his.tail= undefined this._keymap = Object.create(null)

22.4 put

put接受两个参数：一个key和一个value,返回被删除的。

< !" －－源码目录：src/cache.js#34 --> p.put = function (key, value) { var removed

if (this.size=== this.limit) ( removed= this.shif七()

第22章源码篇一缓存 411

var entry= th].s.get(key, true) ].f (!entry) {

entry= {

key: key

this._keymap[key] = entry if (this.ta过) { this.tail.newer= entry entry.older= this.tail } else {

this.head= entry

this.tail= entry this.size++

entry.value= value

return removed

22.5 shift

shift删除Cache里面最近最少使用的项,返回被删除的。

<'－－源码目录：src/cache.js#66 -->

shif七＝function () { var en七ry = this.head if (entry) {
this.head= this.head.newer this.head.older= undefined entry.newer= entry.older= undefined this._keymap[entry.key] = undefined

七his.size--

return entry

412 Vue.js权威指南

22.6 get

get接受参数key,返回对应的值。

< !" －－源码目录：src/cache.js#87 -->

p.ge七＝function (key, returnEntry) { var entry= this._keymap[key]

if (entry=== undefined) return if (entry=== this.ta二) {

return returnEntry ? entry

: entry.value

II EEAD--------------TAIL

I I <. older. newer>

I I <--- add direction -­I I A B C <D> E

if (entry. newer) {

if (entry === this. head) { this.head= entry.newer

entry.newer.older= entry.older// C <-- E.

辽(entry. older) {

en七ry.older.newer = en七ry.newer // C. --> E

entry.newer= undef工ned II D --x entry.older= this.tail II D. --> E 江(this. tail) {

this.tail.newer= en七ry I I E. <-- D

this.tail= entry return returnEntry ? entry

: entry.value

第23章

源码篇—一属性props

其实很多同学都使用过props配置给组件元素设置一些属性,本章我们从源码角度来分析 一下相关的具体实现。

23.1 流程设计

我们看一下初始化props的流程,如图23-1所示。

el= options el= query(el),

getBindAttr(el, attr))

图23-1 props初始化流程图

414 Vue.js权威指南

我们设计了一个d汕－list列表组件,它有两个属性：

<'-- didi-list props--> export default {

props: {

gridData: Array, fields: Array

compileProps解析后的结果如图23-2所示。

} ~ prop: 0b)ect

'mode: 0

path: "gridData"'name: "gridData"

name: name, name = "gridData" path: path, path = "gridData"

1 •options: Object

options : opmons, options = 0bject {} ►type: function Array(

mode: propBindingModes. ONE_WAY, i► _proto_: Object

raw: null ! path: "gridData"

} ;

I raw: null

attr = hyphenate(name); attr = "grid-data", name= "gridD~► _proto_: Object

阳23-2 compileProps转换gridData

gridData会通过hyphenate函数将gridData转换成符合kebab-case(短横线)规则的grid-data, 如图23-3所示。

I :：;二二二三二三厂,已霖'toLowerCase() ;

图23-3 hyphenate实现转换 如图23-4所示是filelds的转换。

图23-4 compileProps转换fields 如图23-5所示是gridData的转换成内部prop对象。

第23章源码篇一属性props 415

如图23-6所示是fields的转换成内部prop对象。

Object

dynamic: true filters: undefined mode: 0

name: "gridData" options: Object

►type: function Array() ► _proto_: Object parentPath: "gridData" path: "gridData"

raw: "gridData"

Object

dynamic.: true filters: undefined mode: 0

name: "fields"

亨options: Object

►type: function Array() ► _proto_: Object parentPath: "fields" path: "fields"

raw: "fields"

图23-5 gridData的对象prop

图23-6 fields的对象prop

23.2 属性name

其实在编译props时,会对属性name进行一些验证处理。 看下面的源码片段：

< !" －－源码目录：src/comp过er/compile-props.js -->

export function compile Props (el, propOptions, vm) { var props = [ J

var names= Object.keys(propOptions) var i = names.length

var options, name, attr, value, path, parsed, prop

while (i一一) {

name= names[i]

options = propOptions [ name J I I empty

1.f (process.env.NODE_ENV !=='production'&& name==='$da七a') { warn ('Do not use $data as prop.', vm)

continue

// props could contain dashes, which w工11 be

// interpreted as minus calculations by the parser // so we need to camelize the path here

path= camelize(name)

416 Vue.js权威指南

if (! identRE. test (path)) {

process.env.NODE_ENV !=='product工on'&& warn ( 'Invalid prop key: "'+ name +'". Prop keys'+ 'must be valid iden七ifiers.',

vm

continue

23.3 coerce

在coerce属性配置上我们可以设置转换函数。 看下面的源码片段：

<'－－源码目录：src/compiler/compile-props.js --> function coerceProp (prop, value) {

var coerce= prop.options.coerce

if (!coerce) {

return value

II coerce is a function return coerce(value)

23.4 type验证

type可以设置常见的类型,也支持自定义。

<!" －－源码目录：src/compiler/compile-props.js --> function assertType (value, type) {

var valid

var expectedType

if (type === String) {

expec七edType ='string'

valid= typeof value=== expectedType } else if (type === Number) { expectedType ='number'

第23章源码篇一属性props 417

valid= typeof value=== expectedType } else if (type === Boolean) { expectedType ='boolean'

valid= typeof value=== expectedType } else if (type === Function) { expectedType ='function'

valid= typeof value=== expectedType } else if (type === Object) { expectedType ='object'

valid= isPlainObject(value)

} else if (type === Array) {

expectedType ='array' valid= isArray(value) } else {

valid= value instanceof type

return { valid, expectedType

23.5 default

default可以设置一些默认值。 看下面的源码片段：

< !" －－源码目录：src/compiler/compile-props.js --> function getPropDefaultValue (vm, prop) {

II no default, return undefined

const options= prop.options

if (!hasOwn(options,'default')) {

II absent boolean value defaults to false

return options.type=== Boolean? false : undefined

var def= options.default

// warn against non-factory defaults for Object & Array if (isObject(def)) {

418 Vue.js权威指南

process.env.NODE_ENV !=='production'&& warn(

'Invalid defaul七value for prop"'+ prop.name+'":'+ 'Props with type Object/Array must use a factory function'+ 'to re七urn the default value.',

vm

// call factory function for non-Function七ypes

return七ypeof def==='func七ion'&& options.type !== Function ? def. call (vm)

: def

23.6 validator

validator可以设置自定义的验证函数。 看下面的源码片段：

<'－－源码目录：src/cornpiler/cornpile-props.js --> var validator= options.validator

辽(validator) {

辽(!validator (value)) {

process.env.NODE_ENV 1=='produc巨on'&& warn (

'Invalid prop: custom valida七or check failed for prop"'+prop.name+'".', vm

return false

第24章

源码篇——events

前面我们介绍过通过methods对象配置来给模板DOM元素绑定事件,那么如何在Vue.js 实例之间以及父子类之间通过事件来通信呢？我们可以通过events这个配置项来实现。

24.1 events配置是什么

其实可以理解为一个简单的配置对象：

0 Key是在实例事件比如$emit调用时传入的参数。

0 Value是处理函数(当然也可以是methods里面配置的方法名)。我们可以在Vue实例化 时通过类似methods的配置项events。

24.2 如伺配宣

和methods配置一样,也是一个对象。Key是监听的事件名称,Value是对应的处理函数。

在new Vue的实例化过程中,Vue实例会调用events对象的每一个Key,如图24-1所示。

图24-1比较大,我们可以逐步拆解,看如下代码示例：

<script>

<!-- new Vue实例化－－> var vm = new Vue ({

events: {

sayHi: function (msg) { console.log("Hello, this is:"+ msg);

}) </script>

420 Vue.js权威指南

我们在实例化时传入了一个events对象,如图24-2所示。

吨1sIBrCa1tbacks (vm, ac1lon ha的)

r.9旧可叩i achon key, h.ndI.IS)

,egisttr(Ym, act,on, k,y, handlers[,))

图24-1 events初始化流程图

第24章源码篇一events 421

已I vue．一－lnlt尸

«沁mponentEvents(this, options.切

n', options.events)

叩邱d佑贰妇(vm,配加n, hash)

图24-2 实例化methods第一步

registerCal I backs和register执行流程分别如图24-3、图24-4所示。

＊＊* Register callbacks for option events and watchers.

冷·

* @param {Vue) v•• @param {String} action * @param {Object) hash＊／

function registerCattbacks(vm, action, hash) { vm = Vue {Set: null, Sparent: undefined, $root: Vue,

if (!hasll) return;var handlers, key, i, j; handlers = function sayHi/msg丿,keytor (key in hash) { hash • Object {}

handlers • hash (key); handlers • function sayHJ/msg)if (isArray(handters)) {for (i • e, j • handlers. length; i < j; i++) { i竺register(vm, action, key, handters[i)); vm= Vue {$et: null, $parent: undefined, Sroot: Vue,

}

｀、,

图24-3 registerCallbacks执行流程图

events的$on执行流程如图24-5所示。它操作this._ events对象,把我们之前传入的sayHi 当成key,对应的处理函数当成它的处理函数。

422 Vue.js权威指南

---------------------· : • watc

．心\per to register an event/watch callback.

．

,►叩：Vue

• @param {Vue}叩

action:'飞on"

事＠ara,n ist;ing} action I key: "sa州1"

(!param {String} key►handler: function say出(彝S9
(!param {Function)String)Object) handler I options: undelined
享@par矶{Object} [options!

亨i i~ CaII SIack -"内

function register(v价,action, key, handler, options) { vm • Vue {sel: null, Sparent: u•def让ed, sroot: Vue,

vue.common.js1e881 81~

var type = typeof handler; type = "functlon'. I re9/Ster

一 旦r }ivp`;('f烹ti：沁) {．一叩} { l • _ 1

vue.common.js>e881 810

v..ction ke han r o tions. registerC汕backs

else If (type=='string'

var methods • vm.Soptions.methods; vue.commonjs1e881:80S

var method = methods && methods [handler];

if [method) {

vm[actionl Ikey, method, options);

I Vue _ImIEvents

vue.common,J$?e881:24S

} else { I Vue._lnlt

process.env.NOOE_ENV !='production'&& warn('Unkno叩毗thod: "'+ handler +"'叩en • +'re9istering,

}

[ Vu• vue.common.Js1e881 947

} else if (handler_&& type=＝工'~bject'1.. {...., I (anonymous m•in.js73479

register(vm, action, key, handler.handler, handler);

}

I functIon)

}

图24-4 register执行流程图

on the given ·event· with · fn.

ayHi"

ion sayHi/msg) nts: Objectray Ill

-+

= function sayHi(msg)

图24-5 events的$on执行流程图 events的modifyListenerCount执行流程如图24-6所示。

I.. I..Watch

• Modify the listener counts on all parents.

►vm: Vue

* Th1s bookk吐pin9 aIIows $broadcast to rcturn early vhen i event :"sayH1"

• no-child has listened to a certain event. - i hookRE.test(event): false

• count: 1

•@peram (Vue) vo 1 !parent II !count II hookRE.test(event): true

@param {String} event I !count: false
@param {Number} count
亨／ A!"

,ar hookRE • rhook, /:

i ：．二:~~tenerCount vue.common.js1e881 ~斗

n.js'e88192 n.js7e881 81II工O OO OOUKKeep上"9,ur L"C夏i,

, if (t!parent I I _!5ount I I hookRE.test(event)) return; parent. unde伍忒,count • 1,_,

re9IsterCallbac比vue.common.js?e881.81

I while (parenti-C · ·..... _.... I Vue._inltEvents vue.common.Js1e881 8(1

I parent._eventsCount[event) = (parent._eventsCount[eventl 11 0) + count; event= "s

parent = parent. sparent; i Vue.-inIt vue common.js?.881.24

匕

i Vue vue.common.js?e88194

图24-6 events的modifyListenerCount执行流程图

24.2.1 $emit触发

了解了events参数中事件是如何绑定的,现在我们来看一下如何触发它,使用$emit,语法 如下：

vrn. $emit (event, [... args])

第24章源码篇一events 423

<script>

<!-- new Vue实例化－－> var vm = new Vue({

even七s: {

sayHi: function (msg) {

console. log ('Hello, this is:'+ msg)

} })

<!-- $emit触发－－>

vm. $emit ('sayHi','DDFE') </script>

vm调用$emit的调试如图24-7所示。

Vue, prototype. $e仍it= function (event) { _event二''sayHi''

var isSource工typeof event =='string'; isSource = true event = is Source 7 event : event. name;

var cbs = this._events[event!; cbs = [function function)

var shou\dPropagate • isSource 11 !cbs; shouldPropagate = true, isSource • true if (cbs) {

cbs = cbs. length > 1 7 toArray(cbs) : cbs;

// this is • so吐what hacky solution to the question raised

// in lf2102: for an in\ine component listener like <eomp @test="doThis">, If the propagation handling is SOfllewhat broken, Therefore we

fl need to treat these inline callbacks differently.

9297l var hasParentCbs = isSource"cbs, so$eItuncmon 1cb) { hasParentCbs = fa\se, 1sSource = true, cbs = [funcmon functionl,

霖!" return cb,-tr叩Parent;

)) ;

93的if (hasParentCbs) { hasParentCbs • false

931!r shouldPropagate = false; shouldPropagate • true

93.21 }

9363 var ar s = toArraY1 arqu毗nts, 1l i · args = ("DDFE'`), arguments二["SayH心,"DDFE"1_

芯厂飞它： ：b九忙含·=l芦界。n荔芯岛{ i二0, l = 1, cbs士(心d0R functionl 一——」

93的,var res = cb,app\yIthi5, ar9s) ; res二undef1吐d, arg_s = ["DDFE"I

93&7i it I res == true &6 I !hasParentCbs 11 cb,_fromParent)) {

茄!" } shou\dPropagate = true;

931e'}

93ll1 }

9312, return shouldPropagate:

9313'};

图24-7 $emit调试

我们来看如下源码实现：

<,＿－源码目录：src/instance/api/events.js#91 -->

Vue.prototype.$emit = func巨on (even七) {

//我们传入的是字符串类型的sayHi II所以isSource返回七rue

var 1.sSource = typeof event==='s七ring' event= isSource? event : even七．name

//直接从th].s. events这个对象里面获取

var cbs = this._events[event]

//这里返回true

424 Vue.js权威指南

var shouldPropagate = is Source I I ! cbs if (cbs) (

cbs = cbs. length > 1 ? toArray (cbs) : cbs

var hasParen七Cbs = isSource && cbs.some(function (cb) ( return cb. fromParent

})

if (hasParentCbs) { shouldPropagate = false

var args = toArray(argurnents, 1)

for (var i = 0, l = cbs.length; i < l; i++) { var cb = cbs[i]

//最终还是调用apply把上面传递的参数再传给监听函数

var res= cb.apply(this, args)

辽(res ===七rue && (!hasParentCbs 11 cb._frornParent)) { shouldPropagate = true

return shouldPropagate

24.2.2 $once绑定

相比前面流程示例中的$on, $once绑定的事件只触发一次,触发完成后就删除了。 $on的语法如下：

vm.$once(event,callback)

我们来看如下源码实现：

<'－－源码目录：src/instance/api/events.js#26 --> Vue. prototype. $once = function (event, fn) { var self= this

func巨on on () {

//依赖$off

self.$off(event, on)

//最终还是apply fn.apply(this, arguments)

第24章源码篇一一events 425

on.fn = fn

//依赖$on this.$on(event, on) return this

24.2.3 $off删除

顾名思义,$off删除事件监听函数。 $off的语法如下：

vrn. $off ([event, callback])

0没有参数,删除所有的事件监听函数。

0只有事件名称,删除这个事件名称对应的所有监听函数。 0同时指定事件名称和对应的监听函数,只删除对应的。 我们来看如下源码实现：

<!-－源码目录：src/instance/api/events.js#45 --> Vue. prototype. $off = function (event, fn) { var cbs

// all

I I'0 -> true

if (!arguments. length) { if (this. $parent) {

for (event in this._ events) { cbs = this._events[event]

1.f (cbs) {

modifyListenerCount(this, event, -cbs.length)

}

//重笠所有

this. events= (} return this

// specific event

cbs =七h].s._events[even七］ ].f (!cbs) {

return this

426 Vue.js权威指南

辽(arguments. length === 1) {

//删除这个事件对应的所有监听函数

modifyListenerCount(this, event, -cbs.length) this._evenls[event] = null

return this

// specific handler var cb

var i = cbs.length while (i一一) (

cb = cbs[i]

if (cb === fn II cb.fn === fn) ( modifyListenerCount(this, event, -1) cbs. splice (i, 1)

break

return this

24.2.4 $dispatch派发

首先在实例上触发$on对应绑定的监听函数,然后沿着$parent向上冒泡。如果返回false, 就直接return了。

$dispatch的语法如下：

vm. $dispatch (event, [... args])

我们来看如下源码实现：

<'－－源码目录：src/instance/api/events.js#163 --> Vue.prototype.$dispatch = func巨on (event) {

//先调用$emit执行一次

var shouldPropagate = this.$emit.apply(this, arguments) //判断参数,false就return了

if ('shouldPropagate) return

var parent= this.$paren七

var args =七oArray(arguments)

II use object event to indicate non-source emit II on parents

args[O] = { name: event, source: this }

//沿着父链

第24章源码篇一events 427

while (parent) {

shouldPropagate = parent.$emit.apply(paren七,args) parent= shouldPropagate

? parent.$parent

: null

return七his

24.2.5 $broadcast广播

遍历当前所有$children,需要返回true,不然就中止了。 $broadcast的语法如下：

vm. $broadcast (event, [... args])

我们来看如下源码实现：

<'－－源码目录：src/instance/api/events.js#131 --> Vue. prototype. $broadcast = function (event) { var isSource = typeof event==='string'

event= isSource? even七：event.name

// if no child has registered for this event, // then there's no need to broadcast.

if (!this._eventsCount[event]) return

var children= this.$children

var args = toArray(arguments)

if (isSource) {

II use object event to indicate non-source em让 II on children

args[O] = { name: even七,source: this }

for (var i = 0, 1 = children.length; i < l; i++) { var child= children[i]

var shouldPropaga七e = child. $emi七．apply(child, args) //子类的子类必须返回true

if (shouldPropagate) (

child.$broadcast.apply(child, args)

return this

第25章 Webpack

Webpack是一个模块化加载器,它同时支持AMD、CMD等加载规范。与其他模块化加载 器相比,它具有以下优势：

1.代码分割

Webpack支持两种依赖加载：同步和异步。同步的依赖会在编译时直接打包输出到目的文件 中;异步的依赖会单独生成一个代码块,只有在浏览器中运行需要的时候才会异步加载该代码块。

2. Loaders

在默认情况下,Webpack只能处理JS文件,但是通过加载器我们可以将其他类型的资源转 换为JS输出。

3.插件机制

Webpack提供了强大的插件系统,当Webpack内置的功能不能满足我们的构建需求时,我 们可以通过使用插件来提高工作效率。

25.1 安装

全局安装,执行如下命令：

$ npm i webpack -g

除了全局安装,我们也可以将Webpack作为项目依赖在项目中进行安装。这样做的好处是, 我们可以在不同的项目中使用不同的Webpack版本。

首先,我们使用npm命令初始化npm项目,执行如下命令：

$ npm init

第25章Webpack 429

然后,运行以下命令在项目中安装Webpack,并将其写入package.json依赖字段 dev Dependencies中：

$ nprn i webpack --save-dev

25.2 基本使用

我们先来看一个最简单的基千Webpack命令行参数打包的例子。假定有以下目录结构：

example

I - app. j s I- cats.js

下面我们看看各文件内容,基于CommonJS规范引用依赖文件,代码示例如下：

// cats.js

var cats = ['dave','henry','martha'] module.exports= cats

I I app. js入口文件

cats= require('./cats.js') console.log(cats)

app.js是项目的JavaScript入口文件,Webpack将会从该文件开始对依赖文件进行打包。

我们通过Webpack命令指定要打包的入口文件app.js和最终输出文件app.bundle.js来打包 应用,执行如下命令：

$ webpack./app.js app.bundle.js

以上命令运行后,Webpack会解析依赖的文件,然后打包输出到app.bundle.js文件。图25-1 演示了Webpack打包过程。

现在我们可以在node中运行打包后的app.bundle.js文件来看看效果,执行如下命令：

$ node app.bundle.js

[ "dave", "henry", "martha")

我们在node环境中进行了演示,实际上Webpack打包后的代码可以运行在任何环境中, 包括浏览器环境。

430

Vue.js权威指南

cats.js

var cats= ['dave','henry','•artha'], codule.exports = cats;

app. js

var cats =~叭re('. /cats. js') console. \og(cats);

夕

webpack bundles the entry point and all its dependencies into a single file

webpack reads the entry point and analyzes its dependencies, its dependencies' dependencies, and so on

图25-1

webpack

MOOULE BUNOLER

app. bundle. j s

~ • － － 层层层层层 层层

! function(r)(functlon t(o)(l f(n[o])returnvar e=n[o ]=(l: o, l: ! 1, exports:{} J; return r[o J. call(

e. exports,e,e. exports, t), e. l= ! 0, e. exportsjvar n•(J; return t.a=r, t.c=n, t. p="", t(t. s=l))([ function(r, t)(

var n=[ "dave",行henry", "aartha"]; r. exports=n}, functlon (r, t,n)(cats=n(0).console. log(cats)}));

Webpack打包过程

25.3

命令行

在25.2节中,我们学习了如何使用Webpack命令进行简单打包,语法如下：

$ webpack <entry><output>

entry为要打包的入口文件路径,output为打包后的文件路径。

Webpack命令还提供了很多参数供我们自定义打包过程,下面介绍一些常用参数。 。-p,对打包后的代码进行压缩。

000

25.4

--watch,文件发生变化时,重新打包。

--config,指定Webpack打包配置文件,稍后会详细介绍配置文件。

--progress,在终端显示打包过程。

配置文件

通过Webpack命令行传参,我们可以进行简单的打包构建。对千复杂的打包,我们可以在 项目的根目录下提供一个配置文件,在配置文件中对打包过程进行更详细的配置。在项目根目 录下不提供参数直接调用webpack命令：

$ webpack

第25章Webpack 431

Webpack默认会调用项目根目录下的webpack.config.js文件,我们也可以通过－config参数 指定配置文件,执行如下命令：

$ webpack -config webpack.config.build.Js

配置文件的内容需要通过module.exports进行导出,代码示例如下：

I I webpack. confJ.g. J s module.exports= {

//配置选项

现在我们看一下Webpack中包含的配置选项,如图25-2所示。

图25-2 配置选项 接下来介绍几个常用选项的含义及用法。

25.4.1 context

context选项用来配置基础路径(必须为绝对路径),默认为process.cwd(),即运行webpack 命令的目录。

25.4.2 entry

entry选项用来配置要打包的入口文件,值可以是字符串、数组、对象。该选项指定的路径 会相对context选项指定的路径进行查找。

432 Vue.js权威指南

1.字符串

直接指定路径,该路径相对千context选项。

entry: ". /entry"

2.数组

路径数组,Webpack会按序打包,但是只导出最后一个文件。

entry: ["./en七ryl", "./entry2"]

3.对象

当entry值为对象时,键名为块名,可以随意指定,键值可以为字符串或数组类型。该块名 可以在output选项中使用,代码示例如下：

entry: {

pagel: ". /pagel",

page2: ["./entryl", "./entry2"] ),

output: {

//打包后输出文件名,name为entry中对应的键名 丘lename: " [name]. bundle. j s"

以上选项配置后,运行命令在项目根目录下会生成page 1. bundle.j s和page2.bundle.js文件。 25.4.3 output

output选项可用来配置输出信息：

output.filename

配置打包后的文件名,注意值不是绝对路径。我们应该通过output.path来指定输出路径, filename会相对output.path来输出,代码示例如下：

//单入口示例

entry:'./src/app.js',

outpu七： { filename:'bundle. j s',

第25章Webpack 433

path: dirname +'/build'

//写入磁盘路径为．／build/bundle.js

如果项目有多个入口,对于每个入口打包后的文件名我们需要保证其唯一性。Webpack提

供了以下模式来动态生成输出文件名：

0 [name],入口文件块名。

0 [hash],每个入口打包后的hash值。

0 [chunkhash],在使用代码分割时,异步加载的文件的hash值。

//多入口示例

entry: {

app:'. /src/app. js', search:'. / src/ search. j s' },

output: {

丘lenarne:'[name].js',

// filename:'[hash]. j s',

// filename:'[ chunkhash]. j s',

path: dirnarne +'/build'

//写入磁盘路径为．／build/app.js、. /build/search.js

output.path-—打包后的文件的根目录(绝对路径)。

25.4.4 module

module选项用来进行模块加载相关配置。

module.loaders——加载器数组,当依赖文件匹配指定的test模式时,Webpack会自动调用

数组中的相应加载器去处理该文件,然后返回JS格式的文件。

加载器是一个对象,该对象拥有以下属性：

0 test—正则表达式,Webpack用其去匹配相应的文件,通常用来匹配文件后缀。 0 exclude—不应该被loader处理的文件。

434 Vue.js权威指南

0 include—－个路径数组,这些路径将会被loader处理。

0 loader - test匹配到的文件对应的加载器,值是一个加载器名字字符串,多个加载器 之间用"I"分隔。

代码示例如下：

module: ( loaders: [

//匹配jsx后缀的文件 七es七： ／ ＼．j sx$/,

// include中的目录会被loader解析 include: [

path.resolve(—土rname, "app/src"), path.resolve(—中rname, "app/test") ],

I I babel loader,该loade：：：可以用来解析ES 6语法

loader: "babel-loader" //或者"babel", Webpack将会自动添加,＿loader'

25.4.5 resolve

resolve选项用来配置依赖文件的匹配,如依赖文件别名配置、模块的查找目录、默认查找 的文件后缀等。

1. resolve.alias

该选项用来配置依赖文件的别名,值是一个对象,该对象的键是别名,值是实际路径。

2. resolve.root

该选项用来指定模块的查找根路径,必须为绝对路径,值可以是路径字符串或者路径数组。

若是路径数组,Webpack会依次在这些路径中查找,如果找到则终止;否则会继续在下一个路 径中查找。代码示例如下：

// webpack.config.Js

var path = require ('path'); I I...

＿ ＿

第25章Webpack 435

resolve: {

root: [ path.resolve('./app/rnodules'), path.resolve('./vendor/modules')

3. resolve.modulesDirectories

该选项用来指定模块目录,值是一个路径数组,默认值为["web_ modules", "node_ modules"]。

25.4.6 devServer

devServer选项可用来配置webpack-dev-server的行为。以下代码用来指定服务的根路径：

devServer: {

contentBase: "./build",

25.5 开发调试

开发代码时,调试是必不可少的。我们可以使用webpack-dev-server在浏览器中进行调试。 webpack-dev-server是一个基千Express的Node」s服务器。在文件发生改变时,它会自动触 发打包过程,然后通过Socket.IO通知浏览器刷新页面,可以大大提高工作效率。

25.5.1 安装

$ npm i -g webpack-dev-server

25.5.2 启动服务

我们可以运行以下命令来启动服务：

$ webpack-dev-server

不带参数运行以上命令,默认会读取webpack.config.js进行打包,我们可以通过－config来 指定配置文件。详情请参阅25.5.3节。

436 Vue.js权威指南

25.5.3 命令行参数

所有的Webpack命令接受的参数,webpack-dev-server都可以接受。除此之外,我们还可以 向webpack-dev-server传递额外的参数。下面我们来看一些常用的参数。

0 --content-base,指定请求的根路径。

0 --host,指定服务端监听的地址可以是IP地址或者域名。当值为0.0.0.0时,可以监听一

台机器的所有IP地址,如127.0.0.1或机器在局域网中的IP地址。

0 --port,指定服务端监听的端口号。 0 --compress,启用gzip压缩。

0 --inline,自动将Socket.IO代码注入到打包后的文件中。启用该选项,当文件内容改变 时可以自动刷新浏览器。

25.5.4 配置文件

除了通过命令行传参来配置webpack-dev-server外,我们还可以通过Webpack配置文件如 默认的webpack.config.js中的devServer选项对其进行配置,所有命令行参数都支持在配置文件 中进行设定。例如：

// webpack.config.Js module.exports= {

I I...

devServer: { inline: true

25.6 1吏用插件

在Webpack提供的基本功能不能满足需求的情况下,Webpack还允许我们使用插件来控制 打包的各个过程。

第25章Webpack 437

25.6.1 安装

我们需要通过npm安装相关的插件,这里以WebpackBrowserPlugin为例,该插件用来在 Webpack或webpack-dev-server运行完成后启动浏览器。

首先安装插件,执行如下命令：

$ npm install --save-dev webpack-browser-plugin

然后在webpack.config.js中引用插件,并在插件选项中注册该插件：

// webpack.config.js

var WebpackBrowserPlugin = require('webpack-browser-plugin'); module.exports= {

plug ins: [

new WebpackBrowserPlugin() ］,

如果是Webpack内置的插件,首先需要在项目中安装Webpack,执行如下命令：

$ nprn install --save-dev webpack

然后在配置文件中引用并注册插件。这里以DefinePlugin为例,该插件可以在打包时替换 指定变量：

I I webpack. con fig. j s //首先需要引入Webpack

var webpack = require('webpack'); module.exports= {

plugins: [

//注册Webpack内置插件

new webpack.DefinePlugin({

VERSION: JSON. stringify ("5fa3b9"), BROWSER_SUPPORTS_HTMLS: true,

438 Vue.js权威指南

':'WO: "l+l",

"typeof window": JSON.s七ringify ("object")

))

］,

25.6.2 常用插件

下面介绍儿款Webpack内置的常用插件的使用,插件的安装请参阅25.6.1节。 1. DefinePlugin

DefinePlugin插件用来替换指定变量,代码示例如下：

// webpack.config.js

var webpack = require('webpack'); module.expor七s = {

plug ins: [

new webpack.DefinePlugin({

VERSION: JSON. stringify (" 5fa3b9"), BROWSER SUPPORTS HTMLS: true,

TWO: "l+l"

))

］,

//待编译的文件

console.log("Running App version"+ VERSION)//编译后：console. log ("Running App version " + "5fa3b9")

辽(!BROWSER_ SUPPORTS_ HTML5) require ("html5shi v") //编译后：if ('七rue) require ("htmlSshi v") var two= TWO//编译后：var two= l+l

2. ProvidePlugin

ProvidePlugin可以自动加载当前模块依赖的其他模块并以指定别名注入到当前模块中。假 如当前模块依赖jquery模块,同时我们想在模块中直接用"$"引用jQuery对象,但是不想手 动require jquery模块。代码示例如下：

第25章Web pack 439

//当前模块 $ (叮扛tern")

此时我们只需要在Webpack配置文件中配置ProvidePlugin插件将jquery模块导出为$变 量即可。代码示例如下：

// webpack.config.Js

var webpack = require ('webpack'); module.exports= {

plug ins: [

//自动引入jquery模块并导出为$变晶,使各个模块可以直接通过"$"来引用jQuery对象

new webpack.ProvidePlugin(( $: "jquery"

))

］,

第26章 Rollup

"Webpack 2输出的文件比起Rollup还是丑啊。但是Roll up针对非JS资成的插件生态不行, 也没有热替换,不适合用在应用层。所以现阶段我还是用Webpack做应用层开发,用Rollup做 库的打包。"

－－－尤小右

26.1 简介

在开发一个项目时,我们会将项目拆分成多个模块,每个模块完成相对独立的功能,我们 可以很方便地单独开发代码。很可能存在这种情况：项目依赖很多第三方组件,依赖组件都很 小,这对千浏览器来说是非常糟糕的,增加了许多请求;对千前端开发来说,严重影响了页面 加载速度。这种情况必须规避。

针对上面情况解决办法有很多,大多都是采用模块化开发方式,使用模块化打包工具将所 有文件最终打包到一个单独的输出文件中,大大减少了请求的数量。Browserify和Webpack就 是这样的打包工具。

使用这种打包工具很快、很好、很方便。但是我们是否注意到下面这样的问题：

var utils = require ('utils') ; var query='Rollup';

utils. aj ax ('https: I I api. example. com? search='+ query). then (handleResponse) ;

我们引入工具函数,但其实只想使用它的ajax方法,传统的打包方式是将所有代码全部打 包,造成代码冗余。

ES 6解决了这个问题,取代了引入全部工具函数,可以只引入所要使用的ajax方法。代码

第26章Rollup 441

示例如下：

import { ajax } from'utils';

var query ='Rollup'; ajax('https://api.example.com?search='+query).then(handleResponse) ;

可以很明显地体会到Tree-shaking的作用一—bundle文件中只保留了utils模块里的ajax方法。

另外,Tree-shaking会抽取引用到的模块内容,将它们置千同一个作用域下,进而直接使用 变噩名就可以访问各个模块的接口;而不像Webpack那样在每个模块外还要包一层函数定义, 再通过合并进去的define/require相互调用。

Rollup是下一代ES 6模块打包工具。它采用Tree-shaking技术,利用ES 6模块静态分析语 法树的特性,只将需要的代码提取出来打包,大大减小了代码体积。可以预见,未来的各种框 架类库都会采用ES 6语法编写。

26.2 安装

全局安装,执行如下命令：

$ npm install -g roll up

另外,如果我们在npm run script环境中使用Rollup命令,则可以使用npm I -D rollup,作 为每一个项目的依赖。

26.3 配萱

大多数选项都可以通过命令行直接指定,但是我们希望使用插件的配置文件,或者想以编 程方式设置选项。

配置文件本身只是一个JavaScript模块(我们也可以使用require和module.exports),代码 示例如下：

impor七buble from'rollup-plugin-buble'; export default {

entry:'src/main. j s', dest:'dist/bundle. j s',

format:'umd',

plug ins: [ buble () l };

442 Vue.js权威指南

将会输出umd格式的内容到dist/bundle.js文件中。

注：通过命令行指定的参数选项将会覆盖配置文件中的相应选项,如果要实现上面例子中 的配置扴出,则可以在命令行中执行如下命令·

$ -c-f umd -o dist/ bundle.cjs.js

Rollup允许一个配置文件可以有多个目标文件,我们可以生成umd格式、ES格式的文件, 都是来自同一文件,我们无须重复工作。代码示例如下：

import babel from'rollup-plugin-babel'; import babelrc from'babelrc-rollup';

let pkg= require('./package.json');

let external= Object.keys(pkg.dependencies);

export default {

entry:'辽b/index. js',

pl ugins: [babel (babel re ()) ], exter:1al: external,

targets: [

dest: pkg ['main'],

format:'umd', moduleName:'rollupStarterProj ect', sourceMap: true

},

des七：pkg ['j snext: main'], format:'es6',

sourceMap: true

};

结果目录如下：

1- dis七

1-rollup-s七arter-project.Js

1-rollup-s七arter-project.js.map 1-rollup-starter-project.rnjs.map 1-rollup-starter-project.rnjs.rnap

第26章Rollup 443

26.4 命令

在命令行中,运行rollup -h或rollup -help查看命令。 语法如下：

rollup [op巨ons] <entry file>

命令选项如下：

(1) -v

版本号。

$ rollup -v

rollup version 0.32.0

(2) -c

配置文件(默认为rollup.config.js)。如果配置文件另有其名(例如rollup.config.dev」s),在 后面加上配置文件名即可。

$ rollup -c rollup.config.dev.Js

(3) -w

监控文件变化后重新渲染文件。

(4) -i

全称： －－input。 (5) -0

全称： －－output。 (6) -f

格式化生成的包文件,全称： －－format。支持如下参数：

0 amd一异步模块定义。目前,主要有两个JavaScript库实现了AMD规范,即require.js 和curl.js。

0 cjs—CommonJS规范。

444 Vue.js权威指南

0 es6(默认)-ES6规范。

0 iile-"自执行",放入<script>标签中。 0 umd-—通用模块定义。

将index.js转换为amd格式,执行如下命令：

$ rollup --format amd -- lib/index.js > build/index.js

结果如图26-1所示。

define(['exports·], function (exports) {'use strict'; I'"巴

function add(n, m) { n + m;

}

multiply(n, m, negative=false) {巴

exports.multiply= multiply; Object.defineProperty(exports,'_esModule', { value: true});

});

图26-1 amd格式输出文件

(7) -e

全称： －－external,扩展插件。 类型：

数组[Array] 外部依赖模块包的ID列表。ID可以是：

O外部依赖项的名称。

0 resolved ID(例如一个文件的绝对路径)。 代码示例如下：

／ ／

app. J s

耳nport moment from'momen七';

setinterval (function() {

第26章Rollup 445

var times七r = moment().format('h:mm:ss a'); console.log('the time is'+ timeStr);

), 1000);

I I build. j s

import* as path from'pa七h,;

roll up. roll up ({ entry:'app.js', external: [

'moment', path.resolve('./src/special-file.js')

)). then (...)

(8) -g

全称： －－globals,全局属性,对UMD/IIFE模块有用。 类型：

Object:{ id: name} 代码示例如下：

var code= bundle.generate({ format:'iife', moduleName:'MyBundle', globals: {

backbone:'Backbone', underscore:

}).code;

(9) -n

全称： －－name, UMD/IIFE模块的名称。 代码示例如下：

var code= bundle.generate({ format:'iife',

446 Vue.js权威指南

moduleName:'MyBundle' }).code;

II-> var MyBundle = (func巨on () {...

(10) -u

全称：开d, AMD/UMD模块的止 代码示例如下：

var code= bundle.generate({ format:'amd',

module Id:'my-bundle' }).code;

I I -> define (['my-bundle'],...

(11) -m

全称： －－sourcemap,产生sourcemap。 (12)

--no-stnct

禁止生成"use strict"格式的代码。

(13) --no-indent

禁用缩进。

(14)

--environment <values>

设置传递<values>给配置文件。

注：如果使用－－environment选项,通过process.env参数调用。

代码示例如下：

// using the example above

process.env.INCLUDE_DEPS ==='true'// always a string process.env.BUILD ==='production'

(15) --no-conflict

生成UMD全局noConflict方法。

第26章Rollup 447

(16) --intro

在bundle文件最前面插入内容。

(17) --outro

在bundle文件最后面插入内容。

(18) --banner

在bundle文件最前面插入内容。 Cl 9) --footer

在bundle文件最后面插入内容。

26.5 插件

Rollup也支持使用插件,写到配置对象的plugin中即可。这里以rollup-plugin-babel为例, 代码示例如下：

].mport babel from'rollup-plug].n-babel'; export default (

entry:'src/ma].n. j s',

format:'cjs',

plug].ns: [ babel () ], dest:'rel/bundle.js'

} ;

与Webpack不同的是,babel的预设不像Webpack那样可以直接写在配置文件中,而是独 立写个"src/. babe Ire"(注意,我们可以写在src下,而不是非得放在项目根目录下)：

"prese七s": ["es2015-rollup")

注：在使用babel插件前,首先确保安装了rollup-plugin-babel和babel预设babel-preset­es2015-rollup:

$ npm i rollup-plugin-babel babel-preset-es2015-rollup

这时候就能配合babel把ES 6模块编译成ES5的bundle了。

448 Vue.js权威指南

其他常见插件列表如下：

0 alias 定义打包时所用的别名。

0 ascii 在字符串中重写非ASCII字符。

0 auto-transform——根据package.json中的键来应用Browserify自动转换,就像

Browserify做的一样。

0 babel—用Babel翻译代码。

0 bower-resolve 在Rollup中使用Bower解决算法。

0 browserify-transform 将Bowserify作为插件使用进行转换。

0 buble 用Buble(与Babel相似,但是比其快得多)翻译代码。

0 coffee-script—将coffeeScript代码转换为JavaScript代码。 0 commonjs——将CommonJS模块转换为ES6形式。

0 eslint—核实入口以及引入的脚本代码。

0 filesize-—在命令行中显示打包的文件大小。

0 hypothetical 从假想的文件系统中引入模块。

0 image—引入JPG、PNG、GIF以及SVG图片。 0 includepaths—提供引入模块的基础路径。

0 inject—检测依赖并且注入之。

0 istanbul-—使用Istanbul来处理代码覆盖。 O」son -将JSON转换为ES 6。

。jst—编译模板文件。

。jsx 编译React的JSX,以及其他类似JSX的组件。

0 memory——从内存中读取入口文件。

第26章Rollup 449

0 multi-entry一—允许有多个入口文件,而不是仅有一个。 0 node-builtins—允许在Rollup中使用Node.js内置的包。

0 node-resolve一使用Node.js模块解决方案(比如,使用以npm方式安装的来自

node_modules的模块)。

0 pe纠S—引入PEG.js语法作为语法解析。 0 postcss——编译PostCSS并且插入head中。 0 ractive-—预编译Ractive组件。

0 replace一替换一组字符串的出现。 0 riot一编译Riot.js标签文件。

0 string -将文本文件以string形式引入。

0 strip—移除调试时使用的陈述及函数,比如console.log。 0 stylus-css-modules-—－编译Stylus并且注入CSS模块。

0 typescript——将Typescript编译为JavaScript。

0 uglify—减小生成的bundle的体积。

0 vinyl一从Vinyl文件中进行引入。

0 vue-—编译Vue组件。

26.6 常见问题解析

0我们可以使用没有ES 6的依赖吗？

可以,Rollup在CommonJS模块下Tree-shaking是不能工作的,但是我们可以通过插件将 它们转换成ES 6模块。

第27章

Browserify

27.1 安装

全局安装,执行如下命名：

$ npm i -g b rowserify

除了全局安装,我们也可以将Browserify作为项目依赖在项目中进行安装,执行如下命令：

$ npm i browserify --save-dev

27.2 基本使用

与Node.js支持的CommonJS规范一样,Browserify通过require来加载依赖文件。假设有 如下目录结构：

example

I- concat.js I - log. j s

I - index. j s

I- index.html

各个文件内容如下：

//入口文件,加载相应的依赖文件

var log= require('./log.js');

var concat = require('./concat.js');

var arr= ['Just','A','Browserify','Demo','!']; log(concat(arr));

第27章Browserify 451

// log.js

module.exports~ function (s七rToLog) { console.log(s七rToLog);

II

conca七．JS

module.exports= funct].on (arr) { return arr. j o].n (,,) ;

<!--入口HTML文件－－> <!DOCTYPE html>

<html lang="en"> <head>

<meta charset="UTF-8">

<巨tle>browserify build demo</title> </head>

<body>

<'－－引入打包后的JS文件－－>

<script src="bundle.js"></script> </body>

</html>

在exmpale目录下执行以下命令进行打包：

$ browserify index.js > bundle.js

接下来我们在浏览器中打开index.html文件,可以看到控制台输出如下：

Just A Browserify Demo

27.3 转换模块

有时候直接require源文件并不能达到我们的目的,我们需要对文件进行预处理后再输出。

这时可以利用Browserify提供的转换模块机制,转换模块可以对源文件进行相应的处理后再输 出到最终文件中。

27.3.1 安装转换模块

转换模块即遵循一定规则的npm模块,所以我们直接通过npm来安装。这里以envify转

452 Vue.js权威指南

换模块为例：

(l)全局安装

$ npm install -g envify

(2)本地安装

$ npm install envify --save-dev

27.3.2 使用转换模块 1.配置方式

在package.json文件的Browserify字段指定转换模块,Browserify编译时会自动依次调用 transform数组内指定的转换模块：

"browserify": { "transform": [ "envify"] }

2.参数方式

除了在package.json中指定转换模块外,还可以在命令行中进行指定：

$ browserify entry.js -t envify> bundle.JS

我们也可以向转换模块传入参数,以下命令向envify转换模块传入NODE_ENV参数,值 为development:

$ browserify index.js -t [ envify --NODE_ENV development] > bundle.JS

27.3.3 相关转换模块介绍

Browserify生态中提供了很多转换模块供我们实现各类需求。本节介绍和Vue.js开发相关 的转换模块。

1. vueify

vueify可以让我们将组件的模板、样式、JS逻辑写在同一个文件中。 (］)安装

$ nprn install vueify --save-dev

如果使用npm 3及以上版本,需要干动安装babel依赖：

$ npm installbabel-core babel-preset-es2015 babel-runtime babel-plugin-transform-runtime --save-dev

第27章Browserify 453

使用该转换模块允许我们通过以下形式来写Vue组件,代码示例如下：

II app.vue <style> .red {

color: #fOO;

</s七yle>

<template>

<hl class="red">((msg))</hl> </template>

<script>

export default { data (I { return {

msg:'Hello world!'

</script>

也可以使用Jang来指定预处理器,代码示例如下：

// app.vue

<style lang="stylus"> .red

color #fOO </style>

<七emplate lang="jade">

hl (class="red") { {msg)) </template>

<script lang="coffee"> module.exports= data: ->

msg:'Hello world'' </script>

454 Vue.js权威指南

还可以使用src引入外部文件,代码示例如下：

<style lang="stylus" src="style.styl"></style>

// main.js,入口JS文件 var Vue = require ('vue')

var App= require('./app.vue')

new Vue ({ el:'body', components: { app: App

))

<'－－入口HTML文件－－> <body>

<app></app>

<script src="build.js"></script> </body>

(2)编译

$ browserify -t vueify -e src/rnain.js -o build/build.js

2. envify

envify转换模块用来替换代码中的有关node环境变量代码片段。这样我们就可以只在开发 环境中输出调试信息,在生产环境中由千条件判断为false,调试信息不会输出。还可以结合 uglifyify库在生产环境中将调试信息直接移除。

(I)安装

$ npm install envify browserify

(2)代码示例

// index.js

if (process.env.NODE_ENV === "development") { console. log ('development only')

第27章Browserify 455

假设当前NODE_ENV环境变量值为production,运行转换模块后将会得到：

I I bundle. j s

if ("production" === "developmen七") {

console. log ('development only')

(3)编译

通过Browserify命令行使用envify转换模块：

$ browserify index.js -t envify > bundle.JS

还可以在编译时传入自定义环境变量：

$ browserify index.js -t [ envify --NODE_ENV development] > bundle.js $ browserify index.js -t [ envify --NODE_ENV production ] > bundle.js

第28章

vue-loader

vue-loader是基千Webpack的loader,在Vue组件化中起着决定性作用。

28.1 如伺配萱

vue-loader的配置和Webpack其他loader的配置类似,对vue后缀增加处理。 配置如下：

module.exports= { entry: { app:'./src/main.js' },

module: {

loaders: [

test: /\.vue$/, loader:'vue'

其实配置还是非常简单、直观的。

28.2 包含内容

我们来看vue文件的组成。其一般包含：

0 template标签一包裹HTML模板片段。

第28章vue-loader 457

0 script标签－—配置Vue和载入其他组件或者依赖库。 0 style标签一—设置样式

代码示例如下：

<template>

<div id="app">

<p> Welcome to DDFE,We love Vue.js! </p> </div>

</template>

<script>

export default {

</script>

<style> html (

height: 100名;

</style>

28.3 特性介绍

1. template

0支持tang配置多种模板语法。

0只支待单个template标签。

2. style

0支待lang配置多种预编译语法。

0支持scope属性,这样CSS只应用到当前组件的元素中,类似千Shadow DOM,但是 不需要任何插件来支待。

0 －个vue文件中可以包含多个style标签。

458 Vue.js权威指南

0内置PostCSS和autoprefixer来自动添加浏览器前缀。 3. script

0默认支持Babel(使用babel-loader)来编译ES 6语法糖。

0对千7.0及以上版本,使用Babel 6:如果使用Babel 5,则需要使用6.x版本。 0支持通过import方式载入其他．vue后缀的组件文件。

0只支持单个script标签。

4. Hot Reload

vue文件修改后,默认支持对应的页面自动刷新。

默认内置loader的配置如下：

var defaultLoaders = { html:'vue-html-loader', css:'vue-style-loader1css-loader',

J s:'babel-loader?presets [] =es20 lS&plugins [] =transform-runtime&comments=false'

我们可以看到：

0 JS默认使用babel-loader编译,加了一些参数。 0 HTML默认使用vue-html-loader。

0 css默认使用vue-style-loader和css-loader。

28.4 常见问题解析

1.如何自定义autoprefixer

<!-- webpack.config.js --> module.exports= {

I I...

vue: {

autoprefixer: false

第28章vue-loader 459

2.如何自定义PostCSS

<!-- webpack.config.js --> module.exports= {

I I...

vue: { postcss: { //.

},

3.如何自定义style的预编译语言

<'－－第一步使用lang配置－－> <style lang="sass"> </style>

<'－－第二步安装依赖－－>

npm install sass-loader node-sass

4.如何自定义loaders

module.exports= { module: { loaders: [

test: /\. vue$/,

loader:'vue'

},

vue: { loaders: {)

28.5 源码解析

我们先来看一下vue-loader文件结构,如图28-1所示。

460 Vue.js权威指南

图28-1 vue-loader文件结构

0主入口文件：loader.js。接受vue文件的全部内容,然后把内容content、文件名fileName 传递下去。

0内容解析文件：parser.js。首先通过调用hash函数把文件名和文件内容生成唯一的key, 然后通过cache检测,如果命中cache,就直接返回;如果没有命中,则调用parse5的 parseFragment方法对文件内容进行解析,遍历子节点内容(只处理template、style和 script节点),取出对应的特性属性Clang、src和scoped),针对空节点的script和style 也进行了优化。parser.js解析过程如图18-2所示。

我们来看一个最简单的vue文件。

<七emplate>

<div id="app">

<p>

Welcome七o DDFE,We love Vue.js1 </p>

</div>

</template>

<script>

export default {

</script>

<style> html {

height: 100%;

</style>

第28章vue-loader 461

template I style

图28-2 parser.js解析过程 通过parse5.parseFragment解析后：

{ nodeName:'#document-fragment', quirksMode: false,

childNodes:

[ { nodeName:'template',

462 Vue.js权威指南

tagNarne:'template', attrs: [],

name space URI:'ht七p://www.w3.org/1999/xhtrnl', childNodes: [],

parentNode: [Circular],

content: [Object],

location: [Object]), { nodeNarne:'#text', value:'\n\n', parentNode: [ Circular], loca巨on: [Object]),

(nodeNarne:'script', tagNarne:'script', attrs: [],

narnespaceURI:'http://www. w3. org/1999/xhtrnl', childNodes: [Object],

parentNode: [ Circular],

loca巨on: [Object]), { nodeNarne:'＃七ext', value:'\n\n',

paren七Node: [Circular], location: [Object]),

{ nodeNarne:'style', tagNarne:'style', attrs: [],

narnespaceURI:'http://www. w3. org/1999/xhtrnl', childNodes: [Object],

parentNode: [ Circular],

loca巨on: [Object]), { nodeNarne:'#text', value:'\n',

parentNode: [Circular], loca七ion: [Object])

实现template支待其他模板引擎,比如jade:

<template lang="jade"> #app

p

第28章vue-loader 463

I Welcome to DDFE,We love Vue.js! </template>

template-loader.js解析过程如下：

接受模板template的内容,然后前面传递了{ raw: true, engine:'jade'}的query参数对象,如 果engine没有设置,则直接用文件的后缀(比如这里是App.vue,取后缀就是vue)。模板的解 析还是依赖consolidate这个核心包来判断是否支持这类模板和后续的render。

这里面会检查是否安装了对应的依赖包,比如依赖jade,如果没有安装consolidate.js会在 后台抛错,如图28-3所示。

图28-3 consolidate」s寻找依赖jade抛错 style-rewriter」s解析过程如下：

接受模板style的内容,然后前面传递了{ id:'_v-llf8fl75', scoped: true}的query参数对象, 里面会判断autoprefixer的配置,调用object-assign把它的配置和用户在Webpack中配置options 的autoprefixer合并,最终还是依赖PostCSS来处理。

<!-- autoprefixer -->

var options = this. options. vue I I { }

var autoprefixOptions = options.autoprefixer

//默认自动加载,触发手动在配置文件中配罚Vue对象中的autoprefixer if (autoprefixOptions !== false) {

autoprefixOptions = assign(

{ },

// also respect autoprefixer-loader options 七his.options.autoprefixer,

autoprefixOptions

var autoprefixer = require ('autoprefixer') (autoprefixOptions) plugins.push(autoprefixer)

我们重点看一下配置scoped的处理实现。

464 Vue.js权威指南

<1-- App.vue --> <template>

<div id="app">

<p>Welcome to DDFE,We love Vue.js!</p> </div>

</template>

<style scoped>

#app {

text-align: center;

</style>

编译后：

<div id="app" _v一llf8ff75>

<p _v-llf8ff75>Welcome to DDFE,We love Vue.js!</p> </div>

#app[_v-llf8ff75] {

text-align: cen七er;

源码如下：

<!-- loader.js中提到了id的生成规则－－> var hash = require ('hash-sum')

var filePath =七his.resourcePath

var rnoduleid ='_v-'+ hash(filePath)

<!-- styl

e-rewriter.js -->

var addid = postcss.plugin('add-id', function (opts) { return function (root) {

root.each(funct工on rewriteSelector (node) { 辽(!node. selector) {

// handle media queries

辽(node.type==='atrule'&& node.name==='med豆') { node.each(rewriteSelector)

return

第28章vue-loader 465

node.selector= selectorParser(func七ion (selectors) { selectors. each (function (selector) {

var node= null

selector. each (function (n) {

if (n.type !=='pseudo') node= n

})

selector.].nser七After(node, selectorParser.attr].bute ({ attribute: op七s.id

}))

}) }).prc:,cess(node.selector).result

})

})

if (query. scoped) { plugins.push(addid({ id: query.id }))

28.6 工具包介绍

上面我们已经陆续提到了一些vue-loader中使用的不错的第三方工具包。

0 PostCSS,主要用来处理vue文件中style部分的一些特性解析,比如scoped等。

0 autoprefixer,其实它就是PostCSS最流行的插件,使用caniuse站点的数据自动给一些

CSS规则添加浏览器前缀。

0 postcss-selector-parser,提供一些API来解析选择器。 0 source-map,生成sourcemap的工具包。

0 vue-template-validator,处理Vue.js模板template在编译器中的一些错误。

0 consolidate,模板引擎合集,支持市面上基本所有的模板引擎,比如jade、doT.js、ejs 等。

0 parse5, HTML语法解析工具。

466 Vue.js权威指南

0 object-assign,来自大名鼎鼎的sindresorhus作品,一个ES 5 Object.assign()的polyfill, 不过不覆盖原生方法。

0 lru-cache,支持least-recently-used算法的cache工具包。 0 hash-sum,非常快速的唯一hash值生成器。

0 de-indent,从代码块中删除多余的indent。

0 loader-utils, Webpack loader的依赖库,提供很多常用的方法,比如parseQuery等。

第29章

PostCSS

PostCSS是一个用JavaScript插件来转换CSS的工具,目前已经有200名插件,这些插件 可以lint CSS,支持变量、mixins、内联的图片等。

简单来说,PostCSS可以将CSS转换为JavaScript能够处理的数据格式,基于JavaScript所 写的插件可以完成上述各种操作。PostCSS为这些插件提供了接口,方便其完成各自的功能, 但是不会对CSS代码做任何修改。从理论上讲,PostCSS的插件可以对CSS进行任何操作,只 要我们有需求,就可以写一个JavaScript插件米实现。

29.1 安装

PostCSS针对不同的构建工具提供了不同的安装工具。在Webpack中该工具名为 postcss-loader,全局安装方式如下：

$ npm install -g postcss-loader

除此之外,当需要用到PostCSS的插件时,也可以使用npm安装。比如,大名鼎鼎的 autoprefixer安装方式如下：

$ nprn install autoprefixer

29.2酉B置

PostCSS一般与Gulp、Webpack等构建工具搭配使用。在vue-loader中使用PostCSS时, 需要在webpack.config.js中进行配置。当需要使用PostCSS的插件时,在vue选项中向postcss

468 Vue.js权威指南

设置选项传入一个数组,比如使用CSSNext插件的配置代码示例如下：

// webpack.config.js module.exports= {

I I other con figs... vue: {

II use custom postcss plugi勹S

postcss: [require ('postcss-cssnext') ()], II disable vue-loader autoprefi江ng.

II this is a good idea since cssnex七comes with it七00. autoprefixer: false

除了提供一个数组用千存放引用的数组外,postcss设置选项还可以接受： O一个可以返回插件数组的函数。代码示例如下：

postcss: function () {

return [precss, autoprefixer];

0一个对象,该对象包含将被传给PostCSS处理器的设置选项。代码示例如下：

postcss: {

plugins: [... ], // lis七of plugins options: {

parser: sugarss // use sugarss parser

29.3 命令

在命令行或者npm scripts中使用PostCSS需要额外安装postcss-cl i,其安装方式如下：

$ npm install postcss-cli

语法如下：

postcss [options] [-o outpu七－file 1-d output-directory 1-r] [input-file]

第29章PostCSS 469

命令选项如下：

(1) --outputj-o

指定输出文件。如果没有指定输出文件,则PostCSS会写入到stdout,但是对输出文件位 置有依赖的插件将无法正确工作。

相似的,如果输入文件没有指定,PostCSS将会从stdin读入,对输入文件位置有依赖的插 件将无法正确工作。

(2) --dirj-d

指定多个输出文件的位置。需要指定－－output、--dir或者－－replace选项,但不是三者都需要 被指定。在提供了多个输入文件的情况下需要使用－－dir或者－－replace。

(3) --replacej-r

用生成的输出文件替换单个或者多个输入文件。需要指定－－output、--dir或者－－replace选项, 但不是三者都需要被指定。在提供了多个输入文件的情况下需要使用－－dir或者－－replace。

(4) --usej-u

指定要使用的插件。可以指定多个插件,使用－－use选项或者在config文件中至少需要指定 一个插件。

(5) --mapJ-m

激活生成sourcemap。默认设置是生成行内映射。如果要在其他的．map文件中生成

sourcemap,使用－－mapfile或者－－no-map. in line命令。

还可以使用更多的sourcemap选项,例如：

0 --no-map—不要生成sourcemap,即使之前已有map存在。

0 --map.annotation <path>——指定可选的用千附加在CSS后面的sourcemap注解的路径。 0 --no-map.annotation—禁止添加CSS的注解。

0 --no-map.sourcesContent一—从map中移除原始的CSS。 (6) --local-plugins

从当前工作目录的node_ modules文件夹开始寻找插件。如果没有这个选项,postcss-cli将

470 Vue.js权威指南

会从其安装位置的node_ modules文件夹开始寻找插件一确切地说,在postcss-cl i是全局安装 的情况下,它将会寻找全局安装的插件。

(7) --watchl-w

监视文件系统的改变并且当源文件更改时重新编译。

当行内CSS被引入时,将向JavaScript配置文件中添加一个更新处理器,来保证引用的模 块被纳入考量。代码示例如下：

"pos七css-import": {

onimport: function(sources) { global.watchCSS(sources, this.from);

对postcss-import来说,该处理器会被自动添加。 (8) --configi-c

指定内容为插件配置的JSON文件,插件的名称作为键。代码示例如下：

"autoprefixer": { "browsers": "> 5%"

},

"postcss-cachify": { "baseUrl": "/res"

如果函数允许作为插件的参数,那么JavaScript配置也可以使用。代码示例如下：

module.exports= { "postcss-url": {

url: function (url) { return "h七tp://example.com/" + url;} },

autoprefixer: { browsers: "> 5%"

.' ．

第29章PostCSS 471

可选的配置选项可以作为－－plugin.option的参数。

注意,命令行选项也可以在配置文件中进行指定。代码示例如下：

"use": [ "autoprefixer", "postcss-cachify"], 归nput": "screen. css",

"outpu七":"bundle.css", "local-plugins": true,

"au七oprefixer": (

"browsers": "> 5%"

},

"postcss-cachify": { "baseUrl": "/res"

(9) --syntaxl-s

将可选的模块作为定制的PostCSS语法使用。

Cl O) --parserl-P

将可选的模块作为定制的PostCSS输入解析器使用。

(11) --stringifierl-t

将可选的模块作为定制的PostCSS输出转换器使用。

C 12) --helpl-h

显示帮助信息。

29.4 插件

0 autoprefixer, PostCSS最知名的插件,其作用是为CSS中的属性添加浏览器特定的前缀。 0 cssnext,该插件允许开发人员在当前项目中使用CSS将来版本中可能会加入的新特性。

cssnext负责把这些新特性转译成在当前浏览器中可以使用的语法。在这些新特性中也 包含了autoprefixer的功能,所以当使用了cssnext后就无须再使用auto prefix er了。

472 Vue.js权威指南

0 precss,包含了能够使用类似Sass中的变量、嵌套、混合等功能的插件。 0 postcss-sorting,对CSS内容按照指定规则排序。

0 short,添加并且扩展很多的简写属性。

0 postcss-use,在当前样式表中直接使用PostCSS的插件。 0 postcss-assets,插入图像尺寸以及内联文件。

0 postcss-sprites,生成图像雪碧图。

0 font-magician,生成所有CSS中需要的＠font-face规则。 0 postcss-inline-svg,内联SVG图片并且定制其样式。

0 postcss-write-svg,直接在CSS中书写简单的SVG。

0 stylelint,模块化的CSS样式检查器。

0 stylefmt,根据stylelint自动格式化CSS的工具。

0 doiuse,根据Can IUse的数据来检测CSS的浏览器支持度。 0 colorguard,帮助开发者维护一个统一的调色板。

第30章

拓展篇

30.1 Composition Event

Compos山on Event,中文译为"复合事件",是DOM 3级事件中新添加的一类事件类型, 用于处理IME的输入序列。IME (Input Method Editor,输入法编辑器)可以让用户输入在物理 键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。因为以上所述原因, 复合事件很少被拉丁系语言输入的开发者所知(因为拉丁字母都能通过物理键盘输入)。当然, 即使是使用非拉丁系语言比如中文作为输入的开发者,也不见得了解复合事件,因为在开发中 用到该种事件类型的情况比较少见。

IME复合系统的工作原理是：缓存用户的键盘输入,直到一个字符被选中后才确定输入。

缓存的键盘输入会暂时展示在输入框中,但不会真正被插入到DOM中,如图30-1所示。但是 如果在复合事件的过程中改变了输入框的值(比如切换了输入法或者直接按下Enter键),复合 事件将提前结束,同时缓存的键盘输入值将会插入到输入框中。

图30-1 缓存键盘输入 复合事件类型包含以下几种事件：

0 compositionstart一在IME的文本复合系统打开时触发。

0 compositionend—在IME的文本复合系统关闭即用户选中了字符并确定输入时触 发,表示返回正常键盘的输入状态。

474 Vue.js权威指南

0 compositionupdate—一在compos山onstart事件触发后、compos山onend事件触发前这 段时间内,每次向输入字段中进行输入时均会触发。

注：input事件将在复合事件后触发。

但是,实际情况与理想还是有一定距离的,复合事件的兼容性比较一般。如图30-2所示是 MDN中列出的兼容性表现,详情可参见https://developer.mozilla.org/en-US/docs/Web/API/ CompositionEvent。

Browser compatibility

Desktop

Feature

Browser compatibility

, MQhle

Opera Safar,氏ature知dro,a

Rrefox Mobile IE Opera Safari

IGec心)Mobile Mobile Mobile

BaSC IYes, 9 0(90) (Y心1

supp"'

`xs"P印md

Ba又C 如p如

90(90(

图30-2 复合事件的兼容性表现

综上所述,在使用复合事件处理input相关问题时,仍然需要慎重。

30.2 ES 6

ECMAScript 6(以下简称ES 6)是JavaScript语言的最新一代标准,发布千2Ol5年6月, 因为ECMA委员会决定从ES 6起每年更新一次标准,因此ES 6被改名为ES 2015,后面的标 准将按照发布年份命名,如ES 2016、ES 2017等。

关千EC MA Script与JavaScript的关系,简单来说,前者是后者的规格,后者是前者的一种 实现。通俗点说,就是后者是前者的一种方言。在通常情况下,二者之间可以划等号。

ES 6是JavaScript的一次极为重大的更新,引入了很多新特性,这些特性解决了JavaScript 长久以来被开发者所诉病的许多缺点。同时,ES 6也给JavaScript的语法带来了重大变革,它 们使JavaScript变得更加强大、更富有表现力。尽管属千重大升级,但ES 6仍然秉持了最大化 兼容已有代码的设计理念,因此采用ES 5及之前标准编写的JavaScript代码在ES 6的环境下将 继续正常运行。

由千发布日期尚短,当前主流的浏览器对ES 6还没有全面支待,不过好消息是支待程度正 在逐渐提高,目前在各大浏览器的最新版本中ES 6的大部分特性都已经实现。而Node.js对 ES 6的支持性还要优于浏览器,通过node可以体验更多ES 6的特性。我们也可以使用Babel 等JavaScript预编译器将ES 6代码转换为ES 5代码,从而在现有环境中执行。

第30章拓展篇 475

下面将简单介绍Vue.js源码中大量采用的ES 6的新特性一模块、let和const。

30.2.1 模块

历史上,JavaScript一直没有模块的概念,这会导致当项目大到一定程度时JavaScript代码 将变得难以复用且极难维护。因此,在相当长一段时间内,对千大型复杂项目来说,JavaScript 基本从一开始就被排除在方案之外。环顾其他开发语言,如Python的import、Ruby的require等 都确保了模块功能的实现,唯独JavaScript在官方标准上一直缺少对模块的定义,直到ES 6的出 现。

在ES 6发布之前,开发者社区就制定了一些模块加载的方案,其中使用最广泛的是 CommonJS (node模块化加载)规范和AMD (RequireJS)规范。前者用千服务器环境,后者则 专注于浏览器环境。

如今,ES 6从官方标准中带来了模块化开发规范。下面主要介绍ES 6模块化开发当中最重 要的export和import概念。

1. export

在ES 6中,一个文件就是一个模块,一个模块内部的所有变量,对千外部来说是无法获取 的,除非使用关键词export对外暴露接口,暴露的各接口通过名字来进行区分。如以下示例代 码,lib.js模块通过sqrt、square、diag向外界暴露三个接口。

//------ lib.js ------

暴霹三个接口给外界

export canst sqrt= Math.sqrt; export function square (x) (

return x * x;

export func己on diag (x, y) {

re七urn sqrt(square(x) + square(y));

export也可以采用下面的方式暴露接口：

I/------ lib. j s ------

const sqrt= Math.sqrt;

476 Vue.js权威指南

function square (x) { return x * x;

function diag (x, y) {

return sqrt(square(x) + square(y));

//通过export暴露接口的第二种语法,使用大括号指定要暴霹的接口 export {sqrt, square, diag};

建议采用第二种方式,因为其结构清晰,模块暴露了哪些接口一目了然。

在通常情况下,export暴露的接口就是其本来的名字,不过可以采用as语法进行别名export, 这种导出方式可以将一个接口通过n个名字对外暴露。代码示例如下：

//------lib.JS------

const sqrt= Math.sqrt;

//通过两个别名对外界暴露

export {sqrt as sql, sqrt as sq2};

注：在ES 6模块规范中,如果b模块从a模块导入一个原始值后,在a模块中修改了这个 原始值,那么b模块中的值也会与a模块中最新的值保持同步,即export暴露的接口与其在模 块内部对应的值是一种动态绑定的关系,通过接口可以获取模块内部实时的值。

2. import

使用export命令对外暴露接口以后,其他JavaScript文件就可以通过import命令加载这个模 块(文件)。在main.js模块中就可以通过import引入上一节中lib」s暴露的接口,代码示例如下：

／ ／

------main.JS------

/*

通过import语法从lib模块中导入所需要的接口 注意大括号中的接口名必须在lib. js模块中

通过export关键词导出

*/

import { square, diag } from'./lib'; console.log(square(ll)); // 121 console.log(diag(4, 3)); // 5

import也可以采用as语法对引入的变量重命名,代码示例如下：

//------ lib.js -----

export var rnyVarl ='varl';

第30章拓展篇 477

//----- main.js -----

import {myVarl as myCustomVarl} from'./lib'; console.log(myCustomVarl);

import会执行加载的模块,因此有空import的语法。代码示例如下： //只加载执行模块,不引用任何接口

import'lib'

import还可以整体加载模块,达到命名空间的效果。代码示例如下：

//------ lib.js -----

export var myVarl = · · ·; export let ~yVar2 = · · ·; export const MY_CONST = · · ·;

export function myFunc () {

export function* myGeneratorFunc () {

export class MyClass {

II

-----main.JS-----

import * as lib from'. I lib'; console.log(lib.myVarl); console.log(lib.myVar2);

new lib. MyClass () ;

3. export default

上面使用的export有一个小问题,即使用模块接口的人必须要知道该模块export了哪些接 口。有时候一个模块实际上只对外暴露一个接口,这时候实际上没必要再限定暴露的接口名字, 那么在ES 6中可以使用export default语法让模块调用者自定义要导入的接口名字。代码示例如 下：

／ ／

------ myFunc.js ------

export default function () (}

478 Vue.js权威指南

//------ mainl.js ------

/*

注意：myFunc不能包含在{)里;myFunc可以替换为任意喜欢的名字 */

import myFunc from'myFunc'; myFunc();

本质上,export default就是输出一个名为default的变量或方法,然后系统允许我们进行重 命名。代码示例如下：

// lib.js

function add (x, y) { return x * y;

export {add as default};

//等同千

II export default add;

／ ／' main. J s

import { default as myAdd} from'lib';

//等同千

I I import myAdd from'lib';

使用export default命令,我们可以很直观地引入模块,比如引用jquery模块时可以这 样写：

import $ from'j query';

4. export/import在Vue.js中的使用

Vue.js采用export/import进行模块化开发,文件通过export暴露接口,通过import引用其 他文件的内容。Vue.js的源码结构优雅、层级严谨,而这一切都离不开export和import。

举例来说,Vue.js的入口文件是／src/index.js,该文件开头如下：

耳nport Vue from'. / instance/vue'

import installGlobalAPI from'./global-api'

import { inBrowser, dev七ools } from'./util/index' import config from'./config'

第30章拓展篇 479

index.js从其他4个文件引用了必要的变量和方法。进入其引用的第一个文件／src/ instance/vue.j s中,我们可以看到,其采用了export default命令：

export default Vue

也有不采用export default方式暴露接口的,比如在/src/filters/array- filters.j s中采用以下语法 对外暴露了三个函数方法：

export function lirni tBy (...) {), export function filterBy (...) {), export function orderBy (...) {)

在src/filters/index.j s中引入上述三个函数：

import { orderBy, filterBy, limitBy } from'./array-filters'

30.2.2 let

代码中任何一对花括号({和})中的语句集都属千一个块,其中定义的所有变量在代码块 外都是不可见的,我们称之为块级作用域。在ES 5及之前的版本中均不存在块级作用域,只有 全局作用域和函数作用域。由此带来的问题很多,比如内层变量可能覆盖外层变噩、用千计数 的循环变量泄露为全局变蜇等。以往,开发者往往要通过闭包等方式来模拟块级作用域,尤为 烦琐。let关键词的出现为JavaScript带来了期盼已久的块级作用域。

1. let的使用

let的作用是声明变量,用法类似于var。与var所不同的是,let声明的变量只在let命令所 在的代码块内有效。代码示例如下：

let a='ddfe';

var b ='di<扛Family';

a; II ReferenceError: a is not defined b; I I'didiFamily'

在用let声明的a的代码块之外调用a会报错,而用var声明的b则可以返回正确值。这表 明let声明的变量只在其所在代码块内有效。

let很适合用来声明循环变蜇,代码示例如下：

for (let i = 0; i < 10; i++) {

480 Vue.js权威指南

// i只在for循环体内有效

console.log(i); // ReferenceError: i is not defined

let不允许重复声明。在相同作用域内,重复声明同一个变噩会报错。代码示例如下：

let a ='ddfe';

let a='d辽让Familyt'//报错

let a ='ddfe';

var a='di土Familyt'//报错

let不存在变量提升。因此,变量需要在声明后才可以使用,否则会报错。代码示例如下：

console.log(foo); //输出undefined

console.log(bar); //报错ReferenceError

var foo ='ddfe'; let bar ='ddfe';

let存在暂时性死区(temporal deadzone,以下简称TDZ),即指在当前代码块内如果使用了 let声明变量,则在该条声明语句之前,该变量不可用。代码示例如下：

江(true) { II TDZ开始

tmp ='ddfe'; II ReferenceError console.log(tmp); II ReferenceError

let tmp; // TDZ结束 console.log(tmp); // undefined

tmp = 123; console.log(tmp); // 123

2. let在Vue.js中的使用

由千使用let具有严谨、不易发生错误同时含有块级作用域等诸多优点,在Vue.js中运用let

第30章拓展篇 481

命令的情况比比皆是。比如：

//在src/config.js文件中保存了全局配控信息 let delirni ters = ['{ {','} }']

let unsafeDelirniters = ['{{{',')}}']

再比如,在/src/batcher.js文件中,runBatcherQueue函数中的for循环变蜇也是采用let声 明的：

function runBatcherQueue (queue) {

II do not cache leng七h because more watchers might be pushed II as we run existing watchers

for (le七i = 0; i < queue.length; i++) {

queue.length= 0

30.2.3 const

1. const的使用

const用于声明一个常量,一旦声明,常量的值便不能再被更改,进入只读模式。代码示例 如下：

canst PI= 3.141; PI// 3.141

PI= 3;

PI // 3. 14 L 重新赋值无效,PI值不变

在严格模式下,对已使用const声明的变量重新赋值甚至会报错,提示"TypeError:'xxx'is

read-only"。

使用const声明后不得再更改的特性,也意味着我们在声明变量时就必须初始化,不能留 到以后再赋值。代码示例如下：

const ddfe;

ddfe ='wonderful'; II重新赋值无效 ddfe II undefined

在严格模式下,使用const声明变量不赋值会报错,提示"SyntaxError: missing = in const declaration"。

const的作用域与let相同只在声明所在的块级作用域内有效。

const与let一样,同样不允许重复声明,不存在变量提升以及TDZ。

482 Vue.js权威指南

此外,还需要注意的是,const在声明复合类型的变量时,只能保证变童名指向的地址不变, 并不保证该地址的数据不变(因为复合类型的变量名指向数据地址而不指向数据)。因此,如果 使用const声明一个对象,并不能保证对象不可更改。代码示例如下：

canst ddfe = {}; ddfe.age = 4; ddfe. age // 4

ddfe = (}; // TypeError: "foo" is read-only

由上例可以看到,使用const声明一个对象ddfe后,对象内的属性仍然可以修改。但不可

改变ddfe指向的对象地址。

如果真的想达到对象本身不可变的效果,则应当使用0 bj ect. freeze方法,在此不展开介绍。 2. canst在Vue.js中的使用

在Vue.js中对千一些常用的变量都采用了const方式声明。比如在src/transition/transition.js 中,对trans山on的动画类型的声明便采用了const命令。代码示例如下：

const TYPE_TRANSITION ='transition' cons七TYPE ANIMATION='animation'

再比如,很多正则检测用的变量,也都使用const声明,因为这些都是一经声明就不再更 改的常量。代码示例如下：

II srcl

src/compilerlcompile.js

canst bindRE = /Av-bind: I A: I con st onRE = I Av-on: I A@I

canst dirAttrRE = /Av-([A:]+)(?:$1:(.*)$)1 canst mod辽ierRE = I\. [A\.]+lg

canst transitionRE = IA (v-bind: I:) ?transition$I

// src/filters/index.Js

con st digitsRE = / (\d { 3}) (?=\d) /g

30.3 object

1. Object.create

语法：Object.create(proto, [ propertiesObject])

第30章拓展篇 483

参数：

0 proto－一一个对象,作为新创建对象的原型。

0 propertiesObject——可选。该参数对象是一个数组与值,该对象的属性名称将是新创 建的对象的属性名称,值是属性描述符。

注：该参数对象不能是undefined。另外,只有该对象自身拥有的可枚举的属性才有效,也

就是说,该对象的原型链上属性是无效的。

抛出异常：如果proto参数不是null或对象值,则抛出一个TypeError异常。 用法：创建一个拥有指定原型和若干指定属性的对象。

使用举例：

//下面的例子演示了如何使用Object.create()来实现类式继承。这是一个单继承

II Shape - superclass function Shape () (

this.x = O; this.y = O;

Shape.prototype.move= funct).on(x,y) ( this.x += x;

this.y += y;

console.).nfo("Shape moved.");

};

// Rectangle - subclass function Rectangle () {

Shape.call(this); II call super constructor

Rectangle.prototype= Object.create(Shape.prototype);

var rect = new Rectangle();

rect instanceof Rectangle// t工ue rect instanceof Shape II true

rect.move(l, l); // Outputs, "Shape moved."

484 Vue.js权威指南

Vue.js应用举例：

// src/global-api.js

// Vue.extend用千创建基础Vue构造器的"子类" Vue. extend - function (extendOptions) {

var Sub = createClass (name I I'VueComponent') Sub.prototype= Object.create(Super.prototype) Sub.prototype.constructor= Sub

2. Object.keys

语法：Object.keys (obj) 参数：

0 obj—一返回该对象的所有可枚举自身属性的属性名。

用法：返回一个字符串数组,其元素来自于给定对象上可枚举的属性。这些属性的顺序与 手动遍历该对象属性时的一致。

使用举例：

var arr= ["a", "b", "c"];

alert(Object.keys(arr)); //弹出"0, 1, 2" //类数组对象

var obj = { 0 : "a", 1 : "b", 2 : "c"}; alert(Object.keys(obj)); II弹出"0, 1, 2" II getFoo是一个不可枚举的属性

var my_o切＝Object. create ({ l, { getFoo : { value : function () { return this. foo } } }) ; my_obj. foo = 1;

alert(Object.keys(my_obj)); II只弹出foo

Vue.js应用举例：

II srclut旦／lang. J s

II Mix proper巨es i吐o target object export function ex七end (to, from) {

var keys= Object.keys(frorn) var i = keys.length

while (i--) {

to[keys[i]] = frorn[keys[i]]

第30章拓展篇 485

return to

3. Object.isExtensible

语法：Object.isExtensible(obj)

参数：

0 Obj {Object}

用法：判断一个对象是否是可扩展的(是否可以在它上面添加新的属性)。在默认情况下, 对象是可扩展的,即可以为其添加新的属性并且其_proto—属性可以被更改。 Object.preventExtensions、Object.seal或Object. freeze方法都可以标记一个对象为不可扩展的 (non-extensible)。

注：在ES 5中,如果参数不是对象类型,将抛出一个TypeError异常。在ES 6中,非对象 参数将被视为一个不可扩展的普通对象,因此会返回false。

使用举例：

//新对象默认是可扩展的

var empty = {};

Object.isExtensible(emp七y) ; I I === true

//．．．可以变得不可扩展

Object.preventExtensions(empty); Object.isExtensible(empty); //===false

//密封对象是不可扩展的

var sealed= Object.seal({}); Object.isExtensible(sealed); //===false

//冻结对象也是不可扩展的

var frozen= Object.freeze(()); Object.isExtensible(frozen); //===false

Vue.js应用举例：

II srcld江ectiveslpubliclfor.Js

486 Vue.js权威指南

II Cache a fragment using track-by or the object key cacheFrag (value, frag, index, key) (

var trackByKey = this.params.trackBy

var cache= this.cache

var primitive= !isObject(value) var id

江(key I I trackByKey I I primitive) (

过＝getTrackByKey(index, key, value, trackByKey) if (!cache[id]) {

cache[id] = frag

} else江(trackByKey 1 =='$index') ( process.env.NODE_ENV !=='production'&& this.warnDuplicate(value)

} else (

id= this.id

江(hasOwn(value,过)) ( 江(value[id] === null) { value[id] = frag

} else {

process.env.NODE ENV 1=='

production'& &

this.warnDuplicate(value)

} else江(Object. isExtensible (value)) ( def(value,过,frag)

} else辽(process.env.NODE_ENV !=='produc巨on') ( warn(

'Frozen v-for objects cannot be

automatically tracked, make sure to'+

'provide a track-by key.'

frag.raw = value

4. Object.getOwnPropertyNames

语法：Object.getOwnPropertyNames(obj)

参数：

0 Obj {Ob」ect}

用法：返回一个由指定对象的所有自身属性的属性名(包括不可枚举的属性)组成的数组。

数组中枚举属性的顺序与通过for... in loop(或Object.keys)迭代该对象属性时的一致。数组中 不可枚举属性的顺序未定义。

第30章拓展篇 487

使用举例：

var arr= ["a", "b", "c");

console. log (Object. getOwnProperr.yNames (arr). sort ()) ; // [ "0", "l", "2", "length" l

//类数组对象

var obj = { 0: "a", 1: "b", 2: "c");

console.log(Objec七．getOwnPropertyNames (obj). sort ()); // [ "0", "l", "2" l

//使用Array.forEach输出屈性名和屈性值

Objec七．getOwnPropertyNames (obj). forEach (function (val, idx, array) { console.log(val +"->"+obj [val]);

}) ;

//输出

II o -> a II 1 -> b II 2 -> c

//不可枚举的屈性

var my_obj = Object.create({), { getFoo: {

value: functior. () { return七his.foe;}, enumerable: false

}) ;

my_obj.foo = 1;

console. log (Object. getOwnPropertyNames (my obj). sort ()) ;

II ["foo", "getFoo"J

Vue.js应用举例：

II srclobserverl].ndex. J s

const arrayKeys = Object.getOwnPropertyNames(arrayMethods)

5. Object.defineProperty

语法：Object.defineProperty(obj, prop, descriptor) 参数：

0 obj-—需要定义属性的对象。

0 prop—需被定义或修改的属性名。

488 Vue.js权威指南

0 descriptor 需被定义或修改的属性的描述符。

用法：该方法直接在一个对象上定义一个新属性,或者修改一个已经存在的属性,并返回 这个对象。

注：该方法的使用较为复杂,但其在Vue.js中有极为重要的应用一—Vue.js实现数据和视 图联动的核心原理便在于该方法。在第2章中有Object.defineProperty方法的详细使用介绍,在 此不再赘述。

Vue.js应用举例：

// src/util/lang.js

export function def (obj, key, val, enumerable) {

Object.defineProperty(obj, key, { value: val,

enumerable: 1 1 enumerable,

writable: true, configurable: true

}}

30.4 函数柯里化

函数柯里化(curry)过程是通过逐步传参,在每一步中返回一个更具体的部分配置的函 数的过程。通过不断传参的过程,我们可以实现对函数的高度复用。函数柯里化是利用闭包、 高阶函数特性来实现动态创建函数、参数复用的过程。柯里化可以使得代码逻辑更加清晰、 代码实现更加优雅。由千在Vue.js中大量应用了函数柯里化技术,本节我们就简要介绍一下 柯里化的使用。

30.4.1 动态创建函数

通常,我们会使用以下方式来注册DOM事件：

var addEven七＝function (el, type, fn, capture) { if (window. addEventListener) { el.addEventListener (type, function (e) { fn.call(el, e);

}, capture);

第30章拓展篇 489

} else if (window.attachEvent) { el.attachEvent ("on" + type, function (e) { fn.call(el, e);

)) ;

使用这种方式的问题是每次调用addEvent方法时,都会执行一次判断来决定使用哪个方法 注册事件。实际上,我们可以在页面载入后只进行一次判断,然后使用同一注册方法注册不同 的事件。我们使用函数柯里化来实现：

var addE.vent. =＼氐W立沁叭＼ ＼

if (window.addEventListener) {

return function (el, sType, fn, capture) \ el.addEventListener(sType, func巨on (e) { fn.call(el, e);

), (capture));

);

) else if (window.attachEven七) (

return func巨on (el, sType, fn, capture) { el.attachEvent("on" + sType, function(e) { fn.call(el, e);

)) ;

);

}) ()

以上自执行代码首先会判断浏览器支持的事件注册方法,根据不同的注册方法,返回一个 事件注册的函数赋值给addEvent,以后调用addEvent方法注册事件时,内部就不会再次进行判 断了,而是直接使用当前浏览器支待的事件注册方法来注册相应的事件。

30.4.2 参数复用

如果我们需要求10与任意数的和,则可能会这么写：

function sum (x, y) ( return x + y

sum(lO, 20); // 30 sum(lO, 55); I I 65

490 Vue.js权威指南

如上面示例所示,在多次调用同一方法时,我们会传入一个相同的参数10。如果使用函数 柯里化,我们就可以实现参数复用,代码示例如下：

func七ion sum (x) { return function (y) { return x + y

var addTen = sum(lO); addTen(20); // 30 addTen(SS); // 65